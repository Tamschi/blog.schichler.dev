<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"> <script defer="" data-domain="blog.schichler.dev" src="https://a.schichler.dev/js/script.js"></script><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Semantic FFI Bindings in Rust - Reactivating the Borrow Checker" /><meta property="og:locale" content="en" /><meta name="description" content="In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks" /><meta property="og:description" content="In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks" /><link rel="canonical" href="https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/" /><meta property="og:url" content="https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/" /><meta property="og:site_name" content="Abstraction Haven" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-31T16:10:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Semantic FFI Bindings in Rust - Reactivating the Borrow Checker" /><meta name="twitter:site" content="@tammeschichler" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks","url":"https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/","@type":"BlogPosting","headline":"Semantic FFI Bindings in Rust - Reactivating the Borrow Checker","dateModified":"2022-01-08T02:01:25+01:00","datePublished":"2020-10-31T16:10:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/"},"@context":"https://schema.org"}</script><title>Semantic FFI Bindings in Rust - Reactivating the Borrow Checker | Abstraction Haven</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Abstraction Haven"><meta name="application-name" content="Abstraction Haven"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="/assets/un-cdn/jsdelivr/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Abstraction Haven</a></div><div class="site-subtitle font-italic">Mostly Rust, sometimes mainly carbohydrates.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://ko-fi.com/tamme/" aria-label="ko-fi" target="_blank" rel="noopener" title="https://ko-fi.com/tamme/" > <i class="fas fa-coffee"></i> </a> <a href="https://tamschi.itch.io/" aria-label="itch.io" target="_blank" rel="noopener" title="https://tamschi.itch.io/" > <i class="fab fa-itch-io"></i> </a> <a href="https://github.com/Tamschi" aria-label="github" target="_blank" rel="noopener" title="https://github.com/Tamschi" > <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tamme','schichler.dev'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="xmpp:tamme@schichler.dev" aria-label="xmpp" > <i class="fas fa-comment-dots"></i> </a> <a href="https://nerdculture.de/@Tamschi" aria-label="mastodon" target="_blank" rel="noopener" title="https://nerdculture.de/@Tamschi" > <i class="fab fa-mastodon"></i> </a> <a href="https://twitter.com/tammeschichler" aria-label="twitter" target="_blank" rel="noopener" title="https://twitter.com/tammeschichler" > <i class="fab fa-twitter"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Semantic FFI Bindings in Rust - Reactivating the Borrow Checker</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 630'%3E%3C/svg%3E" data-src="/assets/img/posts/2020-12-31-Semantic FFI Bindings in Rust - Reactivating the Borrow Checker/unsafe!Ferris on Pebble (edited, scaled for blog).jpg" class="preview-img bg" alt="Unsafe!Ferris (a sea urchin) displayed in black and white on my original-generation Pebble, with a custom black watch band with red red stitched border. The watch is laid flat on a red pillow." width="1200" height="630" data-proofer-ignore><h1 data-toc-skip>Semantic FFI Bindings in Rust - Reactivating the Borrow Checker</h1><div class="post-meta text-muted"><div style="float: left; clear: left;"> By <em> <a href="https://schichler.dev/">Tamme Schichler</a> </em></div><div style="float: right; clear: right;"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/ffi/'>FFI</a></div><div class="d-flex" style="float: left; clear: left;"><div> <span> Posted <em class="timeago" date="2020-10-31 16:10:00 +0100" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 31, 2020, 4:10 PM +0100" >Oct 31, 2020</em> </span> <span> Updated <em class="timeago" date="2022-01-08 02:01:25 +0100 " data-toggle="tooltip" data-placement="bottom" title="Sat, Jan 8, 2022, 2:01 AM +0100" >Jan 8, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2703 words"> <em>15 min</em> read</span></div></div><div class="post-tags" style="float: right; clear: right;"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/patterns/" class="post-tag no-text-decoration" >patterns</a> <a href="/tags/api/" class="post-tag no-text-decoration" >api</a> <a href="/tags/walkthrough/" class="post-tag no-text-decoration" >walkthrough</a></div><div style="clear: both;"></div></div><div class="post-content"><blockquote><p>In this post:</p><ul><li>Rust references, opaque handles and ownership<li>Likely pitfalls or: <code class="language-plaintext highlighter-rouge">c_void</code> isn‚Äôt (yet) C‚Äôs <code class="language-plaintext highlighter-rouge">void</code><li>One big caveat<li>Lifetime-generic opaque references and callbacks</ul></blockquote><hr /><blockquote><ul><li>Prerequisites:<br /> The Rustonomicon‚Äôs pages on <a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html">How Safe and Unsafe Interact</a> and on <a href="https://doc.rust-lang.org/nomicon/ffi.html">FFI</a><li>Optional reading:<br /> <a href="https://en.cppreference.com/w/c/language/restrict">cppreference.com on the <code class="language-plaintext highlighter-rouge">restrict</code> type qualifier</a></ul></blockquote><hr /><p>üé® <em>The image displayed on my watch is unsafe!Ferris by @‚Äçwhoisaldeka on Twitter, first posted <a href="https://twitter.com/whoisaldeka/status/674465785557860353">here</a> under CC-BY‚Ä¶ though</em> technically <em>speaking I downscaled the SVG version that‚Äôs in the Rustonomicon.</em></p><p>I recently succeeded at writing a watch app for my old Kickstarter Pebble and made some discoveries in the process that may be interesting to others working on similar projects or FFI bindings in general. This post is part one of a two-part series, with the other (planned to be) covering some tricks you can use when wrapping an OOP C API.</p><p>üíÅ‚Äç‚ôÇÔ∏è <em>Some of the advice in this post hinges on the e.g. <code class="language-plaintext highlighter-rouge">nightly-2020-10-30</code> <code class="language-plaintext highlighter-rouge">#![feature(extern_types)]</code>. To my knowledge, there is currently no fully sound way to use fully opaque references on stable!<br /> Should the feature change, please ping me with a comment and I‚Äôll update this post accordingly.</em></p><p>A good starting point when writing FFI bindings is to transliterate the original C headers as closely as possible. For example‚Äôs sake, we‚Äôll examine a few functions from <a href="https://developer.rebble.io/developer.pebble.com/docs/c/User_Interface/Window/index.html">this page</a> of the Pebble SDK docs:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Layer</span> <span class="n">Layer</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Window</span> <span class="n">Window</span><span class="p">;</span>

<span class="n">Window</span> <span class="o">*</span> <span class="nf">window_create</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">bool</span> <span class="nf">window_is_loaded</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span> <span class="n">window</span><span class="p">);</span>
<span class="n">window_set_background_color</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="n">GColor</span> <span class="n">background_color</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Layer</span> <span class="o">*</span> <span class="nf">window_get_root_layer</span><span class="p">(</span><span class="k">const</span> <span class="n">Window</span> <span class="o">*</span> <span class="n">window</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">window_destroy</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span> <span class="n">window</span><span class="p">);</span>
</pre></table></code></div></div><p>becomes</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Layer</span><span class="p">;</span> <span class="c1">// Nightly feature: extern_types</span>
  <span class="k">type</span> <span class="n">Window</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">window_create</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Window</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_is_loaded</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Window</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_set_background_color</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Window</span><span class="p">,</span> <span class="n">background_color</span><span class="p">:</span> <span class="n">GColor</span><span class="p">);</span>
  <span class="k">fn</span> <span class="nf">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">Window</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Layer</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Window</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><a href="https://github.com/rust-lang/rust/issues/43467">Extern types</a> have a few useful properties, like not implementing <em>any</em> of the auto-traits by default. They are considered fully thread-unsafe and panic-unsafe, unless you explicitly specify otherwise. We‚Äôre dealing with a watch that doesn‚Äôt support threading at all, and also doesn‚Äôt know exceptions beyond bailing from a faulty app, so for the most part we‚Äôll ignore this aspect.</p><p>A more interesting, and unique, property is that references (<code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut</code>) to extern types are FFI-safe as slim pointers while the type itself is considered unsized.<br /> Rust normally really likes to reorganise the backing storage of references: Small values passed by reference can be ‚Äúinlined‚Äù and passed by value instead, if that produces faster or smaller code. Even data behind a mutable reference can be copied and later written back due to <a href="https://doc.rust-lang.org/nomicon/aliasing.html">Rust‚Äôs strict aliasing rules</a>. However, if the size of the data isn‚Äôt known, it <em>can‚Äôt:</em></p><h3 id="rust-preserves-pointer-identity-of-references-to-extern-types">Rust preserves pointer identity of references to extern types!<a href="#rust-preserves-pointer-identity-of-references-to-extern-types" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>That‚Äôs it, that‚Äôs the post.</p><p>‚ãÆ</p><p>No, not really. There are a few finer points to take care of here. You may have noticed that I didn‚Äôt cite any of the non-code documentation. (Examples aren‚Äôt necessary exact copies from here on out.)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/* Creates a new Window on the heap and initializes it with the default values.
 * [information about default values]
 *
 * RETURNS:
 *   A pointer to the window.
 *   `NULL` if the window could not be created.
 */</span>
<span class="n">Window</span> <span class="o">*</span> <span class="nf">window_create</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Destroys a Window previously created by window_create.
*/</span>
<span class="kt">void</span> <span class="nf">window_destroy</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span> <span class="n">window</span><span class="p">);</span>
</pre></table></code></div></div><p>Hm‚Ä¶ So this window creation function is actually fallible, but <code class="language-plaintext highlighter-rouge">window_destroy</code> expects a valid Window handle ü§î<br /> We couldn‚Äôt tell from the signature alone because in C, all pointers are nullable. The developers would have had to compromise on convenience and/or write unidiomatic code to avoid this. That <code class="language-plaintext highlighter-rouge">window_create</code> can fail but <code class="language-plaintext highlighter-rouge">window_destroy</code> expects an actual instance makes sense too: This API is the same across all watch generations that were made, which includes my ‚Äúaplite‚Äù with only 100kB RAM in total, and only 24kB for app executable and heap combined. Creating too many Windows <strong>will</strong> fail eventually.<br /> Apps will usually configure their windows, so it‚Äôs more efficient to assume they will branch once after creation than making every other function accept null pointers. On a low power device, that‚Äôs a sensible design in my opinion.</p><p>In any case, the first binding above lets us write the following unsound code without a complaint from the compiler:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">unsafe</span> <span class="p">{</span> <span class="nf">window_destroy</span><span class="p">(</span><span class="nf">window_create</span><span class="p">())</span> <span class="p">}</span> <span class="c1">// No!!!</span>
</pre></table></code></div></div><p>That‚Äôs a <a href="https://en.wikipedia.org/wiki/Segmentation_fault#Null_pointer_dereference">segfault</a> in the making.</p><p>Can we do better? In stable Rust, the answer is ‚Äúsomewhat‚Äù:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nf">Layer</span><span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">0</span><span class="p">]);</span> <span class="c1">// Extern types aren't stable as of 2020-10-31.</span>
<span class="k">struct</span> <span class="nf">Window</span><span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">0</span><span class="p">]);</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">window_create</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_is_loaded</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_set_background_color</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">background_color</span><span class="p">:</span> <span class="n">GColor</span><span class="p">);</span>
  <span class="k">fn</span> <span class="nf">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Layer</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span><span class="p">);</span>

  <span class="cd">/// Destroys a layer previously created by layer_create.</span>
  <span class="k">fn</span> <span class="nf">layer_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Layer</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It‚Äôs a bit awkward, but <a href="https://doc.rust-lang.org/stable/core/ptr/struct.NonNull.html"><code class="language-plaintext highlighter-rouge">NonNull</code></a> is FFI-safe and tells us precisely when the pointer points to actual memory. We lost the <code class="language-plaintext highlighter-rouge">const</code> qualifier on <code class="language-plaintext highlighter-rouge">window_get_root_layer</code>‚Äôs argument, but that‚Äôs an okay tradeoff to avoid a hard-to-debug segfault.</p><p>We can now use the bindings like this:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">window</span> <span class="o">=</span> <span class="nf">window_create</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span> <span class="c1">// Not elegant, but panics do create a trace!</span>
  <span class="nf">window_set_background_color</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">layer</span> <span class="o">=</span> <span class="nf">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="k">if</span> <span class="o">!</span><span class="nf">window_is_loaded</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">);</span> <span class="c1">// Oh.</span>
  <span class="nf">layer_destroy</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span> <span class="c1">// Oh no!</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That‚Äôs one conditional double free and one API contract violation üôÅ<br /> (This <code class="language-plaintext highlighter-rouge">layer</code> wasn‚Äôt ‚Äúcreated by layer_create‚Äù. We got it from the Window instance which presumably dismantles it on destruction.)</p><p>Can we do better? Not on stable. Our opaque newtypes above are zero-sized, so their address would likely be erased when handling references to them. Similarly the core type <a href="https://doc.rust-lang.org/stable/core/ffi/enum.c_void.html"><code class="language-plaintext highlighter-rouge">c_void</code></a> is, as of Rust 1.47.0, implemented as</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nd">#[repr(u8)]</span>
<span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"core_c_void"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.30.0"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="nb">c_void</span> <span class="p">{</span>
    <span class="nd">#[unstable(</span>
        <span class="nd">feature</span> <span class="nd">=</span> <span class="s">"c_void_variant"</span><span class="nd">,</span>
        <span class="nd">reason</span> <span class="nd">=</span> <span class="s">"temporary implementation detail"</span><span class="nd">,</span>
        <span class="nd">issue</span> <span class="nd">=</span> <span class="s">"none"</span>
    <span class="nd">)]</span>
    <span class="nd">#[doc(hidden)]</span>
    <span class="n">__variant1</span><span class="p">,</span>
    <span class="nd">#[unstable(</span>
        <span class="nd">feature</span> <span class="nd">=</span> <span class="s">"c_void_variant"</span><span class="nd">,</span>
        <span class="nd">reason</span> <span class="nd">=</span> <span class="s">"temporary implementation detail"</span><span class="nd">,</span>
        <span class="nd">issue</span> <span class="nd">=</span> <span class="s">"none"</span>
    <span class="nd">)]</span>
    <span class="nd">#[doc(hidden)]</span>
    <span class="n">__variant2</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That‚Äôs not unsized. It‚Äôs actually quite a bit smaller than a usual reference too, so the compiler will most likely shift this memory around a lot if we create a <code class="language-plaintext highlighter-rouge">&amp;</code> or <code class="language-plaintext highlighter-rouge">&amp;mut</code> reference to this type!</p><p>üíÅ‚Äç‚ôÇÔ∏è <em><a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">But even creating the Rust references would be undefined behaviour already</a>, if we use it as stand-in for opaque C types: We can‚Äôt be sure that the memory location contains a valid discriminant for this enum (or, for that matter,</em> exists at all<em>, but that‚Äôs secondary here). Creating a Rust reference to a (potentially) invalid value is immediately unsound, even without dereferencing it!</em></p><h3 id="there-is-a-better-way-coming">There is a better way (coming)<a href="#there-is-a-better-way-coming" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>As mentioned before, it is safe to create references to extern types regardless of their underlying data (though the API in question may limit this). With this in mind, we can rewrite our FFI bindings with full (shortened) documentation like this:</p><p>üíÅ‚Äç‚ôÇÔ∏è <em><strong>There is one important caveat to this.</strong> I‚Äôll get to it later, and it‚Äôs a bit of a nasty footgun, so please bear with me.</em></p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Layer</span><span class="p">;</span> <span class="c1">// Nightly feature: extern_types</span>
  <span class="k">type</span> <span class="n">Window</span><span class="p">;</span>

  <span class="cd">/// [information about default values]</span>
  <span class="k">fn</span> <span class="nf">window_create</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">Window</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="cd">/// True if between `load` and `unload` callbacks.</span>
  <span class="k">fn</span> <span class="nf">window_is_loaded</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Window</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>

  <span class="cd">/// This color is drawn by the window's root [`Layer`].</span>
  <span class="k">fn</span> <span class="nf">window_set_background_color</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Window</span><span class="p">,</span> <span class="n">background_color</span><span class="p">:</span> <span class="n">GColor</span><span class="p">);</span>

  <span class="cd">/// [information about layer layering]</span>
  <span class="k">fn</span> <span class="nf">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Window</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Layer</span><span class="p">;</span>

  <span class="cd">/// Destroys a [`Window`] previously created by [`window_create`].</span>
  <span class="k">fn</span> <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">Window</span><span class="p">);</span>

  <span class="cd">/// Destroys a [`Layer`] previously created by [`layer_create`].</span>
  <span class="k">fn</span> <span class="nf">layer_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">Layer</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That‚Äôs short! The functions‚Äô signatures say a lot about how to call them already, so there was room to add other information undisturbed.</p><p>Something a bit peculiar is how commonly <code class="language-plaintext highlighter-rouge">&amp;'static mut ExternType</code> appears, which is pretty unidiomatic in regular Rust. I think the best way to describe these references is as ‚Äúexclusive handle‚Äù: There are no storage limitations on them, so you can move them across the heap without problem, but once you pass them into a function (like the destructors here), they are gone.</p><p>Let‚Äôs try the previous usage example again:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">window</span> <span class="o">=</span> <span class="nf">window_create</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span> <span class="c1">// Not elegant, but panics do create a trace!</span>
  <span class="nf">window_set_background_color</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">layer</span> <span class="o">=</span> <span class="nf">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="k">if</span> <span class="o">!</span><span class="nf">window_is_loaded</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ‚Ä¶</span>

  <span class="c1">// Doesn't compile:</span>
  <span class="c1">//   cannot borrow `*window` as mutable more than once at a time</span>
  <span class="nf">window_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

  <span class="c1">// Causes issues above:</span>
  <span class="c1">//   cannot borrow `*window` as mutable because it is also borrowed</span>
  <span class="c1">//   as immutable</span>
  <span class="nf">layer_destroy</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Great! Note that this isn‚Äôt perfect - we could for example destroy the root layer if we leak the window, which could be prevented with likely zero runtime cost with additional <code class="language-plaintext highlighter-rouge">#[repr(transparent)]</code> newtype wrappers and proxy functions - but for concise FFI bindings this is a seriously low footgun density.</p><p>üíÅ‚Äç‚ôÇÔ∏è <em>This is still an unsafe API in other respects. For example, the window stack API gives out long-lived window handles that collide with handles we already hold, and there are some places where valid parameters are limited in a way Rust‚Äôs type system can‚Äôt represent directly.</em></p><h3 id="the-caveat">The Caveat<a href="#the-caveat" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is one really important rule to keep in mind when designing FFI bindings like this: <strong><a href="https://doc.rust-lang.org/nomicon/references.html">A mutable reference cannot be aliased</a></strong>. Doing so is immediately undefined behaviour.</p><p>On a safe API, this generally isn‚Äôt a problem: There would be either exactly one location to acquire an exclusive handle like this, or wrapper types that drop the restriction internally. (We can‚Äôt quite do this in a pure FFI binding, because the type in question would have to follow borrow semantics while implementing <a href="https://doc.rust-lang.org/stable/core/marker/trait.Copy.html"><code class="language-plaintext highlighter-rouge">Copy</code></a> to be passed as value.)</p><p>Here‚Äôs an example:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// This is a misleading binding!</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">window_create</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">Window</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_stack_push</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Window</span><span class="p">,</span> <span class="n">animated</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
  <span class="k">fn</span> <span class="nf">window_stack_pop</span><span class="p">(</span><span class="n">animated</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">window</span> <span class="o">=</span> <span class="nf">window_create</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">window_stack_push</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nf">window_stack_pop</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="nf">window_stack_push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">popped</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// Whoops.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the last line, <code class="language-plaintext highlighter-rouge">window</code> and the temporary mutable reference <code class="language-plaintext highlighter-rouge">&amp;mut *popped</code> are aliased. Most importantly, this was low friction on the consumer‚Äôs part, too. Not¬†good!</p><p>What went wrong? The issue here is that <code class="language-plaintext highlighter-rouge">window_stack_push</code> sets us up for retrieving the window handle later, but doesn‚Äôt take exclusive ownership of it. In C this makes sense: No part of the API is marked <code class="language-plaintext highlighter-rouge">restrict</code>, the handle stays valid after this API call and manipulating it afterwards is a common pattern.</p><p>Rust isn‚Äôt so lenient, so let‚Äôs fix the extern declarations for our purposes:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">window_create</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">Window</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">window_stack_push</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="cm">/* ‚Üê */</span> <span class="k">mut</span> <span class="n">Window</span><span class="p">,</span> <span class="n">animated</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
  <span class="k">fn</span> <span class="nf">window_stack_pop</span><span class="p">(</span><span class="n">animated</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">window</span> <span class="o">=</span> <span class="nf">window_create</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">window_stack_push</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nf">window_stack_pop</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="c1">// ‚Ä¶</span>
  <span class="nf">window_stack_push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">popped</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// Sound!</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Barely anything changed, but‚Ä¶ suddenly the program is well-formed?</p><p>The reason for this is that <code class="language-plaintext highlighter-rouge">popped</code> is now directly derived from the <code class="language-plaintext highlighter-rouge">window</code> borrow, without releasing it in the meantime. Parallel aliased <code class="language-plaintext highlighter-rouge">&amp;mut</code> references are UB, but they are also nestable and reentrant<strong>¬π</strong>, which means the code above checks out.</p><p>üíÅ‚Äç‚ôÇÔ∏è <em>A high level wrapper will probably want to reorganise the API so that it holds onto a <code class="language-plaintext highlighter-rouge">Window</code> reference independently of threading it through the C callback API mentioned further below. This can be done by downgrading it to a pointer while at rest, combined with careful (safe) API surface restrictions, but the details of that are material for another post.</em></p><h3 id="lifetime-generic-opaque-references">Lifetime-generic opaque references<a href="#lifetime-generic-opaque-references" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>In the Pebble API, certain instances reference external data. Unfortunately, extern types don‚Äôt support generics directly, so</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">type</span> <span class="n">NumberWindow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>does not compile.</p><p>üíÅ‚Äç‚ôÇÔ∏è <em>Visibilities didn‚Äôt matter much before this, so I left them out to reduce noise. I‚Äôll include them from here on out.</em></p><p>Instead, the way we can model the API correctly is as follows:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">NumberWindow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ExternData</span><span class="p">);</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">ExternData</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">CStr</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">type</span> <span class="n">void</span><span class="p">;</span> <span class="c1">// Actually like C's `void`.</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">number_window_create</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">label</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">CStr</span><span class="p">,</span> <span class="c1">// Can be changed later.</span>
    <span class="n">callbacks</span><span class="p">:</span> <span class="n">NumberWindowCallbacks</span><span class="p">,</span>
    <span class="n">callback_context</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">void</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">NumberWindow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">number_window_destroy</span><span class="p">(</span><span class="n">number_window</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">NumberWindow</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">NumberWindow</code> inherits properties from both <a href="https://doc.rust-lang.org/nomicon/phantom-data.html"><code class="language-plaintext highlighter-rouge">PhantomData</code></a> (here a variant lifetime, but no accessible data) and <code class="language-plaintext highlighter-rouge">ExternData</code> (unsized with slim pointer). It‚Äôs a newtype that behaves as ‚Äúlimited-lifetime¬†foreign¬†type‚Äù.</p><p>üíÅ‚Äç‚ôÇÔ∏è <em><code class="language-plaintext highlighter-rouge">NumberWindow</code> sports a user data pointer (<code class="language-plaintext highlighter-rouge">callback_context</code> above) on the C side, and I‚Äôd very much like to expose that in a strongly typesafe way too. Making <code class="language-plaintext highlighter-rouge">NumberWindow</code> itself generic over a type isn‚Äôt a problem because of <code class="language-plaintext highlighter-rouge">PhantomData</code>, but the following is unfortunately not legal in Rust:</em></p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// E0044: foreign items may not have type parameters</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Something to note is that <code class="language-plaintext highlighter-rouge">number_window_destroy</code> still takes an indefinite exclusive borrow (<code class="language-plaintext highlighter-rouge">&amp;'static mut</code>). This parameter can‚Äôt be relaxed more without making unsound usage convenient.</p><p>The <code class="language-plaintext highlighter-rouge">NumberWindow</code> here is still <code class="language-plaintext highlighter-rouge">NumberWindow&lt;'_&gt;</code>, but Rust doesn‚Äôt actually allow a <code class="language-plaintext highlighter-rouge">&amp;'static NumberWindow&lt;'_&gt;</code> to exist, so the consumer has to use a slightly longer pointer cast (<code class="language-plaintext highlighter-rouge">&amp;mut *(number_window as *mut _ as *mut void as *mut _)</code>) to destroy it. If you have a better idea for how to bind this (in context!), I‚Äôm all ears.</p><h3 id="lifetime-generic-callbacks">Lifetime-generic callbacks<a href="#lifetime-generic-callbacks" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is one final point I‚Äôd like to cover, which is the interaction of generic foreign types and function pointer types. <a href="https://developer.rebble.io/developer.pebble.com/docs/c/User_Interface/Window/NumberWindow/index.html">On the C side</a>, the following definition exists:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span> <span class="n">NumberWindowCallback</span><span class="p">)(</span>
  <span class="k">struct</span> <span class="n">NumberWindow</span> <span class="o">*</span><span class="n">number_window</span><span class="p">,</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">context</span>
<span class="p">);</span>
</pre></table></code></div></div><p>C‚Äôs function pointer type definitions aren‚Äôt all that easy to read, but here‚Äôs a compatible Rust function that matches our earlier FFI declarations:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="n">example_handler</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">number_window</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">NumberWindow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">void</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// This is a concrete implementation.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The function has a generic parameter, so to declare the matching pointer type we can either use a concrete lifetime and thread that through the container hierarchy a bit or, more conveniently and accurately, we can use a <a href="https://doc.rust-lang.org/stable/reference/items/type-aliases.html">type alias</a> to a polymorphic function pointer type:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="n">NumberWindowCallback</span> <span class="o">=</span>
  <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span><span class="p">(</span>
    <span class="n">number_window</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">NumberWindow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">void</span><span class="p">,</span>
  <span class="p">);</span>
</pre></table></code></div></div><p>üíÅ‚Äç‚ôÇÔ∏è <em>Rust‚Äôs documentation doesn‚Äôt quite spell out that this is possible for plain function pointers in addition <a href="https://doc.rust-lang.org/stable/reference/trait-bounds.html#higher-ranked-trait-bounds">to traits</a>, or what to call it. The one specific mention I found after digging for a bit is the <code class="language-plaintext highlighter-rouge">ForLifetimes?</code> in the formal grammar on <a href="https://doc.rust-lang.org/stable/reference/types/function-pointer.html">function pointer types</a>, which just links to the section on where clauses.</em></p><p>(Thanks for the correction, <a href="https://hashnode.com/@centril">Mazdak Farrokhzad</a>!)</p><h3 id="whats-next">What‚Äôs next<a href="#whats-next" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>I hope this post has been helpful so far. <a href="https://github.com/Tamschi/pebble-sys#pebble-sys"><code class="language-plaintext highlighter-rouge">pebble-sys</code></a> is still a work in progress, but I believe it‚Äôs on a good trajectory and this is just about everything I learned while working on it so far. It‚Äôs actually my first FFI binding (not counting C#), but it‚Äôs fun to go a bit beyond transliterating the C declarations üòÖ</p><p>For the next post, I want to cover the constructs I used to reconcile Pebble‚Äôs polymorphic OOP API, memory safety, and 24kB of app working memory in <a href="https://github.com/Tamschi/pebble-skip#pebble-skip"><code class="language-plaintext highlighter-rouge">pebble-skip</code></a>. You‚Äôll also see a custom <em>fallible</em> <a href="https://doc.rust-lang.org/stable/std/"><code class="language-plaintext highlighter-rouge">Box</code></a> with direct unsizing coercions.</p><hr /><p>¬π Full disclosure: I was unable to find a direct mention of this latter bit. However, without reentrant mutable references, available pointer arithmetic would essentially be nonsensical, so I‚Äôm <em>pretty sure</em> re-entering mutable references from pointers is legal. It would be good to have some clarification here.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/ffi/'>FFI</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/patterns/" class="post-tag no-text-decoration" >patterns</a> <a href="/tags/api/" class="post-tag no-text-decoration" >api</a> <a href="/tags/walkthrough/" class="post-tag no-text-decoration" >walkthrough</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper">This post is <a href="https://creativecommonsusa.org/wp-content/uploads/2018/01/Copyright-and-Open-Licensing-Primer.pdf">not licensed</a> for any purpose, unless otherwise noted.<br> It is provided AS IS without any guarantee of correctness beyond those required for legal reasons.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Semantic FFI Bindings in Rust - Reactivating the Borrow Checker - Abstraction Haven&url=https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Semantic FFI Bindings in Rust - Reactivating the Borrow Checker - Abstraction Haven&u=https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Semantic FFI Bindings in Rust - Reactivating the Borrow Checker - Abstraction Haven&url=https://blog.schichler.dev/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Asteracea/">Asteracea (as of right now) üåº</a><li><a href="/posts/Moving/">Moving</a><li><a href="/posts/Some-thoughts-on-Bubble/">Some thoughts on Bubble</a><li><a href="/posts/Cheese-olive-dish/">Cheese-olive dish</a><li><a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/">Intrusive Smart Pointers + Heap Only Types = üíû</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/"><div class="card-body"> <em class="timeago small" date="2021-11-14 18:44:00 +0100" >Nov 14, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Intrusive Smart Pointers + Heap Only Types = üíû</h3><div class="text-muted small"><p> In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomati...</p></div></div></a></div><div class="card"> <a href="/posts/Pinning-in-plain-English/"><div class="card-body"> <em class="timeago small" date="2021-11-24 17:10:00 +0100" >Nov 24, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pinning in plain English</h3><div class="text-muted small"><p> A mirrored bell pepper is still clearly the same fruit, but the mirror image, if physically placed outside the mirror, would largely only be compatible with a fundamentally different biology, ...</p></div></div></a></div><div class="card"> <a href="/posts/Asteracea/"><div class="card-body"> <em class="timeago small" date="2022-05-14 15:25:00 +0200" >May 14, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Asteracea (as of right now) üåº</h3><div class="text-muted small"><p> This is a relatively high-level summary post of design decisions I made so far while implementing Asteracea and its related packages like the lignin group of crates. I‚Äôm making this post partially ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Building-non-containers-with-Docker-and-VS-Code/" class="btn btn-outline-primary" prompt="Older"><p>Building non-containers with Docker and VS Code</p></a> <a href="/posts/Some-thoughts-on-Bubble/" class="btn btn-outline-primary" prompt="Newer"><p>Some thoughts on Bubble</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> ¬© 2024 <a href="https://schichler.dev/">Tamme Schichler</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are not licensed for redistribution by the author. (Feel free to save a copy for personal use, though. You likely don't even need permission for that.)">Most rights reserved.</span> <br> <a href="https://impressum.schichler.dev/">Impressum/Imprint, Datenschutz</a></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="/assets/un-cdn/jsdelivr/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/un-cdn/jsdelivr/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/un-cdn/jsdelivr/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
