[ { "title": "Rust RFC 3634: Scoped &lt;code&gt;impl Trait for Type&lt;/code&gt;", "url": "/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/", "categories": "Rust, Language Design", "tags": "Rust, traits, composition, RFC", "date": "2024-05-12 18:20:00 +0200", "snippet": "I just posted my first Rust RFC. Hopefully it‚Äôs received well even though it‚Äôs on a relatively tough topic üòÖFor posterity, you can find the full text I initially submitted below.Non-grammar blockquotes are less-formal comments I added as further explanations.I may edit this post eventually to include the correct Rust Issue link (if the RFC is merged), or to fix embarrassing typos, but for the most up-to-date version please see the ‚ÄòRFC PR‚Äô linked just below this.The rendered GitHub version may be a bit easier to navigate, too, as subheadings appear in the navigation there.You can show the table of contents using the button at the very right of the sticky header on GitHub.Thanks to @teliosdev for some very early syntax feedback that helped put me on track, to @cofinite for pointing out how scoped implementations allow syntax traits to be used as extension traits, to @thefakeplace and to SkiFire13 in the draft discussion for suggestions on how to make this RFC more approachable and easier to understand. Feature Name: scoped_impl_trait_for_type Start Date: 2024-05-12 RFC PR: rust-lang/rfcs#3634 Rust Issue: (to be added if merged)SummaryThis proposal adds scoped impl Trait for Type items into the core language, as coherent but orphan-rule-free alternative to implementing traits globally. It also extends the syntax of use-declarations to allow importing these scoped implementations into other item scopes (including other crates), and differentiates type identity of most generics by which scoped trait implementations are available to each discretised generic type parameter (also adding syntax to specify differences to these captured implementation environments directly on generic type arguments).This (along with some details specified below) enables any crate to locally, in item scopes, implement nearly any trait for any expressible type, publish these trivially composable implementations to other crates, import and use such implementations safely and seamlessly and completely ignore this feature when it‚Äôs not needed*.* aside from one hopefully very obscure TypeId edge case that‚Äôs easy to accurately lint for.This document uses ‚Äúscoped implementation‚Äù and ‚Äúscoped impl Trait for Type‚Äù interchangeably. As such, the former should always be interpreted to mean the latter below.MotivationWhile orphan rules regarding trait implementations are necessary to allow crates to add features freely without fear of breaking dependent crates, they limit the composability of third party types and traits, especially in the context of derive macros.For example, while many crates support serde::{Deserialize, Serialize} directly, implementations of the similarly-derived bevy_reflect::{FromReflect, Reflect} traits are less common. Sometimes, a Debug, Clone or (maybe only contextually sensible) Default implementation for a field is missing to derive those traits. While crates like Serde often do provide ways to supply custom implementations for fields, this usually has to be restated on each such field. Additionally, the syntax for doing so tends to differ between derive macro crates.Wrapper types, commonly used as workaround, add clutter to call sites or field types, and introduce mental overhead for developers as they have to manage distinct types without associated state transitions in order to work around the issues laid out in this section. They also require a distinct implementation for each combination of traits and lack discoverability through tools like rust-analyzer.Another pain point are sometimes missing Into&amp;lt;&amp;gt;-conversions when propagating errors with ?, even though one external residual (payload) type may (sometimes contextually) be cleanly convertible into another. As-is, this usually requires a custom intermediary type, or explicit conversion using .map_err(|e| ‚Ä¶) (or an equivalent function/extension trait). If an appropriate From&amp;lt;&amp;gt;-conversion can be provided in scope, then just ? can be used.This RFC aims to address these pain points by creating a new path of least resistance that is easy to use and very easy to teach, intuitive to existing Rust-developers, readable without prior specific knowledge, discoverable as needed, has opportunity for rich tooling support in e.g. rust-analyzer and helpful error messages, is quasi-perfectly composable including decent re-use of composition, improves maintainability and (slightly) robustness to major-version dependency changes compared to newtype wrappers, and does not restrict crate API evolution, compromise existing coherence rules or interfere with future developments like specialisation. Additionally, it allows the implementation of more expressive (but no less explicit) extension APIs using syntax traits like in the PartialEq&amp;lt;&amp;gt;-example below, without complications should these traits be later implemented in the type-defining crate.For realistic examples of the difference this makes, please check the rationale-and-alternatives section.Guide-level explanationScoped impl Trait for Type can be introduced in The Book alongside global trait implementations and mentioned in the standard library documentation examples.For example, the following changes could be made:10.2. Traits: Defining Shared BehaviorThe following sections are added after Implementing a Trait on a Type:Scoped Implementation of a Trait on a TypeIndependently of implementing a trait on a type or set of types globally, it‚Äôs possible to do so only for the current scope, by adding the use keyword:use impl Trait for Type { // ...}With the exception of very few traits related to language features, you can implement any visible trait on any visible type this way, even if both are defined in other crates.In other words: The orphan rule does not apply to scoped implementations. Instead, item shadowing is used to determine which implementation to use.Scoped implementations are intended mainly as compatibility feature, to let third party crates provide glue code for other crate combinations. To change the behaviour of an instance or a set of instances from their default, consider using the newtype pattern instead.Publishing and Importing Scoped ImplementationsYou can also publish a scoped implementation further by adding a visibility before use ‚Ä¶:pub use impl Trait for Type { // ...}pub use unsafe impl UnsafeTrait for Type { // ...}‚Ä¶ and import it into other scopes:use other_module::{ impl Trait for Type, impl UnsafeTrait for Type,};Note that the scoped implementation of UnsafeTrait is imported without the unsafe keyword. It is the implementing crate‚Äôs responsibility to ensure the exported unsafe implementation is sound everywhere it is visible!Generic parameters, bounds and where-clauses can be used as normal in each of these locations, though you usually have to brace impl&amp;lt;/*...*/&amp;gt; Trait for Type where /*...*/ individually in use-declarations.You can import a subset of a generic implementation, by narrowing bounds or replacing type parameters with concrete types in the use-declaration.Global implementations can be imported from the root namespace, for example to shadow a scoped implementation:use ::{impl Trait for Type};Scoped implementations and genericsScoped implementations are resolved on most generics‚Äô type arguments where those are specified, and become part of the (now less generic) host type‚Äôs identity:#[derive(Default)]struct Type&amp;lt;T&amp;gt;(T);trait Trait { fn trait_fn();}impl&amp;lt;T: Trait&amp;gt; Type&amp;lt;T&amp;gt; { fn type_fn() { T::trait_fn(); }}mod nested { use super::{Trait, Type}; use impl Trait for () { fn trait_fn() { println!(&quot;nested&quot;); } } pub type Alias = Type&amp;lt;()&amp;gt;;}use nested::Alias;fn main() { Alias::type_fn(); // &quot;nested&quot; // Type::&amp;lt;()&amp;gt;::type_fn(); // ^^^^^^^ error[E0599]: the function or associated item `type_fn` exists for struct `Type&amp;lt;()&amp;gt;`, but its trait bounds were not satisfied // let t: Type&amp;lt;()&amp;gt; = Alias::default(); // ^^^^^^^^^ error[E0308]: mismatched types let t: Type&amp;lt;() as Trait in nested&amp;gt; = Alias::default();}This works equally not just for type aliases but also fields, let-bindings and also where generic type parameters are inferred automatically from expressions (for example to call a constructor).Note that some utility types, like references, tuples, Option, Result and closure traits, do not bind implementations eagerly but only when used to specify another generic. You can find a list of these types in the reference. (‚Üê i.e. ‚Äúinsert link here‚Äù.)19.2. Advanced TraitsThe section Using the Newtype Pattern to Implement External Traits on External Types is updated to mention scoped implementations, to make them more discoverable when someone arrives from an existing community platform answer regarding orphan rule workarounds. It should also mention that newtypes are preferred over scoped implementations when use of the type is semantically different, to let the type checker distinguish it from others.A new section is added:Using Scoped Implementations to Implement External Traits on External TypesSince scoped implementations allow crates to reusably implement external traits on external types, they can be used to provide API extensions that make use of syntactic sugar. For example:Filename: fruit-comparer/src/lib.rsuse apples::Apple;use oranges::Orange;pub use impl PartialEq&amp;lt;Orange&amp;gt; for Apple { fn eq(&amp;amp;self, other: &amp;amp;Orange) -&amp;gt; bool { todo!(&quot;Figure out how to compare apples and oranges.&quot;) }}pub use impl PartialEq&amp;lt;Apple&amp;gt; for Orange { fn eq(&amp;amp;self, other: &amp;amp;Orange) -&amp;gt; bool { todo!(&quot;Figure out how to compare oranges and apples.&quot;) }}Filename: src/main.rsuse apples::Apple;use oranges::Orange;use fruit_comparer::{ impl PartialEq&amp;lt;Orange&amp;gt; for Apple, impl PartialEq&amp;lt;Apple&amp;gt; for Orange,};fn main() { let apple = Apple::new(); let orange = Orange::new(); // Compiles: dbg!(apple == orange); dbg!(orange == apple);}If the type whose API was extended this way later gains the same trait inherently, that is not a problem as the consuming code continues to use fruit_comparer‚Äôs scoped implementation. However, a warning (global-trait-implementation-available) is shown by default to alert the maintainers of each crate of the covering global implementation.Be careful about literal coercion when using generic traits this way! For example, if a scoped implementation of Index&amp;lt;isize&amp;gt; is used and a global Index&amp;lt;usize&amp;gt; implementation is added later on the same type, the compiler will not automatically decide which to use for integer literal indices between these two.Rustdoc documentation changesuse and impl keywordsThe documentation pages for the use keyword and for the impl keyword are adjusted to (very) briefly demonstrate the respective scoped use of impl Trait for Type.TypeIdThe page for TypeId gains two sections with the following information:# `TypeId` and scoped implementationsTo make sure that that are no mix-ups between, for example, `HashSet&amp;lt;T&amp;gt;` and`HashSet&amp;lt;T as Hash in module&amp;gt;`, any such difference implies distinct `TypeId`s betweensuch discretised generics (and that the types are not mutually assignable).This also affects trait-bounded generic type parameters: If `T` is bounded on `Hash`, then`TypeId::of::&amp;lt;T&amp;gt;()` results in distinct `TypeId`s in that context depending on thecaptured implementation.However, note that `TypeId::of::&amp;lt;T&amp;gt;()` and `TypeId::of::&amp;lt;T as Hash in module&amp;gt;()` arealways equivalent for one definition of `T`, as `TypeId::of`&#39;s implementation does **not**have a `T: Hash` bound!For convenience (so that their values are easily interchangeable across crates), thefollowing types ignore scoped implementations *on* their generic arguments in terms of*their own* type identity: [‚Ä¶]Despite this, differences in *type arguments&#39;* discrete identities (for example fromscoped implementations captured *in* them) distinguish the type identity of *all*discretised generics they appear in.# `TypeId::of::&amp;lt;Self&amp;gt;()` may change for values of genericsTo make type-erased collections sound and unsurprising by default, it&#39;s sound to transmutebetween instances of an external generic type that differ only in their captured scopedimplementations, **iff and only iff** no inconsistency is ever observed by bounds(including across separate function calls).However, this poses a problem: `TypeId::of::&amp;lt;Self&amp;gt;()` (just like the written-out form ofany type that doesn&#39;t ignore scoped implementations) takes *all* differences in capturedimplementation environments into account, not just those relevant to trait bounds.As such, prefer `TypeId::of::&amp;lt;T&amp;gt;()` whenever possible in order to make only thedistinctions you require. You can use tuples to combine multiple type parameters withoutover-distinguishing: `TypeId::of::&amp;lt;(S, T)&amp;gt;()` These rules and the reasons for them are explained in detail in the reference-level-explanation below, as well as in logical-consistency as part of rationale-and-alternatives. It may be a good idea to link to similar longer explanations from the standard library docs above, even if just as ‚ÄúSee also:‚Äù-style references for further reading. The [‚Ä¶]-placeholder stands for a list of links to each implementation-invariant generic‚Äôs documentation.See also behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters for a way to narrowly alert users of this when relevant, and to scan for the potential impact of these changes ahead of time.Implementation-invariant genericsThe pages for implementation-invariant-generics gain a section similar to the following:# Implementation-invariant genericThis type does not by itself capture scoped implementation environments when discretised.See [`TypeId` and scoped implementations] for more information.where [`TypeId` and scoped implementations] is a link to the section added to the TypeId page above.mem::transmuteThe page for transmute gains a section with the following information:# `transmute` and scoped implementationsIt is sound to transmute between discretised generic types that differ only in theircaptured scoped implementation environments, **but only iff** such differences are**never** observed by bounds on their implementation, including functions that imply suchby being implemented for discrete instances of the generic. As far as I can tell, this is only practically relevant for certain kinds of type-erasing collections, like type-erasing hash maps and B-trees, of which I couldn‚Äôt find any examples on crates.io. Any straightforward implementations of such collections should also at worst exhibit only unexpected behaviour when consumed in the presence of scoped implementations, rather than unsoundness.Changes to The RustonomiconThe page on Transmutes gains the following warning in addition to the existing ones:- It is unsound to change [captured scoped implementations] via transmute for any external type if this change ever causes a contradiction observable by the transmuted value&#39;s implementation. This can happen due to bounds on called functions and/or because a called function is implemented for a specific type discretised from the generic.[captured scoped implementations] should link to documentation introducing scoped impl Trait for Type.Reference-level explanationGrammar changesThe core Rust language grammar is extended as follows: TraitImpl‚Äôs definition is prepended with (Visibility? use)? and refactored for partial reuse to arrive at TraitImpl¬†:‚ÄÉ (Visibility? use)? unsafe? TraitCoverage‚ÄÉ {‚ÄÉ‚ÄÉ InnerAttribute*‚ÄÉ‚ÄÉ AssociatedItem*‚ÄÉ } TraitCoverage¬†:‚ÄÉ TraitCoverageNoWhereClause‚ÄÉ WhereClause? TraitCoverageNoWhereClause¬†:‚ÄÉ impl GenericParams? !? TypePath for Type where a trait implementation with that use-prefix provides the implementation only as item in the containing item scope. (This can be distinguished from use-declarations with a lookahead up to and including impl or unsafe, meaning at most four shallowly tested token trees with I believe no groups. No other lookaheads are introduced into the grammar by this RFC.) The scoped implementation defined by this item is implicitly always in scope for its own definition. This means that it‚Äôs not possible to refer to any shadowed implementation inside of it (including generic parameters and where clauses), except by re-importing specific scoped implementations inside nested associated functions. Calls to generic functions cannot be used as backdoor either (see type-parameters-capture-their-implementation-environment). UseTree‚Äôs definition is extended for importing scoped implementations by inserting the extracted TraitCoverage and TraitCoverageNoWhereClause rules as follows: UseTree¬†:‚ÄÉ (SimplePath? ::)? *‚ÄÇ | (SimplePath? ::)? {‚ÄÉ (‚ÄÉ‚ÄÉ ((‚ÄçUseTree | TraitCoverageNoWhereClause) (, (‚ÄçUseTree | TraitCoverageNoWhereClause))* (, TraitCoverage?)?)?‚ÄÉ‚ÄÇ | TraitCoverage‚ÄÉ )‚ÄÉ }‚ÄÇ | SimplePath (as (IDENTIFIER | _))? Allowing a trailing TraitCoverage with WhereClause in a braced list is intended for ergonomics, but rustfmt should brace it individually by default, then append a trailing comma where applicable as usual. A ‚Äò,‚Äô in the WhereClause here is not truly ambiguous because WhereClauseItems contain ‚Äò:‚Äô, but allowing that ahead of others would likely be visually confusing and tricky to implement (requiring an arbitrarily long look-ahead). Alternatively to allowing a trailing TraitCoverage in mixed lists, an error similar to E0178 could be emitted. Allowing unbraced imports like use some_crate::impl&amp;lt;A, B&amp;gt; Trait&amp;lt;A&amp;gt; for Type&amp;lt;B&amp;gt; where A: Debug, B: Debug; would break the source code‚Äôs visual hierarchy quite badly, so I won‚Äôt suggest it here, but it is possible without ambiguity too. If that is added for convenience, then I‚Äôm strongly in favour of rustfmt bracing the TraitCoverage by default and rust-analyzer suggesting it only braced. Here, TraitCoverage imports the specified scoped impl Trait for Type for binding and conflict checks as if defined in the scope containing the use-declaration. The resulting visibility is taken from UseDeclaration, like with SimplePath-imported items. TraitCoverage must be fully covered by the scoped implementation visible in the source module. Otherwise, a compile-error occurs explaining the uncovered case (similarly to the current error(s) for missing trait implementations). TraitCoverage may subset the source module‚Äôs implementation by having narrower bounds or using concrete types in place of one or more generic type parameters. This causes only the specified subset of the scoped implementation to be imported. Note that scoped implementations of unsafe traits are imported without unsafe. It is the exporting crate‚Äôs responsibility to ensure a scoped implementation is sound everywhere it is visible. Other elements of the coverage must match the source module‚Äôs implementation exactly, unless specified otherwise. TypeParam, GenericArg and GenericArgsBinding are extended to accept implementation environments inline: TypeParam¬†:‚ÄÉ IDENTIFIER ( : TypeParamBounds? )? ( = Type ImplEnvironment? )? GenericArg¬†:‚ÄÉ Lifetime | Type ImplEnvironment? | GenericArgsConst | GenericArgsBinding GenericArgsBinding¬†:‚ÄÉ IDENTIFIER = Type ImplEnvironment? ImplEnvironment¬†:‚ÄÉ as ( ImplEnvironmentEntry ( + ImplEnvironmentEntry )* +? )? ImplEnvironmentEntry¬†:‚ÄÉ (‚ÄÉ‚ÄÉ ForLifetimes? TypePath‚ÄÉ‚ÄÇ | ( ForLifetimes? TypePath )‚ÄÉ )‚ÄÉ in ( :: | SimplePath ) When detecting conflicting implementations, the ImplEnvironment is treated as creating a distinct scope nested in its surrounding scope. Each resulting implementation environment must be conflict-free, but between them they can contain conflicting implementations. Even when an ImplEnvironment is added as above, the resulting implementation environment still captures scoped implementations from the surrounding scope for all traits that were not specified inline! A global implementation can be used explicitly by sourcing it from :: instead of a module. For stability reasons (against relaxation of bounds) and because they matter for type identity, explicit inline implementation environments should be allowed where no matching bound is present, but should produce an unused-scoped-implementation warning iff neither published nor used in the same crate (including for type identity distinction). Whether inline implementation environments would inherit from each other is intentionally left unspecified, as identical types can‚Äôt be nested without indirection, which ensures such a situation isn‚Äôt relevant. Further type specification syntax is extended as follows: ParenthesizedType¬†:‚ÄÉ ( Type ImplEnvironment? ) TupleType¬†:‚ÄÉ ( )‚ÄÇ | ( ( Type ImplEnvironment? , )+ ( Type ImplEnvironment? )? ) ArrayType¬†:‚ÄÉ [ Type ImplEnvironment? ; Expression ] SliceType¬†:‚ÄÉ [ Type ImplEnvironment? ] Closure types are not extended with ImplEnvironment because implementation environments annotated on their parameters would never be effective. Extending ParenthesizedType this way is necessary to specify implementation environments for pointer types‚Äô generic type parameters, e.g. &amp;amp;(Type as Trait in module). QualifiedPathType is also extended for this purpose, but can additionally act as implementation environment scope that also affects the implementation environment of nested types, using a clause starting with where: QualifiedPathType¬†:‚ÄÉ &amp;lt; Type ( as TypePath (in (:: | SimplePath ) )? )? ( where ( Type ImplEnvironment , )* ( Type ImplEnvironment )? )? &amp;gt; The form &amp;lt;Type as Trait in module&amp;gt; is syntactic sugar for &amp;lt;(Type as Trait in module) as Trait&amp;gt;, to avoid repetition of potentially long traits. Implementations imported after where must be valid, but don‚Äôt necessarily have to be relevant. I am not confident that where is the right keyword here, but it seems like this best option among the already-existing ones. use-syntax feels far too verbose here. Maybe the above but with using or with in place of where? No scoped impl Trait for Type of auto traits, Copy and DropImplementations of auto traits state guarantees about private implementation details of the covered type(s), which an external implementation can almost never do soundly.Copy is not an auto trait, but implementing it on a smart pointer like Box&amp;lt;T&amp;gt; would immediately be unsound. As such, this trait must be excluded from all external implementations.Shadowing Drop for types that are !Unpin is similarly unsound without cooperation of the original crate (in addition to likely causing memory leaks in this and more cases).No scoped impl !Trait for TypeAny negative scoped implementation like for exampleuse impl !Sync for Type {}is syntactically valid, but rejected by the compiler with a specific error. (See negative-scoped-implementation.)This also applies to impl Traits in use-declarations (even though the items they would import cannot be defined anyway. Having a specific error saying that this isn‚Äôt possible would be much clearer than one saying that the imported item doesn‚Äôt exist).No external scoped implementations of sealed traitsConsider this library crate:pub struct Generic&amp;lt;T&amp;gt;(T);mod private { // Implemented only on traits that are also `Sealed`. pub trait Sealing {}}use private::Sealing;pub trait Sealed: Sealing { fn assumed { // ‚ù∑ }}impl&amp;lt;T: Sealed&amp;gt; Generic { fn assuming { // ‚ù∂ }}In this crate, any code at ‚ù∂ is currently allowed to make safety-critical assumptions about code at ‚ù∑ and other implementations of assumed.To ensure this stays sound, scoped impl Trait for Type where Trait is external requires that all supertraits of Trait are visible to the crate defining the scoped implementation or are defined not in Trait‚Äôs definition crate (meaning they must still be exported from a crate somewhere in the dependency tree).See also scoped-implementation-of-external-sealed-trait.Type parameters capture their implementation environmentWhen a type parameter is specified, either explicitly or inferred from an expression, it captures a view of all implementations that are applicable to its type there. This is called the type parameter‚Äôs implementation environment.(For trait objects, associated types are treated as type parameters for the purposes of this proposal.)When implementations are resolved on the host type, bounds on the type parameter can only be satisfied according to this captured view. This means that implementations on generic type parameters are ‚Äòbaked‚Äô into discretised generics and can be used even in other modules or crates where this discretised type is accessible (possibly because a value of this type is accessible). Conversely, additional or changed implementations on a generic type parameter in an already-discretised type cannot be provided anywhere other than where the type parameter is specified.When a generic type parameter is used to discretise another generic, the captured environment is the one captured in the former but overlaid with modifications applicable to that generic type parameter‚Äôs opaque type.Note that type parameter defaults too capture their implementation environment where they are specified, so at the initial definition site of the generic. This environment is used whenever the type parameter default is used.In order to avoid too much friction, implementation-invariant-generics are exempt from acting as host for implementation environments on their own.Type identity of discrete typesThe type identity and TypeId::of::&amp;lt;‚Ä¶&amp;gt;() of discrete types, including discretised generics, are not affected by scoped implementations on them.Type identity of generic typesImplementation-aware genericsGenerics that are not implementation-invariant-generics are implementation-aware generics.The type identity of implementation-aware generic types is derived from the types specified for their type parameters as well as the full implementation environment of each of their type parameters and their associated types:#[derive(Default)]struct Type;#[derive(Default)]struct Generic&amp;lt;T&amp;gt;(T);trait Trait {}impl&amp;lt;T&amp;gt; Generic&amp;lt;T&amp;gt; { fn identical(_: Self) {} fn nested_convertible&amp;lt;U: Into&amp;lt;T&amp;gt;&amp;gt;(_: Generic&amp;lt;U&amp;gt;) {}}mod mod1 { use crate::{Generic, Trait, Type}; use impl Trait for Type {} // Private implementation, but indirectly published through `Alias1`. pub type Alias1 = Generic&amp;lt;Type&amp;gt;;}mod mod2 { use crate::{Generic, Trait, Type}; pub use impl Trait for Type {} // Public implementation. pub type Alias2 = Generic&amp;lt;Type&amp;gt;;}mod mod3 { use crate::{Generic, Trait, Type}; use crate::mod2::{impl Trait for Type}; // Reused implementation. pub type Alias3 = Generic&amp;lt;Type&amp;gt;;}mod mod4 { use crate::{Generic, Trait, Type}; use impl&amp;lt;T&amp;gt; Trait for Generic&amp;lt;T&amp;gt; {} // Irrelevant top-level implementation. pub type Alias4 = Generic&amp;lt;Type&amp;gt;;}mod mod5 { use crate::{Generic, Type}; // No implementation. pub type Alias5 = Generic&amp;lt;Type&amp;gt;;}use mod1::Alias1;use mod2::Alias2;use mod3::Alias3;use mod4::Alias4;use mod5::Alias5;fn main() { use std::any::TypeId; use tap::Conv; // Distinct implementations produce distinct types. assert_ne!(TypeId::of::&amp;lt;Alias1&amp;gt;(), TypeId::of::&amp;lt;Alias2&amp;gt;()); assert_ne!(TypeId::of::&amp;lt;Alias1&amp;gt;(), TypeId::of::&amp;lt;Alias3&amp;gt;()); // Types with identical captured implementation environments are still the same type. assert_eq!(TypeId::of::&amp;lt;Alias2&amp;gt;(), TypeId::of::&amp;lt;Alias3&amp;gt;()); // Top-level implementations are not part of type identity. assert_eq!(TypeId::of::&amp;lt;Alias4&amp;gt;(), TypeId::of::&amp;lt;Alias5&amp;gt;()); // If the type is distinct, then values aren&#39;t assignable. // Alias1::identical(Alias2::default()); // ^^^^^^^^^^^^^^^^^ error[E0308]: mismatched types // Fulfilled using the global reflexive `impl&amp;lt;T&amp;gt; Into&amp;lt;T&amp;gt; for T` on `Type`, // as from its perspective, the binding is stripped due to being top-level. Alias1::nested_convertible(Alias2::default()); // The reflexive `impl&amp;lt;T&amp;gt; Into&amp;lt;T&amp;gt; for T` does not apply between the aliases here, // as the distinct capture in the type parameter affects its inherent identity. // (It&#39;s unfortunately not possible to generically implement this conversion without specialisation.) // Alias1::default().conv::&amp;lt;Alias2&amp;gt;(); // ^^^^ error[E0277]: the trait bound `Generic&amp;lt;Type as Trait in mod2&amp;gt;: From&amp;lt;Generic&amp;lt;Type as Trait in mod1&amp;gt;&amp;gt;&amp;gt;` is not satisfied // Identical types are interchangeable. Alias2::identical(Alias3::default()); Alias4::identical(Alias5::default());}As mentioned in type-identity-of-discrete-types, implementations on the generic type itself do not affect its type identity, as can be seen with Alias4 above.The TypeId of these generics varies alongside their identity. Note that due to the transmutation permission defined in layout-compatibility, consumer code is effectively allowed to change the TypeId of instances of generics between calls to generic implementations in most cases. Due to this, implementations of generics that manage types at runtime should usually rely on the typeid-of-generic-type-parameters-opaque-types or (‚Ä¶,)-tuple-types combining them instead of on TypeId::of::&amp;lt;Self&amp;gt;(). (see also behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters)(For a practical example, see logical-consistency.)Implementation-invariant genericsThe following generics that never rely on the consistency of trait implementations on their type parameters are implementation-invariant: &amp;amp;T, &amp;amp;mut T (references), *const T, *mut T (pointers), [T; N], [T] (arrays and slices), (T,), (T, U, ..) (tuples), superficially* fn(T) -&amp;gt; U and similar (function pointers), superficially* Fn(T) -&amp;gt; U, FnMut(T) -&amp;gt; U, FnOnce(T) -&amp;gt; U, Future&amp;lt;Output = T&amp;gt;, Iterator&amp;lt;Item = T&amp;gt;, std::ops::Coroutine and similar (closures), Pin&amp;lt;P&amp;gt;, NonNull&amp;lt;T&amp;gt;, Box&amp;lt;T&amp;gt;, Rc&amp;lt;T&amp;gt;, Arc&amp;lt;T&amp;gt;, Weak&amp;lt;T&amp;gt;, Option&amp;lt;T&amp;gt;, Result&amp;lt;T, E&amp;gt;**.Implementation-invariant generics never capture implementation environments on their own. Instead, their effective implementation environments follow that of their host, acting as if they were captured in the same scope.The type identity of implementation-invariant generics seen on their own does not depend on the implementation environment. This also means that the TypeId of Option&amp;lt;T&amp;gt; does not take into account differences of implementations on T. However, differences of implementations in T can still distinguish the types, in cases where the type identity (and possibly TypeId) of T itself are different. An example for this are generic type parameters‚Äô effective types that can have bounds-relevant implementations observably baked into them.Hosts are: Type aliases (see type-aliases-are-opaque-to-scoped-implementations), implementation-aware-generics, types written as QualifiedPathType (see grammar-changes to QualifiedPathType) and the function operand of call expressions (see call-expressions-function-operand-captures-its-implementation-environment).* superficially: The underlying instance may well use a captured implementation internally, but this isn‚Äôt surfaced in signatures. For example, a closure defined where usize: PartialOrd in reverse + Ord in reverse is just FnOnce(usize) but will use usize: PartialOrd in reverse + Ord in reverse privately when called.** but see which-structs-should-be-implementation-invariant.See also why-specific-implementation-invariant-generics.Call expressions‚Äô function operand captures its implementation environmentCall expressions capture the implementation environment in their function operand, acting as host for implementation-invariant-generics. This enables call expressions such asOption::&amp;lt;Type as Debug in module&amp;gt;::fmt(‚Ä¶)where fmt receives the specified scoped implementation by observing it through the T: Debug bound on its implementing impl block.If no observing bound exists, code of this form should produce a warning spanning the Trait in module tokens. (see unused-scoped-implementation)Type aliases are opaque to scoped implementationsAs scoped impl Trait for Type is a fully lexically-scoped feature, the implementation environment present in a scope does not affect types hidden behind a type alias, except for the top-level type directly:trait Trait { fn method(&amp;amp;self) -&amp;gt; &amp;amp;str;}impl Trait for Type { fn method(&amp;amp;self) -&amp;gt; &amp;amp;str { &quot;global&quot; }}mod m1 { use super::Type; pub type Alias = [Type; 1];}mod m2 { use super::{Type, Trait}; pub use impl Trait for Type { fn method(&amp;amp;self) -&amp;gt; &amp;amp;str { &quot;scoped&quot; } } pub use impl&amp;lt;T: Trait&amp;gt; Trait for [T; 1] { fn method(&amp;amp;self) -&amp;gt; &amp;amp;str { self[0].method() } }}fn main() { use m1::Alias; use m2::{ impl Trait for Type, impl Trait for [Type; 1], }; assert_eq!([Type].method(), &quot;scoped&quot;); assert_eq!(Alias::default().method(), &quot;global&quot;);}Scoped implementations may still be observed through bounded generic type parameters on the type alias itself. (see binding-choice-by-implementations-bounds)TypeId of generic type parameters‚Äô opaque typesIn addition to the type identity of the specified type, the TypeId of opaque generic type parameter types varies according to the captured implementation environment, but only according to implementations that are relevant to their bounds (including implicit bounds), so that the following program runs without panic:use std::any::TypeId;#[derive(Default)]struct Type;trait Trait {}impl Trait for Type {}#[derive(Default)]struct Generic&amp;lt;T&amp;gt;(T);mod nested { pub(super) use impl super::Trait for super::Type {}}// `A` and `B` are distinct due to different captured implementation environments.type A = Generic&amp;lt;Type&amp;gt;;type B = Generic&amp;lt;Type as Trait in nested&amp;gt;;fn no_bound&amp;lt;T: &#39;static, U: &#39;static&amp;gt;(_: Generic&amp;lt;T&amp;gt;, _: Generic&amp;lt;U&amp;gt;) { assert_eq!(TypeId::of::&amp;lt;T&amp;gt;(), TypeId::of::&amp;lt;U&amp;gt;()); assert_ne!(TypeId::of::&amp;lt;Generic&amp;lt;T&amp;gt;&amp;gt;(), TypeId::of::&amp;lt;Generic&amp;lt;U&amp;gt;&amp;gt;()); assert_eq!(TypeId::of::&amp;lt;T&amp;gt;(), TypeId::of::&amp;lt;Type&amp;gt;()); assert_eq!(TypeId::of::&amp;lt;U&amp;gt;(), TypeId::of::&amp;lt;Type&amp;gt;());}fn yes_bound&amp;lt;T: Trait + &#39;static, U: Trait + &#39;static&amp;gt;(_: Generic&amp;lt;T&amp;gt;, _: Generic&amp;lt;U&amp;gt;) { assert_ne!(TypeId::of::&amp;lt;T&amp;gt;(), TypeId::of::&amp;lt;U&amp;gt;()); assert_ne!(TypeId::of::&amp;lt;Generic&amp;lt;T&amp;gt;&amp;gt;(), TypeId::of::&amp;lt;Generic&amp;lt;U&amp;gt;&amp;gt;()); assert_eq!(TypeId::of::&amp;lt;T&amp;gt;(), TypeId::of::&amp;lt;Type&amp;gt;()); assert_ne!(TypeId::of::&amp;lt;U&amp;gt;(), TypeId::of::&amp;lt;Type&amp;gt;());}fn main() { no_bound(A::default(), B::default()); yes_bound(A::default(), B::default());}In particular: If no bound-relevant scoped implementations are captured in a type parameter, then the TypeId of the opaque type of that type parameter is identical to that of the discrete type specified for that type parameter. Distinct sets of bound-relevant captured scoped implementations lead to distinct TypeIds of the opaque type of a type parameter. If the set of bound-relevant captured scoped implementations in two generic type parameters is the same, and the wrapped discrete type is identical, then the TypeId of the opaque types of these generic type parameters is identical. If a generic type parameter is distinguishable this way, it remains distinguishable in called implementations even if those have fewer bounds - the relevant distinction is ‚Äòbaked‚Äô into the generic type parameter‚Äôs opaque type.These rules (and the transmutation permission in layout-compatibility) allow the following collection to remain sound with minimal perhaps unexpected behaviour:use std::{ any::TypeId, collections::{ hash_map::{HashMap, RandomState}, HashSet, }, hash::{BuildHasher, Hash}, mem::drop,};use ondrop::OnDrop;#[derive(Default)]pub struct ErasedHashSet&amp;lt;&#39;a, S: &#39;a + BuildHasher + Clone = RandomState&amp;gt; { storage: HashMap&amp;lt;TypeId, *mut (), S&amp;gt;, droppers: Vec&amp;lt;OnDrop&amp;lt;Box&amp;lt;dyn FnOnce() + &#39;a&amp;gt;&amp;gt;&amp;gt;,}impl ErasedHashSet&amp;lt;&#39;_, RandomState&amp;gt; { pub fn new() -&amp;gt; Self { Self::default() }}impl&amp;lt;&#39;a, S: BuildHasher + Clone&amp;gt; ErasedHashSet&amp;lt;&#39;a, S&amp;gt; { pub fn with_hasher(hasher: S) -&amp;gt; Self { Self { storage: HashMap::with_hasher(hasher), droppers: vec![], } } // This is the important part. pub fn insert&amp;lt;T: &#39;a&amp;gt;(&amp;amp;mut self, value: T) -&amp;gt; bool where T: Hash + Eq + &#39;static, // &amp;lt;-- Bounds. { let type_id = TypeId::of::&amp;lt;T&amp;gt;(); // &amp;lt;-- `TypeId` depends on implementations of bounds. let storage: *mut () = if let Some(storage) = self.storage.get_mut(&amp;amp;type_id) { *storage } else { let pointer = Box::into_raw(Box::new(HashSet::&amp;lt;T, S&amp;gt;::with_hasher( self.storage.hasher().clone(), ))); self.droppers.push(OnDrop::new(Box::new(move || unsafe { // SAFETY: Only called once when the `ErasedHashSet` is dropped. // The type is still correct since the pointer wasn&#39;t `.cast()` yet and // both `S` and `T` are bounded on `&#39;a`, so they are still alive at this point. drop(Box::from_raw(pointer)); }))); self.storage .insert(type_id, pointer.cast::&amp;lt;()&amp;gt;()) .expect(&quot;always succeeds&quot;) }; let storage: &amp;amp;mut HashSet&amp;lt;T, S&amp;gt; = unsafe { // SAFETY: Created with (close to) identical type above. // Different `Hash` and `Eq` implementations are baked into `T`&#39;s identity because of the bounds, so they result in distinct `TypeId`s above. // It&#39;s allowed to transmute between types that differ in identity only by bound-irrelevant captured implementations. // The borrowed reference isn&#39;t returned. &amp;amp;mut *(storage.cast::&amp;lt;HashSet&amp;lt;T, S&amp;gt;&amp;gt;()) }; storage.insert(value) } // ...}In particular, this code will ignore any scoped implementations on T that are not Hash, Eq or (implicitly) PartialEq, while any combination of distinct discrete type and implementation environments with distinct Hash, Eq or PartialEq implementations is cleanly separated.See also behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters for how to lint for an implementation of this collection that uses TypeId::of::&amp;lt;HashSet&amp;lt;T, S&amp;gt;&amp;gt;() as key, which also remains sound and deterministic but distinguishes too aggressively by irrelevant scoped implementations in consumer code, leading to unexpected behaviour.(For an example of TypeId behaviour, see logical-consistency.)Layout-compatibilityTypes whose identities are only distinct because of a difference in implementation environments remain layout-compatible as if one was a #[repr(transparent)] newtype of the other.It is sound to transmute an instance between these types if no inconsistency is observed on that instance by the bounds of any external-to-the-transmute implementation or combination of implementations, including scoped implementations and implementations on discrete variants of the generic. As a consequence, the Self-observed TypeId of instances of generic types may change in some cases.For example, given a library#[derive(Debug)]pub struct Type&amp;lt;T&amp;gt;(T);impl Type&amp;lt;usize&amp;gt; { pub fn method(&amp;amp;self) {}}then in another crate if Debug is used on an instance of Type&amp;lt;T&amp;gt;, then this instance may not be transmuted to one where T: Debug uses a different implementation and have Debug used on it again afterwards, and if Type&amp;lt;usize&amp;gt;::method() is used on an instance of Type&amp;lt;usize&amp;gt;, then that instance may not be transmuted (and used) to or from any other variant, including ones that only differ by captured implementation environment, because method has observed the exact type parameter through its constraints.(In short: Don‚Äôt use external-to-your-code implementations with the instance in any combination that wouldn‚Äôt have been possible without transmuting the instance, pretending implementations can only observe the type identity according to their bounds.)See typeid-of-generic-type-parameters-opaque-types for details on what this partial transmutation permission is for, and behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters for a future incompatibility lint that could be used to warn implementations where this is relevant.No interception/no proxiesThat each scoped impl Trait for Type { /*...*/ } is in scope for itself makes the use of the implementation it shadows in the consumer scope inexpressible. There can be no scoped implementation constrained to always shadow another.This is intentional, as it makes the following code trivial to reason about:{ use a::{impl TheTrait for TheType}; // &amp;lt;-- Clearly unused, no hidden interdependencies. { use b::{impl TheTrait for TheType}; // ... }}(The main importance here is to not allow non-obvious dependencies of imports. Implementations can still access associated items of a specific other implementation by bringing it into a nested scope or binding to its associated items elsewhere. See also independent-trait-implementations-on-discrete-types-may-still-call-shadowed-implementations.)Binding choice by implementations‚Äô boundsImplementations bind to other implementations as follows: where-clause¬π on impl? binding-site of used trait monomorphised by used trait? Yes. Bound at each binding-site of impl. Yes, like-with or as-part-of type parameter distinction. No. Bound once at definition-site of impl. No. ¬π Or equivalent generic type parameter bound, where applicable. For all purposes, this RFC treats them as semantically interchangeable.A convenient way to think about this is that impl-implementations with bounds are blanket implementations over Self in different implementation environments.Note that Self-bounds on associated functions do not cause additional monomorphic variants to be emitted, as these continue to only filter the surrounding implementation.Consider the following code with attention to the where clauses:struct Type;// ‚ù∂trait Trait { fn function(); }impl Trait for Type { fn function() { println!(&quot;global&quot;); } }trait Monomorphic { fn monomorphic(); }impl Monomorphic for Type { fn monomorphic() { Type::function() }}trait MonomorphicSubtrait: Trait { fn monomorphic_subtrait() { Self::function(); }}impl MonomorphicSubtrait for Type {}trait Bounded { fn bounded(); }impl Bounded for Type where Type: Trait { fn bounded() { Type::function(); }}trait BoundedSubtrait: Trait { fn bounded_subtrait() { Type::function(); }}impl BoundedSubtrait for Type where Type: Trait {}trait FnBoundedMonomorphic { fn where_trait() where Self: Trait { Self::function(); } fn where_monomorphic_subtrait() where Self: MonomorphicSubtrait { Self::monomorphic_subtrait(); }}impl FnBoundedMonomorphic for Type {}trait NestedMonomorphic { fn nested_monomorphic(); }trait BoundedOnOther { fn bounded_on_other(); }impl BoundedOnOther for () where Type: Trait { fn bounded_on_other() { Type::function(); }}Type::function(); // &quot;global&quot;Type::monomorphic(); // &quot;global&quot;Type::monomorphic_subtrait(); // &quot;global&quot;Type::bounded(); // &quot;global&quot;Type::bounded_subtrait(); // &quot;global&quot;Type::where_trait(); // &quot;global&quot;Type::where_monomorphic_subtrait(); // &quot;global&quot;Type::nested_monomorphic(); // &quot;scoped&quot;()::bounded_on_other(); // &quot;global&quot;{ // ‚ù∑ use impl Trait for Type { fn function() { println!(&quot;scoped&quot;); } } // use impl FnBoundedMonomorphic for Type {} // error: the trait bound `Type: MonomorphicSubtrait` is not satisfied Type::function(); // &quot;scoped&quot; Type::monomorphic(); // &quot;global&quot; // Type::monomorphic_subtrait(); // error; shadowed by scoped implementation Type::bounded(); // &quot;scoped&quot; Type::bounded_subtrait(); // &quot;scoped&quot; Type::where_trait(); // &quot;global&quot; Type::where_monomorphic_subtrait(); // &quot;global&quot; Type::nested_monomorphic(); // &quot;scoped&quot; ()::bounded_on_other(); // &quot;global&quot; { // ‚ù∏ use impl MonomorphicSubtrait for Type {} use impl FnBoundedMonomorphic for Type {} impl NestedMonomorphic for Type { fn nested_monomorphic() { Type::function() } } Type::function(); // &quot;scoped&quot; Type::monomorphic(); // &quot;global&quot; Type::monomorphic_subtrait(); // &quot;scoped&quot; Type::bounded(); // &quot;scoped&quot; Type::bounded_subtrait(); // &quot;scoped&quot; Type::where_trait(); // &quot;scoped&quot; Type::where_monomorphic_subtrait(); // &quot;scoped&quot; Type::nested_monomorphic(); // &quot;scoped&quot; ()::bounded_on_other(); // &quot;global&quot; }}The numbers ‚ù∂, ‚ù∑ and ‚ù∏ mark relevant item scopes.Generic item functions outside impl blocks bind and behave the same way as generic impls with regard to scoped impl Trait for Type.Trait / ::functionThis is a plain monomorphic implementation with no dependencies. As there is a scoped implementation at ‚ù∑, that one is used in scopes ‚ù∑ and ‚ù∏.Monomorphic / ::monomorphicAnother plain monomorphic implementations.As there is no bound, an implementation of Trait is bound locally in ‚ù∂ to resolve the Type::function()-call.This means that even though a different use impl Trait for Type ‚Ä¶ is applied in ‚ù∑, the global implementation remains in use when this Monomorphic implementation is called into from there and ‚ù∏.Note that the use of Self vs. Type in the non-default function body does not matter at all!MonomorphicSubtrait / ::monomorphic_subtraitDue to the supertrait, there is an implied bound Self: Trait on the trait definition, but not on the implementation.This means that the implementation remains monomorphic, and as such depends on the specific (global) implementation of Trait in scope at the impl MonomorphicSubtrait ‚Ä¶ in ‚ù∂.As this Trait implementation is shadowed in ‚ù∑, the MonomorphicSubtrait implementation is shadowed for consistency of calls to generics bounded on both traits.In ‚ù∏ there is a scoped implementation of MonomorphicSubtrait. As the default implementation is monomorphised for this implementation, it binds to the scoped implementation of Trait that is in scope here.Bounded / ::boundedThe Type: Trait bound (can be written as Self: Trait ‚Äì they are equivalent.) selects the Bounded-binding-site‚Äôs Type: Trait implementation to be used, rather than the impl Bounded for ‚Ä¶-site‚Äôs.In ‚ù∂, this resolves to the global implementation as expected.For the scopes ‚ù∑ and ‚ù∏ together, Bounded gains one additional monomorphisation, as here another Type: Trait is in scope.BoundedSubtrait / ::bounded_subtraitAs with MonomorphicSubtrait, the monomorphisation of impl BoundedSubtrait for Type ‚Ä¶ that is used in ‚ù∂ is shadowed in ‚ù∑.However, due to the where Type: Trait bound on the implementation, that implementation is polymorphic over Trait for Type implementations. This means a second monomorphisation is available in ‚ù∑ and its nested scope ‚ù∏.FnBoundedMonomorphicFnBoundedMonomorphic‚Äôs implementations are monomorphic from the get-go just like Monomorphic‚Äôs.Due to the narrower bounds on functions, their availability can vary between receivers but always matches that of the global implementation environment:::where_traitAvailable everywhere since Type: Trait is in scope for both implementations of FnBoundedMonomorphic.In ‚ù∂, this resolves to the global implementation.In ‚ù∑, this still calls the global &amp;lt;Type as Trait in ::&amp;gt;::function() implementation since the global FnBoundedMonomorphic implementation is not polymorphic over Type: Trait.In ‚ù∏, FnBoundedMonomorphic is monomorphically reimplemented for Type, which means it ‚Äúpicks up‚Äù the scoped Type: Trait implementation that‚Äôs in scope there from ‚ù∑.::where_monomorphic_subtraitIn ‚ù∂, this resolves to the global implementation.In ‚ù∑, this still calls the global &amp;lt;Type as MonomorphicSubtrait in ::&amp;gt;::monomorphic_subtrait() implementation since the global FnBoundedMonomorphic implementation is not polymorphic over Type: Trait.Note that FnBoundedMonomorphic cannot be reimplemented in ‚ù∑ since the bound Type: MonomorphicSubtrait on its associated function isn‚Äôt available in that scope, which would cause a difference in the availability of associated functions (which would cause a mismatch when casting to dyn FnBoundedMonomorphic). It may be better to allow use impl FnBoundedMonomorphic for Type {} without where_monomorphic_subtrait in ‚ù∑ and disallow incompatible unsizing instead. I‚Äôm not sure about the best approach here.In ‚ù∏, FnBoundedMonomorphic is monomorphically reimplemented for Type, which means it ‚Äúpicks up‚Äù the scoped Type: Trait implementation that‚Äôs in scope there from ‚ù∑.NestedMonomorphic / ::nested_monomorphicThe global implementation of NestedMonomorphic in ‚ù∏ the binds to the scoped implementation of Trait on Type from ‚ù∑ internally. This allows outside code to call into that function indirectly without exposing the scoped implementation itself.BoundedOnOther / ::bounded_on_otherAs this discrete implementation‚Äôs bound isn‚Äôt over the Self type (and does not involved generics), it continues to act only as assertion and remains monomorphic.Binding and genericswhere-clauses without generics or Self type, like where (): Debug, do not affect binding of implementations within an impl or fn, as the non-type-parameter-type () is unable to receive an implementation environment from the discretisation site.However, where (): From&amp;lt;T&amp;gt; does take scoped implementations into account because the blanket impl&amp;lt;T, U&amp;gt; From&amp;lt;T&amp;gt; for U where T: Into&amp;lt;U&amp;gt; {} is sensitive to T: Into&amp;lt;()&amp;gt; which is part of the implementation environment captured in T!This sensitivity even extends to scoped use impl From&amp;lt;T&amp;gt; for () at the discretisation site, as the inverse blanket implementation of Into creates a scoped implementation of Into wherever a scoped implementation of From exists.This way, existing symmetries are fully preserved in all contexts.Implicit shadowing of subtrait implementationsTake this code for example:use std::ops::{Deref, DerefMut};struct Type1(Type2);struct Type2;impl Deref for Type1 { type Target = Type2; fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Self::Target { &amp;amp;self.0 }}impl DerefMut for Type1 { fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Self::Target { &amp;amp;mut self.0 }}fn function1(_x: impl Deref + DerefMut) {}fn function2(x: impl DerefMut) { x.deref();}{ use impl Deref for Type1 { type Target = (); fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Self::Target { &amp;amp;() } } // function1(Type1(Type2)); // &amp;lt;-- Clearly impossible. // function2(Type1(Type2)); // &amp;lt;-- Unexpected behaviour if allowed.}Clearly, function1 cannot be used here, as its generic bounds would have to bind to incompatible implementations.But what about function2? Here, the bound is implicit but Deref::deref could still be accessed if the function could be called. For type compatibility, this would have to be the shadowed global implementation, which is most likely unintended decoherence.As such, shadowing a trait implementation also shadows all respective subtrait implementations. Note that the subtrait may still be immediately available (again), if it is implemented with a generic target and all bounds can be satisfied in the relevant scope:trait Trait1 { fn trait1(&amp;amp;self);}trait Trait2: Trait1 { // &amp;lt;-- Subtrait of Trait1. fn uses_trait1(&amp;amp;self) { self.trait1(); }}impl&amp;lt;T: Trait1&amp;gt; Trait2 for T {} // &amp;lt;-- Blanket implementation with bounds satisfiable in scope.struct Type;impl Trait1 for Type { fn trait1(&amp;amp;self) { print!(&quot;global&quot;); }}{ use impl Trait1 for Type { fn trait1(&amp;amp;self) { print!(&quot;scoped&quot;); } } Type.uses_trait1(); // Works, prints &quot;scoped&quot;.}If a subtrait implementation is brought into scope, it must be either an implementation with a generic target, or an implementation on a discrete type making use of the identical supertrait implementations in that scope. (This rule is automatically fulfilled by scoped implementation definitions, so it‚Äôs only relevant for which scoped implementations can be imported via use-declaration.)Independent trait implementations on discrete types may still call shadowed implementationsGoing back to the previous example, but now implementing Trait2 independently without Trait1 in its supertraits:trait Trait1 { fn trait1(&amp;amp;self);}trait Trait2 { // &amp;lt;-- Not a subtrait of `Trait1`. fn uses_trait1(&amp;amp;self);}impl Trait2 for Type { // &amp;lt;-- Implementation on discrete type. fn uses_trait1(&amp;amp;self) { self.trait1(); }}struct Type;impl Trait1 for Type { fn trait1(&amp;amp;self) { print!(&quot;global&quot;); }}{ use impl Trait1 for Type { fn trait1(&amp;amp;self) { print!(&quot;scoped&quot;); } } Type.uses_trait1(); // Works, prints &quot;global&quot;.}In this case, the implementation of Trait2 is not shadowed at all. Additionally, since self.trait1(); here binds Trait on Type directly, rather than on a bounded generic type parameter, it uses whichever impl Trait1 for Type is in scope where it is written.Resolution on generic type parametersScoped impl Trait for Types (including use-declarations) can be applied to outer generic type parameters at least (see unresolved-questions) via scoped blanket use impl&amp;lt;T: Bound&amp;gt; Trait for T.However, a blanket implementation can only be bound on a generic type parameter iff its bounds are fully covered by the generic type parameter‚Äôs bounds and other available trait implementations on the generic type parameter, in the same way as this applies for global implementations.Method resolution to scoped implementation without trait in scopeMethod calls can bind to scoped implementations even when the declaring trait is not separately imported. For example:struct Type;struct Type2;mod nested { trait Trait { fn method(&amp;amp;self) {} }}use impl nested::Trait for Type {}impl nested::Trait for Type2 {}Type.method(); // Compiles.Type2.method(); // error[E0599]: no method named `method` found for struct `Type2` in the current scopeThis also equally (importantly) applies to scoped implementations imported from elsewhere.Scoped implementations do not implicitly bring the trait into scopeThis so that no method calls on other types become ambiguous:struct Type;struct Type2;mod nested { trait Trait { fn method(&amp;amp;self) {} } trait Trait2 { fn method(&amp;amp;self) {} }}use nested::Trait2;impl Trait2 for Type {}impl Trait2 for Type2 {}use impl nested::Trait for Type {}impl nested::Trait for Type2 {}Type.method(); // Compiles, binds to scoped implementation of `Trait`.Type2.method(); // Compiles, binds to global implementation of `Trait2`.(If Trait was not yet globally implemented for Type2, and Trait and Type2 were defined in other crates, then bringing Trait into scope here could introduce instability towards that implementation later being added in one of those crates.)Shadowing with different boundsScoped implementations may have different bounds compared to an implementation they (partially) shadow. The compiler will attempt to satisfy those bounds, but if they are not satisfied, then the other implementation is not shadowed for that set of generic type parameters and no additional warning or error is raised.(Warnings for e.g. unused scoped implementations and scoped implementations that only shadow a covering global implementation are still applied as normal. It‚Äôs just that partial shadowing with different bounds is likely a common use-case in macros.)struct Type1;struct Type2;trait Trait1 { fn trait1() { println!(&quot;1&quot;); }}impl&amp;lt;T&amp;gt; Trait1 for T {} // &amp;lt;--trait Trait2 { fn trait2() { println!(&quot;2&quot;); }}impl Trait2 for Type2 {} // &amp;lt;--trait Say { fn say();}impl&amp;lt;T: Trait1&amp;gt; Say for Twhere T: Trait1, // &amp;lt;--{ fn say() { T::trait1(); }}{ use impl&amp;lt;T&amp;gt; Say for T where T: Trait2 // &amp;lt;-- { fn say() { T::trait2(); } } Type1::say(); // 1 Type2::say(); // 2}No priority over type-associated methodsScoped impl Trait for Type has the same method resolution priority as an equivalent global implementation would have if it was visible for method-binding in that scope. This means that directly type-associated functions still bind with higher priority than those available through scoped implementations.Coercion to trait objectsDue to the coercion into a trait object in the following code, the scoped implementation becomes attached to the value through the pointer meta data. This means it can then be called from other scopes:use std::fmt::{self, Display, Formatter};fn function() -&amp;gt; &amp;amp;&#39;static dyn Display { use impl Display for () { fn fmt(&amp;amp;self, f: &amp;amp;mut Formatter&amp;lt;&#39;_&amp;gt;) -&amp;gt; fmt::Result { write!(f, &quot;scoped&quot;) } } &amp;amp;()}println!(&quot;{}&quot;, function()); // &quot;scoped&quot;This behaves exactly as a global implementation would.Note that the DynMetadata&amp;lt;dyn Display&amp;gt;s of the reference returned above and one that uses the global implementation would compare as distinct even if both are ‚Äú&amp;amp;()‚Äù.Interaction with return-position impl TraitConsider the following functions:trait Trait {}fn function() -&amp;gt; impl Trait { use impl Trait for () {} () // Binds on trailing `()`-expression.}fn function2() -&amp;gt; impl Trait { use impl Trait for () {} {} // Binds on trailing `{}`-block used as expression.}In this case, the returned opaque types use the respective inner scoped implementation, as it binds on the () expression.The following functions do not compile, as the implicitly returned () is not stated inside the scope where the implementation is available:trait Trait {}fn function() -&amp;gt; impl Trait { ^^^^^^^^^^ use impl Trait for () {} --------------------- // Cannot bind on implicit `()` returned by function body without trailing *Expression*.}fn function2() -&amp;gt; impl Trait { ^^^^^^^^^^ use impl Trait for () {} --------------------- return; // Cannot bind on `return` without expression. -------}(The errors should ideally also point at the scoped implementations here with a secondary highlight, and suggest stating the return value explicitly.)The binding must be consistent:trait Trait {}fn function() -&amp;gt; impl Trait { // error: Inconsistent implementation of opaque return type. if true { use impl Trait for () {} return (); ---------- } else { use impl Trait for () {} return (); ^^^^^^^^^^ }}This function does compile, as the outer scoped impl Trait for () is bound on the if-else-expression as a whole.trait Trait {}fn function() -&amp;gt; impl Trait { use impl Trait for () {} if true { use impl Trait for () {} // warning: unused scoped implementation () } else { use impl Trait for () {} // warning: unused scoped implementation () }}This compiles because the end of the function is not reachable:trait Trait {}fn function() -&amp;gt; impl Trait { { use impl Trait for () {} return (); // Explicit `return` is required to bind in the inner scope. }}Static interception of dynamic callsAs a consequence of binding outside of generic contexts, it is possible to statically wrap specific trait implementations on concrete types. This includes the inherent implementations on trait objects:use std::fmt::{self, Display, Formatter};{ use impl Display for dyn Display { fn fmt(&amp;amp;self, f: &amp;amp;mut Formatter&amp;lt;&#39;_&amp;gt;) -&amp;gt; fmt::Result { // Restore binding to inherent global implementation within this function. use ::{impl Display for dyn Display}; write!(f, &quot;Hello! &quot;)?; d.fmt(f)?; write!(f, &quot; See you!&quot;) } } let question = &quot;What&#39;s up?&quot;; // &amp;amp;str println!(&quot;{question}&quot;); // &quot;What&#39;s up?&quot; let question: &amp;amp;dyn Display = &amp;amp;question; println!(&quot;{question}&quot;); // Binds to the scoped implementation; &quot;Hello! What&#39;s up? See you!&quot;}WarningsUnused scoped implementationScoped implementations and use-declarations of such (including those written as ImplEnvironmentEntry) receive a warning if unused. This can also happen if a use-declaration only reapplies a scoped implementation that is inherited from a surrounding item scope.(rust-analyzer should suggest removing any unused use-declarations as fix in either case.)An important counter-example:Filename: library/src/lib.rspub struct Type;pub struct Generic&amp;lt;T&amp;gt;;pub trait Trait {}use impl Trait for Type {}pub type Alias = Generic&amp;lt;Type&amp;gt;;Filename: main.rsuse std::any::TypeId;use library::{Alias, Generic, Type};assert_ne!(TypeId::of::&amp;lt;Alias&amp;gt;(), TypeId::of::&amp;lt;Generic&amp;lt;Type&amp;gt;&amp;gt;());Here, the scoped implementation use impl Trait for Type {} is accounted for as it is captured into the type identity of Alias.Since Alias is exported, the compiler cannot determine within the library alone that the type identity is unobserved. If it can ensure that that is the case, a (different!) warning could in theory still be shown here.Global trait implementation availableScoped implementations and use-declarations of such receive a specific warning if only shadowing a global implementation that would fully cover them. This warning also informs about the origin of the global implementation, with a ‚Äúdefined here‚Äù marker if in the same workspace. This warning is not applied to scoped implementations that at all shadow another scoped implementation.(Partial overlap with a shadowed scoped implementation should be enough to suppress this because setting the import up to be a precise subset could get complex fairly quickly. In theory just copying where-clauses is enough, but in practice the amount required could overall scale with the square of scoped implementation shadowing depth and some imports may even have to be duplicated.)It would make sense to let the definitions and also alternatively specific global implementations of traits with high implementation stability requirements like serde::{Deserialize, Serialize} deactivate this warning too, so that the latter don‚Äôt cause it on the respective covered scoped implementations.Self-referential bound of scoped implementationtrait Foo { }use impl&amp;lt;T&amp;gt; Foo for T where T: Foo { } --------- ^^^^^^A Rust developer may want to write the above to mean ‚Äòthis scoped implementation can only be used on types that already implement this trait‚Äô or ‚Äòthis scoped implementation uses functionality of the shadowed implementation‚Äô. However, since scoped impl Trait for Type uses item scope rules, any shadowed implementation is functionally absent in the entire scope. As such, this implementation, like the equivalent global implementation, cannot apply to any types at all.The warning should explain that and why the bound is impossible to satisfy.Private supertrait implementation required by public implementationConsider the following code:pub struct Type;use impl PartialEq for Type { // ...}pub use impl Eq for Type {}Here, the public implementation relies strictly on the private implementation to also be available. This means it effectively cannot be imported in use-declarations outside this module.See also the error incompatible-or-missing-supertrait-implementation.Public implementation of private trait/on private typeThe codestruct Type;trait Trait {}pub use impl Trait for Type {} ^^^^^ ^^^^should produce two distinct warnings similarly to those for private items in public signatures, as the limited visibilities of Type and Trait independently prevent the implementation from being imported in modules for which it is declared as visible.Scoped implementation is less visible than item/field it is captured inThe codepub struct Type;pub struct Generic&amp;lt;U, V&amp;gt;(U, V);trait Trait {} // &amp;lt;-- Visibility of the trait doesn&#39;t matter for *this* warning.use impl Trait for Type {}-----------------------pub type Alias = Generic&amp;lt;Type, Type&amp;gt;; ^^^^ ^^^^pub fn function(value: Generic&amp;lt;Type, Type&amp;gt;) -&amp;gt; Generic&amp;lt;Type, Type&amp;gt; { ^^^^ ^^^^ ^^^^ ^^^^ value}pub struct Struct { private: Generic&amp;lt;Type, Type&amp;gt;, // This is fine. pub public: Generic&amp;lt;Type, Type&amp;gt;, ^^^^ ^^^^}should produce eight warnings (or four/three warnings with multiple primary spans each, if possible). The warning should explain that the type can‚Äôt be referred to by fully specified name outside the crate/module and that the implementation may be callable from code outside the crate/module.If the binding is specified via inline implementation environment, then the warning should show up on the Trait in module span instead.Note that as with other private-in-public warnings, replacinguse impl Trait for Type {}withmod nested { use super::{Trait, Type}; pub use impl Trait for Type {}}use nested::{impl Trait for Type};in the code sample above should silence the warning.In some cases, adding as Trait in :: to the generic type argument could be suggested as quick-fix, though generally it‚Äôs better to fix this warning by moving the scoped implementation into a nested scope or moving it into a module and importing it into nested scopes as needed. This warning can‚Äôt be suppressed for private traits because the presence of their scoped implementation on a generic type parameter still affects the TypeId of the capturing generic, which here is visible outside of the discretising module.Imported implementation is less visible than item/field it is captured inThis occurs under the same circumstances as above, except thattrait Trait {}use impl Trait for Type {}is replaced withuse a_crate::{ Trait, impl Trait for Type,};(where here the implementation import is subsetting a blanket import, but that technicality isn‚Äôt relevant. What matters is that the implementation is from another crate).If the imported implementation is captured in a public item‚Äôs signature, that can accidentally create a public dependency. As such this should be a warning too (unless something from that crate occurs explicitly in that public signature or item?).ErrorsGlobal implementation of trait where global implementation of supertrait is shadowedA trait cannot be implemented globally for a discrete type in a scope where the global implementation of any of its supertraits is shadowed on that type.struct Type;trait Super {}trait Sub: Super {}impl Super for Type {}{ use impl Super for Type {} ----------------------- // &amp;lt;-- Scoped implementation defined/imported here. impl Sub for Type {} ^^^^^^^^^^^^^^^^^ //&amp;lt;-- error: global implementation of trait where global implementation of supertrait is shadowed}Negative scoped implementationThis occurs on all negative scoped implementations. Negative scoped implementations can be parsed, but are rejected shortly after macros are applied.struct Type;trait Trait {}impl Trait for Type {}{ use impl !Trait for Type {} ^^^^^^^^^^^^^^^^^^^^^^^^ error: negative scoped implementation}Incompatible or missing supertrait implementationImplementations of traits on discrete types require a specific implementation of each of their supertraits, as they bind to them at their definition, so they cannot be used without those being in scope too (to avoid perceived and hard to reason-about inconsistencies).struct Type;trait Super {}trait Sub: Super {}impl Super for Type {}mod nested { pub use impl Super for Type {} pub use impl Sub for Type {}}use nested::{impl Sub for Type}; ^^^^^^^^^^^^^^^^^ error: incompatible supertrait implementationRustc should suggest to import the required scoped implementation, if possible.See also the warning private-supertrait-implementation-required-by-public-implementation. See also implicit-import-of-supertrait-implementations-of-scoped-implementations-defined-on-discrete-types for a potential way to improve the ergonomics here.Scoped implementation of external sealed traitGiven crate a:mod private { pub trait Sealing {}}use private::Sealing;pub trait Sealed: Sealing {}pub use impl&amp;lt;T&amp;gt; Sealed for T {} // Ok.And crate b:use a::{ Sealed, impl Sealed for usize, // Ok.};use impl Sealed for () {} // Error. ^^^^^^Crate b cannot define scoped implementations of the external sealed trait Sealed, but can still import them.See no-external-scoped-implementations-of-sealed-traits for why this is necessary.Behaviour change/Warning: TypeId of implementation-aware generic discretised using generic type parametersAs a result of the transmutation permission given in layout-compatibility, which is needed to let the ErasedHashSet example in typeid-of-generic-type-parameters-opaque-types remain sound, monomorphisations of a function that observe distinct TypeIds for implementation-aware-generics they discretise using type parameters may be called on the same value instance.Notably, this affects TypeId::of::&amp;lt;Self&amp;gt;() in implementations with most generic targets, but not in unspecific blanket implementations on the type parameter itself.This would have to become a future incompatibility lint ahead of time, and should also remain a warning after the feature is implemented since the behaviour of TypeId::of::&amp;lt;Self&amp;gt;() in generics is likely to be unexpected.In most cases, implementations should change this to TypeId::of::&amp;lt;T&amp;gt;(), where T is the type parameter used for discretisation, since that should show only the expected TypeId distinction.Instead of TypeId::of::&amp;lt;AStruct&amp;lt;U, V, W&amp;gt;&amp;gt;(), TypeId::of::&amp;lt;(U, V, W)&amp;gt;() can be used, as tuples are implementation-invariant-generics.DrawbacksWhy should we not do this?First-party implementation assumptions in macrosIf a macro outputs a call of the form &amp;lt;$crate::Type as $crate::Trait&amp;gt;::method(), it can currently make safety-critical assumptions about implementation details of the method that is called iff implemented in the same crate.(This should also be considered relevant for library/proc-macro crate pairs where the macro crate is considered an implementation detail of the library even where the macro doesn‚Äôt require an unsafe token in its input, even though ‚Äúcrate privacy‚Äù currently isn‚Äôt formally representable towards Cargo.)As such, newly allowing the global trait implementation to be shadowed here can introduce soundness holes iff Trait is not unsafe or exempt from scoped implementations.(I couldn‚Äôt come up with a good example for this. There might be a slim chance that it‚Äôs not actually a practical issue in the ecosystem. Unfortunately, this seems to be very difficult to lint for.)There are a few ways to mitigate this, but they all have significant drawbacks: Opt-in scoped-impl Trait transparency for macros This would make scoped impl Trait for Types much less useful, as they couldn‚Äôt be used with for example some derive macros by default. It would also be necessary to teach the opt-in along with macros, which may not be realistic considering existing community-made macro primers. Implementation is likely complicated because many procedural macros emit tokens only with Span::call_site() hygiene, so information on the distinct binding site origin may not be readily available. This could be limited to existing kinds of macro definitions, so that future revised macro systems can be opted in by default. Future macros could use an unsafe trait instead to assume an implementation, or make use of scoped impl Trait for Type to enforce a specific implementation in their output. Drawback: Whether globally implemented behaviour can be changed by the consumer would depend on the macro. It would be good to surface a transparency opt-in in the documentation here. Opt-in scoped-impl Trait priority for macros This would preserve practical usefulness of the proposed feature in most cases. This would add significant complexity to the feature, as resolution of scoped implementations wouldn‚Äôt be exactly the same as for other items. (We should otherwise warn if a scoped impl Trait for Type outside a macro shadows binding a global implementation inside of it though, so at least the feature implementation complexity may be net zero in this regard.) This could be limited to existing kinds of macro definitions, with the same implications as for opt-in transparency above. Drawback: Whether globally implemented behaviour can be changed by the consumer would depend on the macro. It would be good to surface a priority opt-in in the documentation here. Forbid scoped impl Trait for Type if Trait and Type are from the same crate This would at best be a partial fix and would block some interesting uses of using-scoped-implementations-to-implement-external-traits-on-external-types. Unexpected behaviour of TypeId::of::&amp;lt;Self&amp;gt;() in implementations on generics in the consumer-side presence of scoped implementations and transmuteAs explained in rustdoc-documentation-changes, layout-compatibility and type-identity-of-generic-types, an observed TypeId can change for an instance under specific circumstances that are previously-legal transmutes as e.g. for the HashSets inside the type-erased value-keyed collection like the ErasedHashSet example in the typeid-of-generic-type-parameters-opaque-types section.This use case appears to be niche enough in Rust to not have an obvious example on crates.io, but see behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters for a lint that aims to mitigate issues in this regard and could be used to survey potential issues.More use-declaration clutter, potential inconsistencies between filesIf many scoped implementations need to be imported, this could cause the list of use-declarations to become less readable. If there are multiple alternatives available, inconsistencies could sneak in between modules (especially if scoped impl Trait for Type is used in combination with specialisation).This can largely be mitigated by centralising a crate‚Äôs scoped trait imports and implementations in one module, then wildcard-importing its items:// lib.rsmod scoped_impls;use scoped_impls::*;// scoped_impls.rsuse std::fmt::Debug;use a::{TypeA, TraitA};use b::{TypeB, TraitB};pub use a_b_glue::{impl TraitA for TypeB, impl TraitB for TypeA};// ...pub use impl Debug for TypeA { // ...}pub use impl Debug for TypeB { // ...}// ...// other .rs filesuse crate::scoped_impls::*;Type inference has to consider both scoped and global implementationsComplexity aside, this could cause compiler performance issues since caching would be less helpful.Fortunately, at least checking whether scoped implementations exist at all for a given trait and item scope should be reasonably inexpensive, so this hopefully won‚Äôt noticeably slow down compilation of existing code.That implementation environment binding on generic type parameters is centralised to the type discretisation site(s) may also help a little in this regard.Cost of additional monomorphised implementation instancesThe additional instantiations of implementations resulting from binding-choice-by-implementations-bounds could have a detrimental effect on compile times and .text size (depending on optimisations).This isn‚Äôt unusual for anything involving GenericParams, but use of this feature could act as a multiplier to some extent. It‚Äôs likely a good idea to evaluate relatively fine-grained caching in this regard, if that isn‚Äôt in place already.Split type identity may be unexpectedConsider crates like inventory or Bevy‚Äôs systems and queries.There may be tricky to debug issues for their consumers if a TypeId doesn‚Äôt match between uses of generics with superficially the same type parameters, especially without prior knowledge of distinction by captured implementation environments.A partial mitigation would be to have rustc include captured scoped implementations on generic type parameters when printing types, but that wouldn‚Äôt solve the issue entirely.Note that with this RFC implemented, TypeId would still report the same value iff evaluated on generic type parameters with distinct but bound-irrelevant captured implementations directly, as long as only these top-level implementations differ and no nested captured implementation environments do.Marking a generic as implementation-invariant is a breaking changeThis concerns the split of implementation-aware-generics and implementation-invariant-generics.‚ÄúImplementation-aware‚Äù is the logic-safe default.‚ÄúImplementation-invariant‚Äù has better ergonomics in some cases.It would be great to make moving from the default here only a feature addition. To do this, a new coherence rule would likely have to be introduced to make implementations conflict if any type becoming implementation-invariant would make them conflict, and additionally to make such implementations shadow each other (to avoid all-too-unexpected silent behaviour changes).However, even that would not mitigate the behaviour change of type-erasing collections that are keyed on such generics that become type-invariant later, so making this a breaking change is simpler and overall more flexible.Rationale and alternativesAvoid newtypes‚Äô pain pointsAlternative keywords: ergonomics and compatibility.Recursively dependent #[derive(‚Ä¶)]Many derives, like Clone, Debug, partial comparisons, serde::{Deserialize, Serialize} and bevy_reflect::{FromReflect, Reflect} require the trait to be implemented for each field type. Even with the more common third-party traits like Serde‚Äôs, there are many crates with useful data structures that do not implement these traits directly.As such, glue code is necessary.Current patternSome crates go out of their way to provide a compatibility mechanism for their derives, but this is neither the default nor has it (if available) any sort of consistency between crates, which means finding and interacting with these mechanisms requires studying the crate‚Äôs documentation in detail.For derives that do not provide such a mechanism, often only newtypes like NewSerdeCompatible and NewNeitherCompatible below can be used. However, these do not automatically forward all traits (and forwarding implementations may be considerably more painful than the derives), so additional glue code between glue crates may be necessary.use bevy_reflect::Reflect;use serde::{Deserialize, Serialize};use bevy_compatible::BevyCompatible;use neither_compatible::NeitherCompatible;use serde_compatible::SerdeCompatible;// I could not actually find much information on how to implement the Bevy-glue.// I assume it&#39;s possible to provide at least this API by creating a newtype and implementing the traits manually.use bevy_compatible_serde_glue::BevyCompatibleDef;use neither_compatible_bevy_glue::NewNeitherCompatible; // Assumed to have `From`, `Into` conversions.use neither_compatible_serde_glue::NeitherCompatibleDef;use serde_compatible_bevy_glue::NewSerdeCompatible; // Assumed to have `From`, `Into` conversions./// A typical data transfer object as it may appear in a service API.#[derive(Deserialize, Serialize, Reflect)]#[non_exhaustive] // Just a reminder, since the fields aren&#39;t public anyway.pub struct DataBundle { // Serde provides a way to use external implementations on fields (but it has to be specified for each field separately). // Bevy does not have such a mechanism so far, so newtypes are required. // The newtypes should be an implementation detail, so the fields are (for consistency all) private. #[serde(with = &quot;NewSerdeCompatibleDef&quot;)] serde: NewSerdeCompatible, #[serde(with = &quot;BevyCompatibleDef&quot;)] bevy: BevyCompatible, #[serde(with = &quot;NewNeitherCompatibleDef&quot;)] neither: NewNeitherCompatible,}// Some of the newtypes don&#39;t implement `Default` (maybe it was added to the underlying types later and the glue crate doesn&#39;t want to bump the dependency),// so this has to be implemented semi-manually instead of using the `derive`-macro.impl Default for DataBundle { fn default() -&amp;gt; Self { DataBundleParts::default().into() }}// If the Bevy glue doesn&#39;t forward the Serde implementations, this is necessary.#[derive(Deserialize, Serialize)]#[serde(remote = &quot;NewSerdeCompatible&quot;)]#[serde(transparent)]struct NewSerdeCompatibleDef(SerdeCompatible);// Same as above, but here the implementation is redirected to another glue crate.#[derive(Deserialize, Serialize)]#[serde(remote = &quot;NewNeitherCompatible&quot;)]#[serde(transparent)]struct NewNeitherCompatibleDef(#[serde(with = &quot;NeitherCompatibleDef&quot;)] NeitherCompatible);impl DataBundle { // These conversions are associated functions for discoverability. pub fn from_parts(parts: DataBundleParts) -&amp;gt; Self { parts.into() } pub fn into_parts(self) -&amp;gt; DataBundleParts { self.into() } // Necessary to mutate multiple fields at once. pub fn parts_mut(&amp;amp;mut self) -&amp;gt; DataBundlePartsMut&amp;lt;&#39;_&amp;gt; { DataBundlePartsMut { serde: &amp;amp;mut self.serde.0, bevy: &amp;amp;mut self.bevy, neither: &amp;amp;mut self.neither.0, } } // Accessors to the actual instances with the public types. pub fn serde(&amp;amp;self) -&amp;gt; &amp;amp;SerdeCompatible { &amp;amp;self.serde.0 } pub fn serde_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut SerdeCompatible { &amp;amp;mut self.serde.0 } // This also uses an accessor just for consistency. pub fn bevy(&amp;amp;self) -&amp;gt; &amp;amp;BevyCompatible { &amp;amp;self.bevy } pub fn bevy_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut BevyCompatible { &amp;amp;mut self.bevy } // More accessors. pub fn neither(&amp;amp;self) -&amp;gt; &amp;amp;NeitherCompatible { &amp;amp;self.neither.0 } pub fn neither_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut NeitherCompatible { &amp;amp;mut self.neither.0 }}// Conversions for convenienceimpl From&amp;lt;DataBundleParts&amp;gt; for DataBundle { fn from(value: DataBundleParts) -&amp;gt; Self { Self { serde: value.serde.into(), bevy: value.bevy.into(), neither: value.neither.into(), } }}impl From&amp;lt;DataBundle&amp;gt; for DataBundleParts { fn from(value: DataBundle) -&amp;gt; Self { Self { serde: value.serde.into(), bevy: value.bevy, neither: value.neither.into(), } }}/// Used to construct and destructure [`DataBundle`].#[derive(Default)] // Assume that all the actual field types have useful defaults.#[non_exhaustive]pub struct DataBundleParts { pub serde: SerdeCompatible, pub bevy: BevyCompatible, pub neither: NeitherCompatible,}/// Return type of [`DataBundle::parts_mut`].#[non_exhaustive]pub struct DataBundlePartsMut&amp;lt;&#39;a&amp;gt; { pub serde: &amp;amp;&#39;a mut SerdeCompatible, pub bevy: &amp;amp;&#39;a mut BevyCompatible, pub neither: &amp;amp;&#39;a mut NeitherCompatible,}If two traits that require newtype wrappers need to be added for the same type, the process can be even more painful than what‚Äôs shown above, involving unsafe reinterpret casts to borrow a wrapped value correctly as each newtype and forwarding-implementing each trait manually if no transparent derive is available.With scoped impl Trait for TypeScoped impl Trait for Type eliminates these issues, in a standardised way that doesn‚Äôt require any special consideration from the trait or derive crates:use bevy_reflect::Reflect;use serde::{Deserialize, Serialize};use bevy_compatible::BevyCompatible;use neither_compatible::NeitherCompatible;use serde_compatible::SerdeCompatible;// I could not actually find much information on how to implement Bevy-glue.// It&#39;s about the same as manually implementing the traits for newtypes, though.// Since many traits are required for `bevy_reflect`&#39;s derives, those glue crates use the prelude pattern and provide one for each target type.use bevy_compatible_serde_glue::{ impl Deserialize&amp;lt;&#39;_&amp;gt; for BevyCompatible, impl Serialize for BevyCompatible,};use neither_compatible_bevy_glue::preludes::neither_compatible::*;use neither_compatible_serde_glue::{ impl Deserialize&amp;lt;&#39;_&amp;gt; for NeitherCompatible, impl Serialize for NeitherCompatible,};use serde_compatible_bevy_glue::preludes::serde_compatible::*;/// A typical data transfer object as it may appear in a service API.#[derive(Default, Deserialize, Serialize, Reflect)]#[non_exhaustive]pub struct DataBundle { // Everything just works. pub serde: SerdeCompatible, pub bevy: BevyCompatible, pub neither: NeitherCompatible,}// `Default` was derived normally.// No glue for the glue is necessary.// No conversions are needed to construct or destructure.// `&amp;amp;mut`-splitting is provided seamlessly by Rust.// No accessors are needed since the fields are public.Even in cases where the glue API cannot be removed, it‚Äôs still possible to switch to this simplified, easier to consume implementation and deprecate the original indirect API.Note that the imported scoped implementations are not visible in the public API here, since they do not appear on generic type parameters in public items. There may still be situations in which defining a type alias is necessary to keep some scoped implementations away from generic type parameters. In some cases, it could be enough to add as Trait in :: to generic type arguments to restore their implementation environment to contain global implementations only. In some cases, where a field type is quoted in a derive macro directly, writing (Type as Trait in module) only there could in theory also work, but this would heavily depend on the macro‚Äôs implementation details. See also should-it-be-an-error-to-specify-an-implementation-environment-in-places-where-its-guaranteed-to-be-unused.Unlike with external newtypes, there are no potential conflicts beyond overlapping imports and definitions in the same scope. These conflicts can always be resolved both without editing code elsewhere and without adding an additional implementation: either by narrowing a local blanket implementation, by narrowing a blanket implementation import to a subset of the external implementation, or at worst by moving a generic implementation into a submodule and importing it for discrete types.Error handling and conversionsWhen implementing services, it‚Äôs a common pattern to combine a framework that dictates function signatures with one or more unrelated middlewares that have their own return and error types. The example below is a very abridged example of this.Note that in either version, the glue code may be project-specific. Glue code is very slightly more concise when implemented with scoped impl Trait for Type, as intermediary struct definitions and the resulting field access can be avoided.Current pattern// crate `service`use framework::{Error, Returned};use middleware_a::{fallible_a, Error as ErrorA};use middleware_b::{fallible_b, Error as ErrorB};use framework_middleware_a_glue::{IntoReturnedExt as _, NewErrorA};use framework_middleware_b_glue::{IntoReturnedExt as _, NewErrorB};pub fn a() -&amp;gt; Result&amp;lt;Returned, Error&amp;gt; { // A `try` block should work eventually, but it may be not much less verbose. Ok((|| -&amp;gt; Result&amp;lt;_, NewErrorA&amp;gt; { fallible_a()?; Ok(fallible_a()?) })()? .into_returned())}pub fn b() -&amp;gt; Result&amp;lt;Returned, Error&amp;gt; { // The same as above. Ok((|| -&amp;gt; Result&amp;lt;_, NewErrorB&amp;gt; { fallible_b()?; Ok(fallible_b()?) })()? .into_returned())}pub fn mixed(condition: bool) -&amp;gt; Result&amp;lt;Returned, Error&amp;gt; { // Neither &#39;NewError&#39; type provided by third-party crates can be used directly here. Ok((move || -&amp;gt; Result&amp;lt;_, NewError&amp;gt; { Ok(if condition { fallible_b()?; fallible_a()?.into_returned() } else { fallible_a()?; fallible_b()?.into_returned() }) })()?)}// Custom glue to connect all three errors:struct NewError(Error);impl From&amp;lt;NewError&amp;gt; for Error { fn from(value: NewError) -&amp;gt; Self { value.0 }}impl From&amp;lt;ErrorA&amp;gt; for NewError { fn from(value: ErrorA) -&amp;gt; Self { let intermediate: NewErrorA = value.into(); Self(intermediate.into()) }}impl From&amp;lt;ErrorB&amp;gt; for NewError { fn from(value: ErrorB) -&amp;gt; Self { let intermediate: NewErrorB = value.into(); Self(intermediate.into()) }}use service::{a, b, mixed};fn main() { framework::setup() .add_route(&quot;a&quot;, a) .add_route(&quot;b&quot;, b) .add_route(&quot;mixed&quot;, mixed) .build() .run();}With scoped impl Trait for Type// crate `service`// More concise, since middleware errors are used only once in imports.use framework::{Error, Returned};use middleware_a::fallible_a;use middleware_b::fallible_b;// Note: It is often better to import `impl Into` here over `impl From`,// since middleware types often don&#39;t appear in public signatures.//// If the target type of the import must appear as type parameter in a public signature,// a module that is wildcard-imported into each function body can be used instead,// which would amount to 6 additional and 2 modified lines here.//// This RFC includes a warning for unintentionally exposed scoped implementations.use framework_middleware_a_glue::{ impl Into&amp;lt;Returned&amp;gt; for middleware_a::Returned, impl Into&amp;lt;Error&amp;gt; for middleware_a::Error,};use framework_middleware_b_glue::{ impl Into&amp;lt;Returned&amp;gt; for middleware_b::Returned, impl Into&amp;lt;Error&amp;gt; for middleware_b::Error,};pub fn a() -&amp;gt; Result&amp;lt;Returned, Error&amp;gt; { // It just works. fallible_a()?; Ok(fallible_a()?.into())}pub fn b() -&amp;gt; Result&amp;lt;Returned, Error&amp;gt; { // Here too. fallible_b()?; Ok(fallible_b()?.into())}pub fn mixed(condition: bool) -&amp;gt; Result&amp;lt;Returned, Error&amp;gt; { // This too just works, as conversions bind separately. Ok(if condition { fallible_b()?; fallible_a()?.into() } else { fallible_a()?; fallible_b()?.into() })}// No custom glue is necessary at all.// Unchanged. No change in the API of `service`, either.use service::{a, b, mixed};fn main() { framework::setup() .add_route(&quot;a&quot;, a) .add_route(&quot;b&quot;, b) .add_route(&quot;mixed&quot;, mixed) .build() .run();}Note that to export discrete scoped impl Into in addition to their scoped impl From, the glue crates can use the following pattern, which discretises the global implementation and as such binds to each scoped impl From in the respective exported scoped impl Into:pub use ::{ impl Into&amp;lt;framework::Returned&amp;gt; for middleware_a::Returned, impl Into&amp;lt;framework::Error&amp;gt; for middleware_a::Error,};Preserve coherenceCross-crate stabilityWith this RFC, scopes are a ‚Äòmini version‚Äô of the environment that global implementations exist in. As this environment is sealed within one scope, and not composed from multiple crates that may update independently, the orphan rule is not necessary.All other coherence rules and (for exported implementations) rules for what is and is not a breaking change apply within each scope exactly like for global implementations. In particular: Blanket implementations like // (Does not compile!)use std::fmt::{Debug, LowerHex, Pointer};mod debug_by_lower_hex;use debug_by_lower_hex::{impl&amp;lt;T: LowerHex&amp;gt; Debug&amp;lt;T&amp;gt; for T}; // &amp;lt;--use impl&amp;lt;T: Pointer&amp;gt; Debug&amp;lt;T&amp;gt; for T { // &amp;lt;-- // ...} still conflict regardless of actual implementations of LowerHex and Pointer because they may overlap later and because scoped implementation are explicitly subset where they are imported, it is not a breaking change to widen an exported scoped implementation. (This is part of the reason why scoped impl Trait for Types are anonymous; names would make these imports more verbose rather than shorter, since the subsetting still needs to happen in every case.) Logical consistencyBinding external top-level implementations to types is equivalent to using their public API in different ways, so no instance-associated consistency is expected here. Rather, values that are used in the same scope behave consistently with regard to that scope‚Äôs visible implementations.of generic collectionsGenerics are trickier, as their instances often do expect trait implementations on generic type parameters that are consistent between uses but not necessarily declared as bounded on the struct definition itself.This problem is solved by making the impls available to each type parameter part of the the type identity of the discretised host generic, including a difference in TypeId there as with existing monomorphisation.(See type-parameters-capture-their-implementation-environment and type-identity-of-generic-types in the reference-level-explanation above for more detailed information.)Here is an example of how captured implementation environments safely flow across module boundaries, often seamlessly due to type inference:pub mod a { // ‚ìê == ‚óØ use std::collections::HashSet; #[derive(PartialEq, Eq)] pub struct A; pub type HashSetA = HashSet&amp;lt;A&amp;gt;; pub fn aliased(_: HashSetA) {} pub fn discrete(_: HashSet&amp;lt;A&amp;gt;) {} pub fn generic&amp;lt;T&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) {}}pub mod b { // ‚ìë use std::{ collections::HashSet, hash::{Hash, Hasher}, }; #[derive(PartialEq, Eq)] pub struct B; use impl Hash for B { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } pub type HashSetB = HashSet&amp;lt;B&amp;gt;; // ‚ö† pub fn aliased(_: HashSetB) {} pub fn discrete(_: HashSet&amp;lt;B&amp;gt;) {} // ‚ö† pub fn generic&amp;lt;T&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) {}}pub mod c { // ‚ìí == ‚óØ use std::collections::HashSet; #[derive(PartialEq, Eq, Hash)] pub struct C; pub type HashSetC = HashSet&amp;lt;C&amp;gt;; pub fn aliased(_: HashSetC) {} pub fn discrete(_: HashSet&amp;lt;C&amp;gt;) {} pub fn generic&amp;lt;T&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) {}}pub mod d { // ‚ìì use std::{ collections::HashSet, hash::{Hash, Hasher}, iter::once, }; use super::{ a::{self, A}, b::{self, B}, c::{self, C}, }; use impl Hash for A { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } use impl Hash for B { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } use impl Hash for C { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } fn call_functions() { a::aliased(HashSet::new()); // ‚ìê == ‚óØ a::discrete(HashSet::new()); // ‚ìê == ‚óØ a::generic(HashSet::from_iter(once(A))); // ‚äô == ‚ìì b::aliased(HashSet::from_iter(once(B))); // ‚ìë b::discrete(HashSet::from_iter(once(B))); // ‚ìë b::generic(HashSet::from_iter(once(B))); // ‚äô == ‚ìì c::aliased(HashSet::from_iter(once(C))); // ‚ìí == ‚óØ c::discrete(HashSet::from_iter(once(C))); // ‚ìí == ‚óØ c::generic(HashSet::from_iter(once(C))); // ‚äô == ‚ìì }}Note that the lines annotated with // ‚ö† produce a warning due to the lower visibility of the scoped implementation in b.Circles denote implementation environments: ¬† ¬† ‚óØ indistinct from global ‚ìê, ‚ìë, ‚ìí, ‚ìì respectively as in module a, b, c, d ‚äô caller-side The calls infer discrete HashSets with different Hash implementations as follows: call in call_functions impl Hash in captured in/at notes a::aliased - type alias The implementation cannot be ‚Äòinserted‚Äô into an already-specified type parameter, even if it is missing. a::discrete - fn signature See a::aliased. a::generic d once&amp;lt;T&amp;gt;¬†call ¬† b::aliased b type alias ¬† b::discrete b fn signature ¬† b::generic d once&amp;lt;T&amp;gt;¬†call b‚Äôs narrow implementation cannot bind to the opaque T. c::aliased :: type alias Since the global implementation is visible in c. c::discrete :: fn signature See c::aliased. c::generic d once&amp;lt;T&amp;gt;¬†call The narrow global implementation cannot bind to the opaque T. of type-erased collectionsType-erased collections such as the ErasedHashSet shown in typeid-of-generic-type-parameters-opaque-types require slightly looser behaviour, as they are expected to mix instances between environments where only irrelevant implementations differ (since they don‚Äôt prevent this mixing statically like std::collections::HashSet, as their generic type parameters are transient on their methods).It is for this reason that the TypeId of generic type parameters disregards bounds-irrelevant implementations.The example is similar to the previous one, but aliased has been removed since it continues to behave the same as discrete. A new set of functions bounded is added:#![allow(unused_must_use)] // For the `TypeId::‚Ä¶` lines.trait Trait {}pub mod a { // ‚ìê == ‚óØ use std::{collections::HashSet, hash::Hash}; #[derive(PartialEq, Eq)] pub struct A; pub fn discrete(_: HashSet&amp;lt;A&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;A&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;A&amp;gt;(); // ‚ù∑ } pub fn generic&amp;lt;T: &#39;static&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑ } pub fn bounded&amp;lt;T: Hash + &#39;static&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑ }}pub mod b { // ‚ìë use std::{ collections::HashSet, hash::{Hash, Hasher}, }; use super::Trait; #[derive(PartialEq, Eq)] pub struct B; use impl Hash for B { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } use impl Trait for B {} pub fn discrete(_: HashSet&amp;lt;B&amp;gt;) { // ‚ö†‚ö† TypeId::of::&amp;lt;HashSet&amp;lt;B&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;B&amp;gt;(); // ‚ù∑ } pub fn generic&amp;lt;T: &#39;static&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑ } pub fn bounded&amp;lt;T: Hash + &#39;static&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑ }}pub mod c { // ‚ìí == ‚óØ use std::{collections::HashSet, hash::Hash}; use super::Trait; #[derive(PartialEq, Eq, Hash)] pub struct C; impl Trait for C {} pub fn discrete(_: HashSet&amp;lt;C&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;C&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;C&amp;gt;(); // ‚ù∑ } pub fn generic&amp;lt;T: &#39;static&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑ } pub fn bounded&amp;lt;T: Hash + &#39;static&amp;gt;(_: HashSet&amp;lt;T&amp;gt;) { TypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂ TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑ }}pub mod d { // ‚ìì use std::{ collections::HashSet, hash::{Hash, Hasher}, iter::once, }; use super::{ a::{self, A}, b::{self, B}, c::{self, C}, Trait, }; use impl Hash for A { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } use impl Hash for B { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } use impl Hash for C { fn hash&amp;lt;H: Hasher&amp;gt;(&amp;amp;self, _state: &amp;amp;mut H) {} } use impl Trait for A {} use impl Trait for B {} use impl Trait for C {} fn call_functions() { a::discrete(HashSet::new()); // ‚ìê == ‚óØ a::generic(HashSet::from_iter(once(A))); // ‚äô == ‚ìì a::bounded(HashSet::from_iter(once(A))); // ‚äô == ‚ìì b::discrete(HashSet::from_iter(once(B))); // ‚ìë b::generic(HashSet::from_iter(once(B))); // ‚äô == ‚ìì b::bounded(HashSet::from_iter(once(B))); // ‚äô == ‚ìì c::discrete(HashSet::from_iter(once(C))); // ‚ìí == ‚óØ c::generic(HashSet::from_iter(once(C))); // ‚äô == ‚ìì c::bounded(HashSet::from_iter(once(C))); // ‚äô == ‚ìì }}// ‚ö† and non-digit circles have the same meanings as above.The following table describes how the types are observed at runtime in the lines marked with ‚ù∂ and ‚ù∑. Types are denoted as if seen from the global implementation environment with differences written inline, which should resemble how they are formatted in compiler messages and tooling. within function(called by call_functions) ‚ù∂ (collection) ‚ù∑ (item) a::discrete HashSet&amp;lt;A&amp;gt; A a::generic HashSet&amp;lt;A as Hash in d + Trait in d&amp;gt; A a::bounded HashSet&amp;lt;A as Hash in d + Trait in d&amp;gt; A ‚àò Hash in d b::discrete HashSet&amp;lt;B as Hash in b + Trait in b&amp;gt; B b::generic HashSet&amp;lt;B as Hash in d + Trait in d&amp;gt; B b::bounded HashSet&amp;lt;B as Hash in d + Trait in d&amp;gt; B ‚àò Hash in d c::discrete HashSet&amp;lt;C&amp;gt; C c::generic HashSet&amp;lt;C as Hash in d + Trait in d&amp;gt; C c::bounded HashSet&amp;lt;C as Hash in d + Trait in d&amp;gt; C ‚àò Hash in d The combination ‚àò is not directly expressible in TypeId::of::&amp;lt;&amp;gt; calls (as even a direct top-level annotation would be ignored without bounds). Rather, it represents an observation like this:{ use std::{any::TypeId, hash::Hash}; use a::A; use d::{impl Hash for A}; fn observe&amp;lt;T: Hash + &#39;static&amp;gt;() { TypeId::of::&amp;lt;T&amp;gt;(); // &#39;`A` ‚àò `Hash in d`&#39; } observe::&amp;lt;A&amp;gt;();}with multiple erased type parametersBy replacing the linesTypeId::of::&amp;lt;HashSet&amp;lt;T&amp;gt;&amp;gt;(); // ‚ù∂TypeId::of::&amp;lt;T&amp;gt;(); // ‚ù∑withTypeId::of::&amp;lt;HashSet&amp;lt;(T,)&amp;gt;&amp;gt;(); // ‚ù∂TypeId::of::&amp;lt;(T)&amp;gt;(); // ‚ù∑(and analogous inside the discrete functions), the TypeId table above changes as follows: within function(called by call_functions) ‚ù∂ (collection) ‚ù∑ (item) a::discrete HashSet&amp;lt;(A,)&amp;gt; (A,) a::generic HashSet&amp;lt;(A as Hash in d + Trait in d,)&amp;gt; (A,) a::bounded HashSet&amp;lt;(A as Hash in d + Trait in d,)&amp;gt; (A ‚àò Hash in d,) b::discrete HashSet&amp;lt;(B as Hash in b + Trait in b,)&amp;gt; (B,) b::generic HashSet&amp;lt;(B as Hash in d + Trait in d,)&amp;gt; (B,) b::bounded HashSet&amp;lt;(B as Hash in d + Trait in d,)&amp;gt; (B ‚àò Hash in d,) c::discrete HashSet&amp;lt;(C,)&amp;gt; (C,) c::generic HashSet&amp;lt;(C as Hash in d + Trait in d,)&amp;gt; (C,) c::bounded HashSet&amp;lt;(C as Hash in d + Trait in d,)&amp;gt; (C ‚àò Hash in d,) As you can see, the type identity of the tuples appears distinct when contributing to an implementation-aware generic‚Äôs type identity but (along with the TypeId) remains appropriately fuzzy when used alone.This scales up to any number of type parameters used in implementation-invariant generics, which means an efficient ErasedHashMap&amp;lt;S: BuildHasher&amp;gt; can be constructed by keying storage on the TypeId::of::&amp;lt;(K, V)&amp;gt;() where K: Hash + Eq and V are the generic type parameters of its functions.Logical stability Non-breaking changes to external crates cannot change the meaning of the program. Breaking changes should result in compile-time errors rather than a behaviour change.This is another consequence of subsetting rather than named-model imports, as narrowing a scoped implementation can only make the use-declaration fail to compile, rather than changing which implementations are shadowed.Similarly, types of generics with different captured implementation environments are strictly distinct from each other, so that assigning them inconsistently does not compile. This is weighed somewhat against ease of refactoring, so in cases where a type parameter is inferred and the host is used in isolation, which are assumed to not care about implementation details like that, the code will continue to align with the definition instead of breaking.Encourage readable codeThis RFC aims to further decrease the mental workload required for code review, by standardising glue code APIs to some degree and by clarifying their use in other modules.It also aims to create an import grammar that can be understood more intuitively than external newtypes when first encountered, which should improve the accessibility of Rust code somewhat.Clear importsAs scoped implementations bind implicitly like global ones, two aspects must be immediately clear at a glace: Which trait is implemented? Which type is targeted?Restating this information in the use-declaration means that it is available without leaving the current file, in plaintext without any tooling assists. This is another improvement compared to newtypes or external definitions, where the relationship may not be immediately clear depending on their names.Spelling scoped implementation imports out with keywords rather than just symbols makes their purpose easy to guess for someone unfamiliar with the scoped impl Trait for Type feature, possibly even for most English-speaking developers unfamiliar with Rust.This is also true for blanket imports with where, which remain easy to parse visually due to the surrounding braces:use std::fmt::{Debug, Display, Pointer};// `Debug` and `Display` all `Pointer`-likes as addresses.// The `Display` import is different only to show the long form// with `where`. It could be written like the `Debug` import.use cross_formatting::by_pointer::{ impl&amp;lt;T: Pointer&amp;gt; Debug for T, {impl&amp;lt;T&amp;gt; Display for T where T: Pointer},};println!(&quot;{:?}&quot;, &amp;amp;()); // For example: 0x7ff75584c360println!(&quot;{}&quot;, &amp;amp;()); // For example: 0x7ff75584c360Familiar grammarThe grammar for scoped implementations differs from that for global implementations by only a prefixed use and an optional visibility. As such, it should be easy to parse for developers not yet familiar with scoped implementations specifically.The clear prefix (starting with at least two keywords instead of one) should still be enough to distinguish scoped implementations at a glance from global ones.The header (the part before the {} block) of global implementations is reused unchanged for scoped implementation imports, including all bounds specifications, so there is very little grammar to remember additionally in order to use scoped impl Trait for Types.In each case, the meaning of identical grammar elements lines up exactly - only their context and perspective vary due to immediately surrounding tokens.(See grammar-changes for details.)Stop tokens for humansWhen looking for the scoped implementation affecting a certain type, strict shadowing ensures that it is always the closest matching one that is effective.As such, readers can stop scanning once they encounter a match (or module boundary, whether surrounding or nested), instead of checking the entire file‚Äôs length for another implementation that may be present in the outermost scope.Aside from implementation environments captured inside generics, scoped implementations cannot influence the behaviour of another file without being mentioned explicitly.Unblock ecosystem evolutionAs any number of scoped glue implementations can be applied directly to application code without additional compatibility shims, it becomes far easier to upgrade individual dependencies to their next major version. Compatibility with multiple versions of crates like Serde and bevy_reflect can be provided in parallel through officially supported glue crates.Additionally, scoped implementations are actually more robust than newtypes regarding certain breaking changes:A newtype that implements multiple traits could eventually gain a global blanket implementation of one of its traits for types that implement another of its traits, causing a conflict during the upgrade.In the presence of an overlapping scoped impl Trait for Type, the new blanket implementation is just unambiguously shadowed where it would conflict, which means no change is necessary to preserve the code‚Äôs behaviour. A global-trait-implementation-available warning is still shown where applicable to alert maintainers of new options they have.(See also glue-crate-suggestions for possible future tooling related to this pattern.)Side-effect: Parallelise build plans (somewhat) moreSerde often takes a long time to build even without its macros. If another complex crate depends on it just to support its traits, this can significantly stretch the overall build time.If glue code for ‚Äòoverlay‚Äô features like Serde traits is provided in a separate crate, that incidentally helps to reduce that effect somewhat:Since the glue forms a second dependency chain that normally only rejoins in application code, the often heavier core functionality of libraries can build in parallel to Serde and/or earlier glue. Since the glue chain is likely to be less code, it matters less for overall build time whether it has to wait for one or two large crates first.Provide opportunities for rich toolingDiscovery of implementationsAs scoped implementations clearly declare the link between the trait and type(s) they connect, tools like rust-analyzer are able to index them and suggest imports where needed, just like for global traits.(At least when importing from another crate, the suggested import should be for a specific type or generic, even if the export in question is a blanket implementation. Other generics of the export can usually be preserved, though.)Discovery of the feature itselfIn some cases (where a trait implementations cannot be found at all), tools can suggest creating a scoped implementation, unless adding it in that place would capture it as part of the implementation environment of a type parameter specified in an item definition visible outside the current crate.That said, it would be great if rust-analyzer could detect and suggest/enable feature-gated global implementations to some extent, with higher priority than creating a new scoped implementation.Rich and familiar warnings and error messagesSince scoped implementations work much like global ones, many of the existing errors and warnings can be reused with at most small changes. This means that, as developers become more familiar with either category of trait-related issues, they learn how to fix them for global and scoped implementations at the same time.The implementation of the errors and warnings in the compiler can also benefit from the existing work done for global implementations, or in some cases outright apply the same warning to both scoped and global implementations.Since available-but-not-imported scoped implementations are easily discoverable by the compiler, they can be used to improve existing errors like error[E0277]: the trait bound [‚Ä¶] is not satisfied and error[E0599]: no method named [‚Ä¶] found for struct [‚Ä¶] in the current scope with quick-fix suggestions also for using an existing scoped implementation in at least some cases.Maintenance warnings for ecosystem evolutionScoped impl Trait for Types lead to better maintenance lints:If a covering global implementation later becomes available through a dependency, a warning can be shown on the local trait implementation for review. (See global-trait-implementation-available.)In the long run, this can lead to less near-duplicated functionality in the dependency graph, which can lead to smaller executable sizes.Automatic documentationScoped implementations can be documented and appear as separate item category in rustdoc-generated pages.Rustdoc should be able to detect and annotate captured scoped implementations in public signatures automatically. This, in addition to warnings, could be another tool to help avoid accidental exposure of scoped implementations.Implementation origin and documentation could be surfaced by rust-analyzer in relevant places.Why specific implementation-invariant-generics?This is a not entirely clean ergonomics/stability trade-off, as well as a clean resolution path for behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters. It is also the roughest part of this proposal, in my eyes. If you have a better way of dealing with the aware/invariant distinction, please do suggest it!The main issue is that generics in the Rust ecosystem do not declare which trait implementations on their type parameters need to be consistent during their instances‚Äô lifetime, if any, and that traits like PartialOrd that do provide logical consistency guarantees over time are not marked as such in a compiler-readable way.Ignoring this and not having distinction of implementation-aware-generics‚Äô discretised variants would badly break logical consistency of generic collections like BTreeSet&amp;lt;T&amp;gt;, which relies on Ord-consistency to function.On the other hand, certain types (e.g. references and (smart) pointers) that often wrap values in transit between modules really don‚Äôt care about implementation consistency on these types. If these were distinct depending on available implementations on their values, it would create considerable friction while defining public APIs in the same scope as struct or enum definitions that require scoped implementations for derives.Drawing a line manually here is an attempt to un-break this by default for the most common cases while maintaining full compatibility with existing code and keeping awareness of scoped impl Trait for Type entirely optional for writing correct and user-friendly APIs.As a concrete example, this ensures that Box&amp;lt;dyn Future&amp;lt;Output = Result&amp;lt;(), Error&amp;gt;&amp;gt;&amp;gt; is automatically interchangeable even if spelled out in the presence of scoped error-handling-and-conversions affecting Error, but that BinaryHeap&amp;lt;Box&amp;lt;u8&amp;gt;&amp;gt; and BinaryHeap&amp;lt;Box&amp;lt;u8 as PartialOrd in reverse + Ord in reverse&amp;gt;&amp;gt; don‚Äôt mix.Functions pointers and closure trait( object)s should probably be fairly easy to pass around, with their internally-used bindings being an implementation detail. Fortunately, the Rust ecosystem already uses more specific traits for most configuration for better logical safety, so it‚Äôs likely not too messy to make these implementation-invariant.Traits and trait objects cannot be implementation invariant by default (including for their associated types!) because it‚Äôs already possible to define OrderedExtend and OrderedIterator traits with logical consistency requirement on Ord between them.Efficient compilationIn theory, it should be possible to unify many instances of generic functions that may be polymorphic under this proposal cheaply before code generation. (Very few previously discrete implementations become polymorphic under scoped impl Trait for Type.)This is mainly an effect of layout-compatibility and binding-choice-by-implementations-bounds, so that, where the differences are only bounds-irrelevant, generated implementations are easily identical in almost all cases. The exception here are implementation-aware-generics‚Äô TypeIds (see also typeid-of-generic-type-parameters-opaque-types). Checking for this exception should be cheap if done alongside checks for e.g. function non-constness if possible, which propagates identically from callee to caller.Given equal usage, compiling code that uses scoped implementations could as such be slightly more efficient compared to use of newtypes and the resulting text size may be slightly smaller in some cases where newtype implementations are inlined differently.The compiler should treat implementations of the same empty trait on the same type as identical early on, so that no code generation is unnecessarily duplicated. However, unrelated empty-trait implementations must still result in distinct TypeIds when captured in a generic type parameter and observed there by a where-clause or through nesting in an implementation-aware generic.AlternativesNamed implementationsUse of named implementations is not as obvious as stating the origin-trait-type triple in close proximity, so code that uses named implementations tends to be harder to read.Like named implementations, the scope-identified implementations proposed here can be written concisely in generic parameter lists (as Type as Trait in module), limiting the code-writing convenience advantage of named implementations. Where needed, the module name can be chosen to describe specific function, e.g. exporting reverse-ordering Ord and PartialOrd implementations from a module called reverse.If named implementations can‚Äôt be brought into scope (see Genus in lightweight-flexible-object-oriented-generics), that limits their practical application to where they can be captured in implementation-aware-generics. Bringing named implementations into scope would be more verbose than for module-trait-type-identified as subsetting would still be required to preserve useful room for library crate evolution.Weakening coherence rulesThere is likely still some leeway here before the Rust ecosystem becomes brittle, but at least the orphan rule specifically is essential for ensuring that global trait implementations do not lead to hard ecosystem splits due to strictly incompatible framework crates.If other coherence rules are relaxed, scoped impl Trait for Type also benefits immediately since it is subject to all of them.Crate-private implementations as distinct featureThere is a previous RFC: Hidden trait implementations from 2018-2021 where the result was general acceptance, but postponement for logistical reasons.Scoped impl Trait for Type together with its warnings scoped-implementation-is-less-visible-than-itemfield-it-is-captured-in and imported-implementation-is-less-visible-than-itemfield-it-is-captured-in can mostly cover this use-case, though with slightly more boilerplate (use-declarations) and not as-strict a limitation.Required-explicit binding of scoped implementations inside genericsThis could avoid the distinction between implementation-aware-generics and implementation-invariant-generics to some extent, at the cost of likely overall worse ergonomics when working with scoped implementations.It‚Äôs also likely to make derive-compatibility of scoped implementations inconsistent, because some macros may require explicit binding on field types while others would not.Prior artLightweight, Flexible Object-Oriented GenericsYizhou Zhang, Matthew Loring, Guido Salvaneschi, Barbara Liskov and Andrew C. Myers, May 2015https://www.cs.cornell.edu/andru/papers/genus/There are some parallels between Genus‚Äôs models and the scoped impl Trait for Types proposed in this RFC, but for the most part they are quite distinct due to Rust‚Äôs existing features: Genus scoped impl Trait for Type reasoning Proper-named models Anonymous scoped implementations Use of existing coherence constraints for validation. Forced subsetting in use-declarations improves stability. The impl Trait for Type syntax stands out in use-declarations and is intuitively readable. Explicit bindings of non-default models Mainly implicit bindings, but explicit bindings of scoped and global implementations are possible in some places. Focus on simplicity and ergonomics of the most common use-case. More natural use with future specialisation. Comparing containers inherently constrain type parameters in their type definition. Available scoped implementations for discretised type parameters become part of the type identity. &amp;lt;p&amp;gt;This is a tradeoff towards integration with Rust‚Äôs ecosystem, as generics are generally not inherently bounded on collection types in Rust.&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;There is likely some friction here with APIs that make use of runtime type identity. See split-type-identity-may-be-unexpected.&amp;lt;/p&amp;gt; Some features are largely equivalent: Genus Rust (without scoped impl Trait for Type) notes / scoped impl Trait for Type Implicitly created default models Explicit global trait implementations Duck-typed implementation of unknown external traits is unnecessary since third party crates‚Äô implementations are as conveniently usable in scope as if global. Runtime model information / Wildcard models Trait objects Scoped implementations can be captured in trait objects, and the TypeId of generic type parameters can be examined. This does not allow for invisible runtime specialisation in all cases. Bindings [only for inherent constraints on generic type parameters?] are part of type identity not applicable &amp;lt;p&amp;gt;Available implementations on type parameters of discretised implementation-aware generics are part of the type identity. Top-level bindings are not.&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Genus‚Äôs approach provides better remote-access ergonomics than ùí¢‚Äôs and great robustness when moving instances through complex code, so it should be available. Fortunately, the existing style of generic implementations in Rust can simply be monomorphised accordingly, and existing reflexive blanket conversions and comparisons can bind regardless of unrelated parts of the top-level implementation environment of their type parameters.&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;However, typical Rust code also very heavily uses generics like references and closures to represent values passed through crate boundaries. To keep friction acceptably low by default, specific utility types are exempt from capturing implementation environments in their type parameters.&amp;lt;/p&amp;gt; A Language for Generic Programming in the LargeJeremy G. Siek, Andrew Lumsdaine, 2007https://arxiv.org/abs/0708.2255ùí¢ and scoped impl Trait for Type are conceptually very similar, though this RFC additionally solves logical consistency issues that arise from having multiple alternative ways to fulfill a constraint and develops some ideas further than the paper. Other differences are largely due to ùí¢ being more C++-like while scoped impl Trait for Type attempts smooth integration with all relevant Rust language features.A few notable similarities, in the paper‚Äôs words: equivalent retroactive modeling (where existing Rust‚Äôs is limited by orphan rules), (retained) separate compilation (though some information can flow between items in this RFC, but only where such information flows already exist in Rust currently), lexically scoped models, seemingly the same binding rules on generic type parameters within constrained models/generic implementations,and key differences: ùí¢ Rust / scoped impl Trait for Type notes Only discrete model imports Includes generic imports and re-exports This is pointed out as ‚Äò[left] for future work‚Äô in the paper. Here, it follows directly from the syntax combination of Rust‚Äôs use and impl Trait for Type items. - (Rust) Global implementations The automatic availability of global implementations between separately imported traits and types offers more convenience especially when working with common traits, like those backing operators in Rust. Model overloading, mixed into nested scopes Strict shadowing Strict shadowing is easier to reason about for developers (especially when writing macros!), as the search stops at the nearest matching implementation or module boundary.See Rust‚Äôs trait method resolution behaviour and interaction-with-specialisation for how this is still practically compatible with a form of overload resolution.See scoped-fallback-implementations for a possible future way to better enable adaptive behaviour in macro output. - (Rust) Trait objects ùí¢ does not appear to support runtime polymorphism beyond function pointers. Scoped impl Trait for Type is seamlessly compatible with dyn Trait coercions (iff Trait is object-safe). (unclear?) Available implementations on discretised type parameters become part of the type identity of implementation-aware generics. This allows code elsewhere to access scoped implementations that are already available at the definition site, and leads to overall more semantically consistent behaviour. Unresolved questions‚Äúglobal‚Äù implementationsI‚Äôm not too sure about the ‚Äúglobal‚Äù wording. Technically that implementation isn‚Äôt available for method calls unless the trait is in scope‚Ä¶ though it is available when resolving generics. Maybe ‚Äúunscoped‚Äù is better?Precise resolution location of implementation environments in function callsIn macros, which function-call token should provide the resolution context from where to look for scoped impl Trait for Types (in all possible cases)?This doesn‚Äôt matter for Span::call_site() vs. Span::mixed_site() since scoped implementations would resolve transparently through both, but it does matter for Span::def_site() which should exclude them.It very much does matter if one of the opt-in mitigations for first-party-implementation-assumptions-in-macros is implemented.Which structs should be implementation-invariant?This is a tough question because, runtime behaviour difference of of-type-erased-collections aside, the following makes shifting a type from implementation-aware-generics to implementation-invariant-generics a compilation-breaking change:struct Type;struct Generic&amp;lt;T&amp;gt;(T);trait Trait {}mod a { use super::{Type, Generic, Trait}; pub use impl Trait for Type {} pub type Alias = Generic&amp;lt;T&amp;gt;;}mod b { use super::{Type, Generic, Trait}; pub use impl Trait for Type {} pub type Alias = Generic&amp;lt;T&amp;gt;;}use impl Trait for a::Alias {}use impl Trait for b::Alias {}(It is theoretically possible to do such a later adjustment as part of an edition, even considering TypeId behaviour I think, but it‚Äôs certainly not pretty.)Splitting this along the line of ‚Äústructs that use &amp;lt;&amp;gt; around type parameters‚Äù would feel cleaner, but the basic smart pointers, Pin&amp;lt;P&amp;gt;, Option&amp;lt;T&amp;gt; and Result&amp;lt;T, E&amp;gt; appear in crate API signatures enough that not including them would create considerable friction.Other candidates for consideration: Other DispatchFromDyn types in the standard library like Cell, SyncUnsafeCell, UnsafeCellShould it be an error to specify an implementation environment in places where it‚Äôs guaranteed to be unused?With the given grammar-changes, it‚Äôs possible to write fn((Type as Trait in module)), but, at least without a surrounding host, here the implementation environment written inline is completely ineffective because function pointer types are discretised implementation-invariant-generics.On the other hand, making it an error rather than a unused-scoped-implementation warning could easily cause problems for macros.Future possibilitiesExporting a scoped implementation as global, extern impl TraitThis should never be used for IO/serialisation traits.Application crates may want to provide a specific implementation globally, disregarding orphan rules since there are no downstream crates that could be impacted by future incompatibilities (and crate-local issues are largely mitigated by Cargo.lock).This could later be allowed using a construct like// Use an external implementation as global:#[core::unstable_use_as_global]use impl_crate::{impl Trait for Type};// Provide a local implementation globally:#[core::unstable_use_as_global]use impl Trait for Type { /*...*/ }To use a global implementation not available through one of its dependencies, a library crate would have to declare it:extern impl Trait for Type;This would result in a compile error or link-time error if the declaration is not fully covered by a global trait implementation.If the trait implementation is later made available plainly (that is: without use, subject to orphan rules) by a dependency, a warning should appear on the extern impl declaration, along with the suggestion to remove the extern impl item.(However, I assume binding to implementations not-from dependencies or the same crate in this way has a lot of implications for code generation.)There is previous discussion regarding a similar suggestion in a slightly different context: [Pre-RFC] Forward implsPerhaps the downsides here could be mitigated by allowing #[unstable_use_as_global] very strictly only in application crates compiled with the cargo --locked flag.Scoped impl Trait for Type of auto traits, Drop and/or Copy with orphan rulesThe crate in which a type is defined could in theory safely provide scoped implementations for it also for these traits. This is likely more complicated to implement than the scoped impl Trait for Types proposed in this RFC, as these traits interact with more distinct systems. What would be the binding site of Drop in let-statements? This could interact with linear types, were those to be added later on. For example, database transactions could be opt-out linear by being !Drop globally but also having their crate provide a scoped Drop implementation that can be imported optionally to remove this restriction in a particular consumer scope. Scoped proxy implementationsIn theory it might be possible to later add syntax to create an exported implementation that‚Äôs not in scope for itself.I‚Äôm very hesitant about this since doing so would allow transparent overrides of traits (i.e. proxying), which could be abused for JavaScript-style layered overrides through copy-pasting source code together to some extent.Analogous scoped impl TypeThis could be considered as more-robust alternative to non-object-safe extension traits defined in third party crates.A good example of this use case could be the tap crate, which provides generic extension methods applicable to all types, but where its use is theoretically vulnerable to instability regarding the addition of type-associated methods of the same name(s).If instead of (or in addition to!) ‚Ä¶:// pipe.rspub trait Pipe { #[inline(always)] fn pipe&amp;lt;R&amp;gt;(self, func: impl FnOnce(Self) -&amp;gt; R) -&amp;gt; R where Self: Sized, R: Sized, { func(self) } // ...}impl&amp;lt;T&amp;gt; Pipe for T where T: ?Sized {}‚Ä¶the extension could be defined as ‚Ä¶:pub use impl&amp;lt;T&amp;gt; T where T: ?Sized { #[inline(always)] fn pipe&amp;lt;R&amp;gt;(self, func: impl FnOnce(Self) -&amp;gt; R) -&amp;gt; R where Self: Sized, R: Sized, { func(self) } // ...}‚Ä¶then: The consumer crate could choose which types to import the extension for, weighing use tap::pipe::{impl Type1, impl Type2}; against use tap::pipe::{impl&amp;lt;T&amp;gt; T where T: ?Sized}; These scoped extensions would shadow inherent type-associated items of the same name, guaranteeing stability towards those being added. (This should come with some warning labels in the documentation for this feature, since adding items to an existing public scoped extension could be considered an easily-breaking change here.) This has fewer benefits compared to scoped impl Trait for Type, but would still allow the use of such third-party extension APIs in library crates with very high stability requirements.An open question here is whether (and how) to allow partially overlapping use impl Type in the same scope, in order to not shadow inherent associated items with ones that cannot be implemented for the given type. That could in theory be more convenient to use, but calls could be subtly inconsistent at the consumer side, i.e. accidentally calling an inherent method if a scoped extension method was expected and widening a public implementation to overlap more of another exported in the same module could break dependent crates if a wide blanket import applied to narrower extensions. As such, if this feature was proposed and accepted at some point in the future, it would likely be a good idea to only allow non-overlapping implementations to be exported.Interaction with specialisation Scoped impl Trait for Type can be used for consumer-side specialisation of traits for binding sites that are in item scope, by partially shadowing an outer scope‚Äôs implementation. Note that this would not work on generic type parameters, as the selected implementation is controlled strictly by their bounds (See resolution-on-generic-type-parameters.), but it would work in macros for the most part. This does not interact with specialisation proper, but rather is a distinct, less powerful mechanism. As such, it would not supersede specialisation. Scoped impl Trait for Type does not significantly interact with specialisation of global implementations. Any global specialisation would only be resolved once it‚Äôs clear no scoped implementation applies. Specialisation could disambiguate scoped implementations which are provided (implemented or imported) in the same scope. For example, use dummy_debug::{impl&amp;lt;T&amp;gt; Debug for T};use debug_by_display::{impl&amp;lt;T: Display&amp;gt; Debug for T};use impl Debug for str { // ...} would then compile, in scope resolving &amp;lt;str as Debug&amp;gt; to the local implementation and otherwise binding Debug depending on whether Display is available at the binding site for each given type T. Local implementations do not necessarily have to be more specific compared to imported ones - in keeping with ‚Äúthis is the same as for global implementations‚Äù, the way in which the scoped implementation is introduced to the scope should not matter to specialisation. When importing scoped implementations from a module, specialisation should apply hierarchically. First, the specificity of implementations is determined only by use impl implementations and use-declarations in the importing scope. If the trait bound binds to a use-declaration, then the actual implementation is chosen by specificity among those visible in the module they are imported from. If the chosen implementation there is an import, the process repeats for the next module. This ensures stability and coherence when published implementations are specialised in other modules. I‚Äôm not sure how well this can be cached in the compiler for binding-sites in distinct scopes, unfortunately. Fortunately, specialisation of scoped impl Trait for Type does not seem like a blocker for specialisation of global trait implementations. Should specialisation of scoped implementations require equal visibility? I think so, but this question also seems considerably out of scope for scoped impl Trait as Type as a feature itself. Scoped impl Trait for Type as associated itemScoped impl Trait for Type could be allowed and used as associated non-object-safe item as follows:trait OuterTrait { use impl Trait for Type;}fn function&amp;lt;T: OuterTrait&amp;gt;() { use T::{impl Trait for Type}; // ...configured code...}impl OuterTrait for OtherType { // Or via `use`-declaration of scoped implementation(s) defined elsewhere! // Or specify that the global implementation is used (somehow)! use impl Trait for Type { // ... }}function::&amp;lt;OtherType&amp;gt;();This would exactly supersede the following more verbose pattern enabled by this RFC:trait OuterTrait { type Impl: ImplTraitFor&amp;lt;Type&amp;gt;;}trait ImplTraitFor&amp;lt;T: ?Sized&amp;gt; { // Copy of trait&#39;s associated items, but using `T` instead of the `Self` type and // e.g. a parameter named `this` in place of `self`-parameters.}fn function&amp;lt;T: OuterTrait&amp;gt;() { use impl Trait for Type { // Implement using `T::Impl`, associated item by associated item. } // ...configured code...}struct ImplTraitForType;impl ImplTraitFor&amp;lt;Type&amp;gt; for ImplTraitForType { // Implement item-by-item, as existing scoped `impl Trait for Type` cannot be used here.}impl OuterTrait for OtherType { type Impl: ImplTraitFor&amp;lt;Type&amp;gt; = ImplTraitForType;}function::&amp;lt;OtherType&amp;gt;(); In theory this could be made object-safe if the associated implementation belongs to an object-safe trait, but this would introduce much-more-implicit call indirection into Rust.Scoped fallback implementationsA scoped fallback implementation could be allowed, for example by negatively bounding it on the same trait in the definition or import:#[derive(Debug)]struct Type1;struct Type2;{ use debug_fallback::{impl&amp;lt;T&amp;gt; Debug for T where T: !Debug}; dbg!(Type1); // Compiles, uses global implementation. dbg!(Type2); // Compiles, uses fallback implementation.}This would be a considerably less messy alternative to autoref- or autoderef-specialisation for macro authors.Note that ideally, these fallback implementations would still be required to not potentially overlap with any other (plain or fallback) scoped implementation brought into that same scope.Negative scoped implementationsIt‚Äôs technically possible to allow negative scoped implementations that only shadow the respective implementation from an outer scope. For example:// signed-indexing/src/arrays/prelude.rsuse core::ops::Index;pub use impl&amp;lt;T, const N: usize&amp;gt; !Index&amp;lt;usize&amp;gt; for [T; N] {}pub use impl&amp;lt;T, const N: usize&amp;gt; Index&amp;lt;isize&amp;gt; for [T; N] { type Output = T; #[inline] #[track_caller] fn index(&amp;amp;self, index: isize) -&amp;gt; &amp;amp;T { match index { 0.. =&amp;gt; self[index as usize], ..=-1 =&amp;gt; if let Some(index) = self.len().checked_add_signed(index) { self[index] } else { #[inline(never)] #[track_caller] fn out_of_bounds(len: usize, index: isize) -&amp;gt; ! { panic!(&quot;Tried to index slice of length {len} with index {index}, which is too negative to index backwards here.&quot;); } out_of_bounds(self.len(), index); }, } }}use signed_indexing::arrays::prelude::*;let array = [1, 2, 3];// Unambiguous:let first = array[0];let last = array[-1];This is likely a rather niche use-case.It could also be useful in the context of scoped-fallback-implementations.Implicit import of supertrait implementations of scoped implementations defined on discrete typesAs subtype implementations defined on discrete types always require specific supertrait implementations, the import of these supertrait implementations could be made implicit.This would also affect implementation environments modified in generic arguments, changinglet min_heap: BinaryHeap&amp;lt;u32 as PartialOrd in reverse + Ord in reverse&amp;gt; = [1, 3, 2, 4].into();tolet min_heap: BinaryHeap&amp;lt;u32: Ord in reverse&amp;gt; = [1, 3, 2, 4].into();anddbg!(&amp;lt;u32 as Ord in reverse where u32 as PartialOrd in reverse&amp;gt;::cmp(&amp;amp;1, &amp;amp;2)); // [‚Ä¶] = Greatertodbg!(&amp;lt;u32 as Ord in reverse&amp;gt;::cmp(&amp;amp;1, &amp;amp;2)); // [‚Ä¶] = GreaterThe downside is that use-declarations would become less obvious. Implied supertrait implementation imports could be enabled only for implementation environments specified inline on generic type parameters as e.g. Type as Ord in module to avoid this.If this is added later than scoped impl Trait for Type, then private scoped implementations must not be implicitly exported through this mechanism. (It‚Äôs likely a good idea to not allow that anyway, as it would be surprising.) Making previously crate-private implementations available that way could lead to unsoundness.AlternativelyIt could be enough to allow inferring the module explicitly by writing _ instead of its SimplePath, so that the snippets above becomelet min_heap: BinaryHeap&amp;lt;u32 as PartialOrd in _ + Ord in reverse&amp;gt; = [1, 3, 2, 4].into();anddbg!(&amp;lt;(u32 as PartialOrd in _) as Ord in reverse&amp;gt;::cmp(&amp;amp;1, &amp;amp;2)); // [‚Ä¶] = GreaterHere, too, the inference should only be of required supertrait implementations based on explicitly chosen implementations of their subtraits.Conversions where a generic only cares about specific bounds‚Äô consistencyWith specialisation and more expressive bounds, an identity conversion like the following could be implemented:// In the standard library.use std::mem;impl&amp;lt;T, U, S: BuildHasher&amp;gt; From&amp;lt;HashSet&amp;lt;T, S&amp;gt;&amp;gt; for HashSet&amp;lt;U, S&amp;gt;where T: ?Hash + ?Eq, // Observe implementations without requiring them. U: ?Hash + ?Eq, T == U, // Comparison in terms of innate type identity and observed implementations.{ fn from(value: HashSet&amp;lt;T, S&amp;gt;) -&amp;gt; Self { unsafe { // SAFETY: This type requires only the `Hash` and `Eq` implementations to // be consistent for correct function. All other implementations on // generic type parameters may be exchanged freely. // For the nested types this is an identity-transform, as guaranteed // by `T == U` and the shared `S` which means the container is also // guaranteed to be layout compatible. mem::transmute(value) } }}This could also enable adjusted borrowing:// In the standard library.use std::mem;impl&amp;lt;T, S: BuildHasher&amp;gt; HashSet&amp;lt;T, S&amp;gt; { fn as_with_item_impl&amp;lt;U&amp;gt;(&amp;amp;self) -&amp;gt; HashSet&amp;lt;U, S&amp;gt; where T: ?Hash + ?Eq, // Observe implementations without requiring them. U: ?Hash + ?Eq, T == U, // Comparison in terms of innate type identity and observed implementations. { unsafe { // SAFETY: This type requires only the `Hash` and `Eq` implementations to // be consistent for correct function. All other implementations on // generic type parameters may be exchanged freely. // For the nested types this is an identity-transform, as guaranteed // by `T == U` and the shared `S` which means the container is also // guaranteed to be layout compatible. &amp;amp;*(self as *const HashSet&amp;lt;T, S&amp;gt; as *const HashSet&amp;lt;U, S&amp;gt;) } }}(But at that point, it may be better to use something like an unsafe marker trait or unsafe trait with default implementations.)Sealed trait boundsThis is probably pretty strange, and may not be useful at all, but it likely doesn‚Äôt hurt to mention this.Consider ImplEnvironment clauses in bounds like here:use another_crate::{Trait, Type1, Type2};pub fn function&amp;lt;T as Trait in self&amp;gt;() {}pub use impl Trait for Type1 {}pub use impl Trait for Type2 {}With this construct, function could privately rely on implementation details of Trait on Type1 and Type2 without defining a new sealed wrapper trait. It also becomes possible to easily define multiple sealed sets of implementations this way, by defining modules that export them.Overall this would act as a more-flexible but also more-explicit counterpart to sealed traits.Iff the caller is allowed to use this function without restating the binding, then removing the scope would be a breaking change (as it is already with bindings captured on type parameters in public signatures, so that would be consistent for this syntactical shape). That convenience (automatically using the correct implementations even if not in scope) also really should exist only iff there already is robust, near-effortless tooling for importing existing scoped implementations where missing. Otherwise this feature here would get (ab)used for convenience, which would almost certainly lead to painful overly sealed APIs.Binding an implementation in a call as function::&amp;lt;T as Trait in a&amp;gt;() while it is constrained as fn function&amp;lt;T as Trait in b&amp;gt;() { ‚Ä¶ } MUST fail for distinct modules a and b even if the implementations are identical, as otherwise this would leak the implementation identity into the set of breaking changes.Glue crate suggestionsIf crates move some of their overlay features into glue crates, as explained in unblock-ecosystem-evolution, it would be nice if they could suggest them if both they and e.g. Serde were cargo added as direct dependencies of a crate currently being worked on.An example of what this could look like:[package]name = &quot;my-crate&quot;version = &quot;0.1.2&quot;edition = &quot;2021&quot;[dependencies]# none[suggest-with.serde.&quot;1&quot;]my-crate_serde_glue = &quot;0.1.0&quot;[suggest-with.bevy_reflect.&quot;0.11&quot;]my-crate_bevy_reflect_glue = &quot;0.1.2&quot;[suggest-with.bevy_reflect.&quot;0.12&quot;]my-crate_bevy_reflect_glue = &quot;0.2.1&quot;(This sketch doesn‚Äôt take additional registries into account.)Ideally, crates.io should only accept existing crates here (but with non-existing version numbers) and Cargo should by default validate compatibility where possible during cargo publish.Reusable limited-access APIsGiven a newtype of an unsized type, like#[repr(transparent)]pub struct MyStr(str);for example, there is currently no safe-Rust way to convert between &amp;amp;str and &amp;amp;MyStr or Box&amp;lt;MyStr&amp;gt; and Box&amp;lt;str&amp;gt;, even though in the current module which can see the field this is guaranteed to be a sound operation.One good reason for this is that there is no way to represent this relationship with a marker trait, since any global implementation of such a trait would give outside code to this conversion too.With scoped impl Trait for Type, the code above could safely imply a marker implementation like the following in the same scope:// Visibility matches newtype or single field, whichever is more narrow.use unsafe impl Transparent&amp;lt;str&amp;gt; for MyStr {}use unsafe impl Transparent&amp;lt;MyStr&amp;gt; for str {}// Could symmetry be implied instead?(Transparent can and should be globally reflexive.)This would allow safe APIs with unlimited visibility likepub fn cast&amp;lt;T: Transparent&amp;lt;U&amp;gt;, U&amp;gt;(value: T) -&amp;gt; U { unsafe { // SAFETY: This operation is guaranteed-safe by `Transparent`. std::mem::transmute(value) }}andunsafe impl&amp;lt;T: Transparent&amp;lt;U&amp;gt;, U&amp;gt; Transparent&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; for Box&amp;lt;T&amp;gt; {}unsafe impl&amp;lt;&#39;a, T: Transparent&amp;lt;U&amp;gt;, U&amp;gt; Transparent&amp;lt;&amp;amp;&#39;a U&amp;gt; for &amp;amp;&#39;a T {}unsafe impl&amp;lt;&#39;a, T: Transparent&amp;lt;U&amp;gt;, U&amp;gt; Transparent&amp;lt;&amp;amp;&#39;a mut U&amp;gt; for &amp;amp;&#39;a mut T {}which due to their bound would only be usable where the respective T: Transparent&amp;lt;U&amp;gt;-implementation is in scope, that is: where by-value unwrapping-and-then-wrapping would be a safe operation (for Sized types in that position).Overall, this would make unsized newtypes useful without unsafe, by providing a compiler-validated alternative to common reinterpret-casts in their implementation. The same likely also applies to certain optimisations for Sized that can‚Äôt be done automatically for unwrap-then-wrap conversions as soon as a custom Allocator with possible side-effects is involved.If a module wants to publish this marker globally, it can do so with a separate global implementation of the trait, which won‚Äôt cause breakage. (As noted in efficient-compilation, the compiler should treat implementations of empty traits as identical early on, so that no code generation is unnecessarily duplicated.) Could sharing pointers like Arc inherit this marker from their contents like Box could? I‚Äôm unsure. They probably shouldn‚Äôt since doing this to exposed shared pointers could easily lead to hard-to-debug problems depending on drop order. A global unsafe impl&amp;lt;T: Transparent&amp;lt;U&amp;gt;, U&amp;gt; Transparent&amp;lt;UnsafeCell&amp;lt;U&amp;gt;&amp;gt; for UnsafeCell&amp;lt;T&amp;gt; {} should be unproblematic, but a global unsafe impl&amp;lt;T&amp;gt; Transparent&amp;lt;T&amp;gt; for UnsafeCell&amp;lt;T&amp;gt; {} (or vice versa) must not exist to allow the likely more useful implementations on &amp;amp;-like types." }, { "title": "Asteracea (as of right now) üåº", "url": "/posts/Asteracea/", "categories": "Rust, Asteracea", "tags": "web, frontend, components, DSL", "date": "2022-05-14 15:25:00 +0200", "snippet": "This is a relatively high-level summary post of design decisions I made so far while implementing Asteracea and its related packages like the lignin group of crates. I‚Äôm making this post partially in response to Raph Levien‚Äôs Xilem: an architecture for UI in Rust, since I noticed we have largely similar approaches to app structure and lifecycle management (although we went for somewhat different solutions that are presented in superficially very different ways to the developer).Funnily enough, our architectures are both named after plant biology. I previously explained my choice as follows: Why the name? I‚Äôd started naming my projects after plants shortly before starting this one. Asteraceae are often plain but wildly varied flowering plants.My wish with this project is to create a ‚Äúboring‚Äù system that is uninteresting by itself and highlights the user‚Äôs individuality. The name also reflects that I‚Äôd like to support the creation of individual ‚Äúweb gardens‚Äù (small creative pages usually by individuals) as well as sustainable development of large enterprise apps (by encouraging maintainable code style through enterprise features like built-in dependency injection, as well as a green deployment due to (vastly) decreased runtime energy usage and hardware requirements).(My system uses mutable but largely non-moving data structures, so its supporting crates like lignin or rhizome tend to be named after structural components rather than transport tissue, though.)A Word of CautionFirst off, my professional background is largely web frontend development (about 1.5 years of specific experience?), and I don‚Äôt exactly have a formal education in this space. Similarly, I picked up English largely while teaching myself how to program. There may be rough patches in terms of vocabulary ahead, in either regard.I‚Äôll also have to rely on examples and comparisons a bit more, since I lack the theoretical knowledge to name the different existing UI framework API patterns.As such, please take everything here with a grain of salt, and feel free to point out issues. I‚Äôm used to harsh criticism and don‚Äôt mind as long as it attacks my ideas rather than something I have no control over.MotivationI originally started work on Asteracea in late 2019, as part of a program I could host on my local network that would let me track itemised grocery bills and monitor individual product price changes. At the time, I also needed a break from JavaScript, but still decided to make it a website, so that I could use it easily on mobile without dealing with Android Studio.Many of the choices I made and features I added are direct responses to frustrations I encountered while working as a consultant on web app projects, as well as as user of a fairly old computer, a phone with low system memory and frequently a slow internet connection.I like websites that work also without JavaScript and don‚Äôt start with a loading screen, won‚Äôt unload other apps as soon as I browse to them, and don‚Äôt hog the CPU. As a developer, I prefer to work with very strongly typed languages and to have documentation available directly in the IDE, to reduce the amount of time I spend on a feature and the amount of context switches I have to do.Additionally, and this is purely personal preference, I love small indie projects and also like crafting my own web presence in detail. (I have not gotten around to doing the latter, for the most part.)As such, I didn‚Äôt want to make a framework aimed only at larger scale deployments, but one that scales down nicely to even the smallest and simplest of pages and isn‚Äôt prescriptive in terms of document structure.GoalsAsteracea is my attempt at making (web) frontend development both more convenient and more accessible, while raising the quality of the compiled applications.The system is built from modular and often interchangeable parts, so while I‚Äôm working towards a turn-key bundle, you don‚Äôt have to use my macro DSL to make your components compatible with mine. This is also to enable incremental upgrades of the platform without spilling all application code along with it. (Some glue may be required between distinct paradigms, where there could be a mismatch in the API shape exposed by individual components.)Personally, both boilerplate and syntactic noise irk me though, so I created a relatively concise macro transform that translates symbols and keywords into structural aspects of the component, while identifiers are mostly used only for application-level constructs.ProblemsThe main issue with implementing a classic model-view-controller pattern in Rust is that lifecycle management of stateful hierarchical GUIs is a huge chore, largely due to callbacks that have to reach deep into encapsulated components (while mutability of inert data is much less of a problem).Component-instantiating GUI frameworks like Angular or WinForms tend to be very boilerplate-heavy, buying a straightforward mental model with dense syntax and/or restated structure. (WinForms gets around this with a designer and generated code, but that‚Äôs not a good option for web development, where a well-organised document structure often describes intent more than visual primitives.)Their strength is maintainable development at scale, as they hide transient local state very well and often allow for better code organisation than other paradigms.Mainly reactive frameworks like eponymically React, which generate the GUI structure from only a render method, have greatly simplified syntax but often need workarounds for state management.React‚Äôs Hooks for example are very convenient, but they suffer from footguns related to control flow (that you can very reliably lint against, to be fair) and can‚Äôt entirely remove initialisation from their hot update path without potentially changing behaviour. They also tend to scale less-than-ideally to more complex applications, mostly hurting code organisation and maintainability.WPF is overall well-designed and its basic features are very accessible due to great first-party tooling, but full use of its advanced features is not all that well communicated (with a large gap between consuming and providing them) and the framework is non-portable, which is stifling broader adoption.However, many of its systems rely on externally-visible fairly direct mutability of components, which doesn‚Äôt translate all that well into plain Rust.(.NET as a whole is not great at tree-shaking unused code due to its runtime metaprogramming features, but that‚Äôs not a problem with WPF in particular, just something that came up while I was thinking about how to make applications tiny enough for the clientside web.)Immediate-mode GUIs like imgui or Unity‚Äôs editor GUI system have the advantage of being able to reuse language constructs like loops directly to model aspects of a hierarchical GUI (and save many of the nested parentheses you see in the structurally similar reactive ones, so their syntax tends to be cleaner and more open-ended), but they mostly suffer from very inconvenient state management for child components.My ApproachI‚Äôm remixing existing ideas (including from all of the above).If you look at the individual pieces that make up Asteracea, you‚Äôll likely notice that nearly all of them already exist in some shape or form elsewhere.This framework aims to be ‚Äúboring‚Äù: The macro DSL is mostly contextless and generates unspectacular code you could easily hand-write (if you didn‚Äôt mind a lot of verbosity and a bit of straightforward unsafe code for pin projections), the procedural macro lowers syntactic sugar in steps (both by transforming and reparsing in terms of its own syntax, and by delegating to existing general-purpose macros in its output), the generated HTML- and DOM-structure is no-frills as-if-handwritten, with no structural restrictions like mandatory custom elements and there are no surprises that would suddenly lower app performance because you weren‚Äôt explicit enough.The one original concept that I didn‚Äôt see elsewhere before are interlaced local scopes, though I wouldn‚Äôt be surprised if that has been done elsewhere, as it‚Äôs a straightforward source code transformation.Reference-counting through direct payload borrows is something I came up with on a whim, but later learned already has standard library support in C++ (although in a slightly different way that doesn‚Äôt mesh with strict provenance in Rust).I‚Äôll annotate from where I lifted different concepts below each heading.My SolutionsEverything explained here is implemented and functional (on some branch in the repository, but mostly indeed develop), unless otherwise noted. You‚Äôre invited to have a go at playing around with it, but keep in mind that there are some usability holes (and no standard library worth mentioning), and that some of the syntax is subject to change as I continue to simplify it.There is a Zulip Stream for this project, in case you have questions or would like to give feedback on this post.Apologies for the outdated versions on Crates.io; I started work on larger changes a while back and haven‚Äôt finished polishing and documenting everything yet.Interlaced Local Scopes for Localised SemanticsThe smallest, empty, component, which is a ZST, does not have inherent identity, does not incur allocations and does not generate output in either HTML or DOM, is roughly this:asteracea::component! { Empty()() []}Which likely looks pretty odd. (Yes, that‚Äôs two parameter lists.)I went with a use-what-you-need approach to reduce the boilerplate required for simple components. Stateful and pure reactive components are unified, with no baseline runtime overhead. There are some trade-offs in updating the DOM, as the underlying lignin is a classic, so far double-buffered, diffed VDOM for easier modularity and platform-independence.I‚Äôll explain the basic structure in terms of this counter component:use asteracea::services::Invalidator;use lignin::web::{Event, Materialize};use std::sync::atomic::{AtomicUsize, Ordering};asteracea::component! { /// A simple counter. pub(crate) Counter( priv dyn invalidator: dyn Invalidator, starting_count: usize, )( class?: &amp;amp;&#39;bump str, button_text: &amp;amp;str = &quot;Click me!&quot;, ) &amp;lt;div .class?={class} let self.count = AtomicUsize::new(starting_count); !&quot;This button was clicked {} times:&quot;(self.count.load(Ordering::Relaxed)) &amp;lt;button !(button_text) on bubble click = active Self::on_click &amp;gt; /div&amp;gt;}impl Counter { fn on_click(&amp;amp;self, event: Event) { // This needs work. let event: web_sys::Event = event.materialize(); event.stop_propagation(); self.count.fetch_add(1, Ordering::Relaxed); self.invalidator.invalidate_with_context(None); }}(Embedding the code here isn‚Äôt ideal, since it loses the semantic highlights it normally has via rust-analyzer. Screenshot)Components are struct types with some associated functions, so they accept documentation and a visibility, and have a name that‚Äôs an item identifier in their containing scope. (First two lines inside the macro.)Next are the constructor parameters, in the first pair of parentheses: dyn name: Type uses the dependency injection mechanism (inspired by Angular) to retrieve a value and bind it to name. Meanwhile, Type acts as a token here and not only controls what is retrieved, but also how it is made available, and, if applicable, how it is lazily injected into the dependency tree. (The entry point here is the trait rhizome::sync::Extract, in my development version as of now.) A dyn Trait should usually extract itself as pinning sharing resource handle, which keeps the resource tree node its instance is stored in alive. The resource tree itself is sparse and can ‚Äúskip‚Äù levels in the component hierarchy, so there is no overhead from components that don‚Äôt interact with it. Prefixing a constructor parameter declaration with a visibility declares a field directly in the component and finally assigns the argument (whether extracted or plain) to it. (Lifted verbatim from Typescript.) starting_count: usize, declares a plain constructor parameter. All parameters are named, which is inspired by HTML attributes, and to a smaller extent by how properties can be assigned in Angular templates. The implementation is statically validated and should have next-to-no overhead thanks to the typed-builder crate, though there is some room for improvement in the implementation details (i.e. no easy repeatable parameters, and high complexity of optional arguments (which are distinct from optional parameters)). Next is the render parameter list. This list is used for transient values that are provided each time the component is rendered, but may flow into the generated VDOM by reference if they are annotated with the special &#39;bump lifetime. Placing a ? after its name makes the parameter optional. The outwards-visible type is unchanged, but internally, it is wrapped in an Option&amp;lt;_&amp;gt;. An alternative to optional parameters are default arguments, written as = expr in their respective parameter definition. These are evaluated for each call where the argument wasn‚Äôt specified and have access to preceding parameters. (Inspired by‚Ä¶ Python I think? The semantics are different.) A return type can be optionally specified after the render parameters, but generally this is automatic and a drop handle wrapping a VDOM node that can refer to other nodes in the bump allocator that was given to the render method by the app runtime.Next is the main original feature of Asteracea, a mixed-style component body. ‚ÄúMixed-style‚Äù has a dual meaning here: The body is translated into both a constructor (::new(‚Ä¶)) and a VDOM-builder (::render(self: Pin&amp;lt;&amp;amp;Self&amp;gt;, ‚Ä¶)). Each piece of plain Rust that appears in this body is quoted into either the one or the other, so distinct sets of local variables are present in each and self is only available in .render. The paradigm is mixed-declarative-imperative: You get painless state management like in React, with single statements that take care of both declaration and initialisation of local state. You can freely use (certain) flow control statements like for-loops without wrapping them in boilerplate. Some differences apply: For example, loops expected to generate a value from each iteration, but this value can be the empty node []. You can still use the normal versions inside a Rust-block-expression. This is a smooth mix: Control flow (generally) translates into stored expression state management, so it‚Äôs safe to declare more fields wherever, right where you need them. (There is no implicit cross-talk between loop iterations or branches.) I‚Äôll continue line by line again: &amp;lt;div is an opening tag. These can either be standard HTML elements as identifier (which statically validates them to some extent and enables context help (See screenshot below.)), or alternatively the element name can be written as strong literal (&quot;custom-element&quot;), which allows more flexibility at the expense of validation. To use an Asteracea-generated component as child, you would write &amp;lt;*Child, with an asterisk before the identifier. You can also write &amp;lt;{expr} to only render or transclude such a child component, without instantiating it. .class?={class}: This is an optional argument (in this case an optional attribute), only set if the value is Some(‚Ä¶) or true and fully absent if it is None or false. This also works on *Children, but only with Option&amp;lt;_&amp;gt;s. HTML attributes and render arguments are prefixed with a single . here. For HTML elements, the identifier can be replaced with a string literal like &quot;data-myData&quot; to skip validation. Child components may additionally accept constructor parameters prefixed with *. For example, the counter above could be placed inside a parent component as follows: &amp;lt;*Counter *starting_count={0}&amp;gt; Constructor argument expressions are placed in the surrounding constructor scope and in most cases run only once when the parent component is instantiated. However, any side-effects should ideally still be idempotent regardless, to make debugging easier. let self.count = AtomicUsize::new(starting_count); This is React‚Äôs useState, except that it can be placed anywhere. The Rust expression on the right is constructor-scoped, so it can see starting_count but not, for example, button_text. The field is statically-typed. The above is actually a shorthand for: let self.count: AtomicUsize = AtomicUsize::new(starting_count); I used a bit of macro-magic to make that possible, as there is unfortunately no true field type inference. Fields declared this way can also be published (Their visibility follows let but is normally the implicit one.), though in this case that‚Äôs not a good idea since setting it directly would not invalidate the rendered GUI state. The next line does string formatting: !&quot;format string&quot;(args) is the general pattern, though the implementation specifics are delegated to bumpalo. You can write !(arg) to imply the format string &quot;{}&quot;. &amp;lt;button - a nested HTML element, one of the recursion points of this grammar. You can also nest child components, and you can nest HTML elements and child components inside a container component to transclude them. (More on that later: Asteracea‚Äôs transclusion is a bit fancier than what e.g. Angular or React can do, closer to WPF‚Äôs in power.) The next line is just string formatting again, which brings us to: on bubble click = active Self::on_click Event handlers are currently the most shaky aspect of Asteracea and I‚Äôll likely have to rework some of their details a bit, so I‚Äôll be brief: Event bindings are on average allocation free (callback registry with drop notifications) and the use of modifiers (bubble vs. capture vs. nothing, and use of active after = to event.prevent_default()) is statically validated if the event is. (As usual, you can use a string literal for the event name to skip validation.) The handler can have a number of different signatures, and can also be written inline as currently fn (self, event) { ‚Ä¶ } (not a closure). Event bindings on child components are not yet supported, but will use uniform syntax with event subscriptions on HTML elements once available. Support for bubbling event bindings outside the HTML DOM is up in the air; personally I find good direct events to be cleaner, and for skipping layers there‚Äôs the DI system already. &amp;gt; closes an HTML element or child component without restating its name. /div&amp;gt; closes that HTML element while restating its name. This is validated statically and the element‚Äôs context help is available on this closing tag.Few, Composite Allocations(inspired by Rust‚Äôs async blocks)Asteracea relies very heavily on data inlining to reduce memory use and improve cache behaviour.Most Asteracea-components don‚Äôt allocate directly, and their use elsewhere also does not automatically incur an allocation, as child components are (non-generically) inlined into their parents.There are a few exceptions to this: box expressions explicitly heap-allocate the storage for their contents, and e.g. for loops are storage container expressions that manage storage instances on the heap. Conversely, simple branches like match (or if, which in Asteracea is direct syntactic sugar for the former) can use fully inlined storage either as enum or struct.As components must be pinned to be rendered, the asteracea::component! macro safely implements pin projections for the fields storing child component instances.(If you create branches with vastly different storage sizes, that does seem to get flagged by Clippy. You can then box one or more of the branches to dynamically use less memory.)Rich Tooling CompatibilityAsteracea preserves source code spans and assigns those of synthetic tokens based on fine-grained context. This means that most error messages and warnings are already very precise with just rust-analyzer.Additionally, there are custom messages for domain-specific errors, like in the following case:on bubble error = active fn (self, _) {} ~~~~~~ ~~~~~~ evaluation of constant value failedthe evaluated program panicked at ‚ÄòKeyword bubble is not valid for this event; the event does not bubble.‚Äô evaluation of constant value failedthe evaluated program panicked at ‚ÄòKeyword active is not valid for this event; the event is not cancellable.‚Äô(This isn‚Äôt perfect: Rustc‚Äôs spans are less accurate than rust-analyzer‚Äôs (but still useful) and I‚Äôd love to get rid of the evaluation of constant value failed, the evaluated program panicked at &#39;, &#39; parts entirely. It‚Äôs in my eyes at least close to a dedicated editor integration, though, and Error Lens is able to display the message inline with little clutter.)Span preservation also gives you access to some rust-analyzer quick fixes inside the macro, though not all of them currently work correctly. I‚Äôm not sure how much I can improve them with the current proc macro API on stable, so for now I‚Äôm biding my time before attempting higher levels of polish in this regard.Additionally, you can step-debug into components somewhat decently. (There is room for improvement here though, likely by adjusting the Spans for generated code some more.)Keyed Repetition(inspired by loops in Angular templates)It‚Äôs very easy to construct dynamic list displays using loops in the component body:asteracea::component! { ListVisual()( // Side-note: Supporting this kind of parameter type is pretty tricky. items: impl IntoIterator&amp;lt;Item = &amp;amp;&#39;_ SomeItem&amp;gt;, ) &amp;lt;ul for item in items { &amp;lt;li bind &amp;lt;*CaptureItem *item={item}&amp;gt; &amp;gt; } /ul&amp;gt;}This list is auto-keyed (which has a bit of overhead vs. specifying the key type manually (also possible), until type ‚Ä¶ = impl ‚Ä¶; becomes available), which means the storage contexts for its body are automatically reused, reordered, and reinitialised only as needed.There is a bit of an oddity here: The constructor parameter *item on *CaptureItem receives data originally from the render parameter items. This is possible because bind moves the constructor of its argument into the render scope (as Rust closure), running it once when first rendered.Stored loop body state is dropped when the loop runs again and that item is missing.(Key repetitions are fine, but it‚Äôs strictly the last ones for each key that are added or removed.)Un-keyed RepetitionYou can loop in the constructor of a component instead by writing *for. This is evaluated only once when the surrounding expression (usually the component) is initialised, has exactly the same semantics as a plain Rust loop (aside from generating items), and generates the VDOM a bit more efficiently than the render-scoped loops above.Transclusion and Parent/Container Parameters(inspired by transclusion in Angular and attached properties in WPF)My code calls these ‚Äúparent parameters‚Äù, but I‚Äôm not sure which term is better in practice.Take snippet example for instance:&amp;lt;*Router // I&#39;ll redo how the paths are specified. -&amp;gt;path={&quot;/div/*&quot;} &amp;lt;div&amp;gt; -&amp;gt;path={&quot;/span/*&quot;} &amp;lt;span&amp;gt;&amp;gt;Here, two child expressions are handed to the Router instance during rendering. (They are constructed eagerly with the expression that contains this code, but you can easily defer that in most cases. Here I haven‚Äôt done it because purely HTML expressions don‚Äôt need storage or construction.)This functions via closures, so while outer variables are visible, the Router can decide which branch to actually render here each GUI frame.The -&amp;gt;path argument is fully statically typed and validated against Router‚Äôs render method signature, and passed along by value with each child.Transclusion slots can be named and distinct slots can accept different sets of arguments. The child parameter slot on Router in this case is repeatable and anonymous. I haven‚Äôt yet implemented good syntactic sugar for declaring these, so that‚Äôs currently a bit cumbersome.A single non-repeating anonymous content parameter can currently be declared as .., and can also be pasted as .. in the component body. This is a placeholder and likely to change.Coloured Async and Named SlotsThere isn‚Äôt really much to say about these features, as they follow directly from Rust‚Äôs interpretation of coroutines and child transclusion via (named in general) render parameters.Asteracea components may be asynchronous and .awaited in asynchronous expressions, which may be the body of an asynchronous component or created by the async keyword.Slots can be named (I used lifetime labels here, since that results in nice syntax highlights.) and a slot can also be set up to accept an asynchronous expression.async fn future_text() -&amp;gt; String { &quot;Like a record!&quot;.to_string()}asteracea::component! { Spinner()() &quot;Spinning right &#39;round‚Ä¶&quot;}asteracea::component! { async Async()() let self.text: String = future_text().await; !&quot;{}&quot;(self.text)}asteracea::component! { Instant()() &amp;lt;*Suspense &#39;spinner: &amp;lt;*Spinner&amp;gt; &#39;ready: async &amp;lt;*Async.await&amp;gt; &amp;gt;}(That‚Äôs essentially a clone of React‚Äôs Suspense, just Rust-y.)The storage for both the Spinner and Async is managed by (and inlined into) Instant, so Suspense can be fairly¬π non-generic, as transclusion is largely type-erased.However, Suspense controls how the underlying Future is driven (holding onto a cancellation token and scheduling a small driver-Future using an injected ContentRuntime implementation) and takes care of invalidation (by cloning and passing along an optionally-injected Invalidator handle).Dependency Injection(inspired by Angular, but strictly at runtime)It‚Äôs quite easy to declare resource tokens for injection, here for example the ContentRuntime declaration in its entirety:// src/services/content_runtime.rsuse crate::include::async_::ContentFuture;use rhizome::sync::derive_dependency;/// A resource used by [`Suspense`](`crate::components::Suspense`) to schedule [`ContentFuture`]s.pub trait ContentRuntime { fn start_content_future(&amp;amp;self, content_future: ContentFuture);}derive_dependency!(dyn ContentRuntime);// Specific implementation:impl&amp;lt;F: Fn(ContentFuture)&amp;gt; ContentRuntime for F { fn start_content_future(&amp;amp;self, content_future: ContentFuture) { self(content_future) }}(Injection of concrete data-holding types is set up a bit differently.)As ContentRuntime in particular is blanket-implemented over certain closures, providing an implementation to your app is then as easy as writing:// Given to the root component manually, but otherwise managed implicitly.let root = Node::new(TypeId::of::&amp;lt;()&amp;gt;());&amp;lt;dyn ContentRuntime&amp;gt;::inject(root.as_ref(), |content_future| { // `ContentFuture` is `&#39;static + Unpin + Send + Future&amp;lt;Output = ()&amp;gt; + FusedFuture` and completely type-erased and semantically fire-and-forget, // and as such trivially compatible with practically every single Rust async runtime out there.});A container component‚Äôs dependency injection node is parent to that of transcluded children. This allows Invalidator-interception for memoisation, for example.As mentioned above, dependency injection into components is done by declaring a constructor parameters likedyn runtime: dyn ContentRuntime,but it‚Äôs also possible to not strictly require the runtime by making the parameter optional:dyn runtime?: dyn ContentRuntime,MemoisationBetween Invalidator injection, transclusion that flows the dependency context, and a drop-guarded VDOM, it‚Äôs relatively straightforward to implement a memoisation component usable like this:&amp;lt;*Memo // ‚Ä¶further content‚Ä¶&amp;gt;And if you need to externally invalidate the Memo, you could name the field it is stored in to call methods on it:&amp;lt;*Memo priv memo // ‚Ä¶further content‚Ä¶&amp;gt;// ‚Ä¶self.memo.invalidate();(My current memoisation component has a slightly different API, is on a feature branch, and is not in a clean shape. I‚Äôll likely optimise and clean it only after working on some other features first.)Sparse VDOM Drop GuardsThe VDOM tree itself can be trivially dropped, so double-buffering it with a rotating pair of bump allocators is very efficient.However, the memoisation component above must know when it‚Äôs safe to drop a cached version of the VDOM, without direct knowledge of the main allocators‚Äô unsafe rotation at the app root.Relying on a safety contract that prescribes an app lifecycle with repeating elements seemed error-prone, so instead Asteracea uses sparsely aggregated drop guard trees stored in the same bump allocators as the VDOM nodes.These may contain a type-erased drop notification (as well as the VDOM node they guard), but most importantly can be unsafely split into the notification and VDOM node.The component macro aggregates the former from child components, only pushing a pair into the allocator where collisions happen, and then composes them with the VDOM node it created to create a safe return value.If an error or unwind happens while these parts are split, the drop notification is sent and the macro guarantees that the formerly-guarded VDOM nodes are never accessed.Server-side Rendering and HydrationAs Asteracea is fundamentally platform-agnostic, it‚Äôs possible to run applications natively on a server without changes to the application code. (If you need different output, you can reconfigure aspects of an app through dependency injection, e.g. by not injecting a user credentials service or by injecting dummy async runtimes that never poll the Future‚Äôs.)lignin-html can render lignin VDOMs into HTML documents, and lignin-dom can read the DOM tree into a VDOM tree, effectively hydrating it in place on first diff.Element BindingsElement bindings function similarly to event subscriptions and give a component running client-side access to the DOM element instance, by notifying it of changes and asking it to clean up when removed from the rendered view.I haven‚Äôt really given this feature much thought yet, but it‚Äôs there and should be enough to host JavaScript components.Room for ModificationsThe lignin DOM update specification carves out some niches for uncontrolled modifications of the page structure, to make it easier for users to adjust the appearance of pages or add functionality using e.g. web extensions.With at least my differ, apps won‚Äôt interfere with extra child nodes in an element as long as they follow the app-managed ones, or extra attributes or extra event bindings. (There is no external notification in cases where a DOM element instance happens to be repurposed, though, so extensions must subscribe to DOM changes to stay in sync.)Additionally, the differ is at the same time resilient enough to detect inconsistencies with the tolerated DOM state and recreate parts of it more aggressively where needed.A Declarative Compile-Time Schema LibraryAsteracea‚Äôs knowledge of HTML is provided by the lignin-schema crate, the source code of which you can find here: lignin-schema/src/lib.rsThe macros encode information about elements, attributes and events into the Rust type system and attach meta data (documentation and deprecations) as attributes, while the asteracea::component! macro does not have this information and instead just emits validating const expressions and constructs the relevant type paths.The actual schema validation is then done only by the Rust compiler, which also makes it possible to have automatic in-editor completions for element names and for rust-analyzer to provide documentation on hover. (The macro could be more lenient to allow completions to work in more cases.) You may notice that one of the macro upper-cases all element names. I somewhat boldly assumed a differ might want to use Element.tagName inside an HTML document without doing a case-sensitive comparison here, but maybe lower-casing everything would be better in light of Brotli compression. I don‚Äôt think it really matters all that much when using a double-buffered VDOM, at least, since the renderer would only have to adjust casings once during hydration.Plain Extra ImplsAs the entirety of component‚Äôs state is stored in ‚Äújust fields‚Äù, it‚Äôs easy to extend a component‚Äôs API.For example, the following could be added to the counter component above‚Äôs module to give its parent access to the counter state:impl Counter { pub fn count(&amp;amp;self) -&amp;gt; usize { self.count.load(Ordering::Relaxed) } pub fn increment(&amp;amp;self) { self.count.fetch_add(1, Ordering::Relaxed); }}As long as the parent binds the instance to a name, like here‚Ä¶asteracea::component! { Parent()() &amp;lt;*Counter priv counter *starting_count={0} &amp;gt;}It can then call these as e.g. self.counter.count().Some methods may require a Pin&amp;lt;&amp;amp;Self&amp;gt;. For fields that require pinning, like child components, a matching pin projection method is also available. In this case, self.counter_pinned().count() would also work that way as long as self is at least a Pin&amp;lt;&amp;amp;Parent&amp;gt;.No-Effort InstrumentationYou only have to enable Asteracea‚Äôs &quot;tracing&quot; feature to automatically instrument all constructors and render methods with tracing spans and log all their arguments. (This uses auto-deref-specialisation internally, so you get meaningful argument logs depending on which traits are available on them, without having to worry about incompatibilities.) Please wrap any sensitive information you pass around in your program in a debug-opaque newtype to avoid accidental logging. The lignin-‚Ä¶ crates, once published to Crates.io in their instrumented version, similarly should provide only redacted logs by default, unless content logging is explicitly enabled via a feature.)You also get nice performance traces in the browser if you use tracing-wasm. I‚Äôd like to eventually write a proper debug interface and browser extension to inspect the app state, but for now that‚Äôs quite far off.One caveat here is that async constructors aren‚Äôt quite properly instrumented due to some difficulties with the tracing::instrument attribute macro. It seems my PR in this regard might land soon though, at which point adjusting Asteracea to use that macro again should be quick and easy.There is also a potential parameter name collision with this feature that still needs to be solved, though ideally upstream.Odd FeaturesI‚Äôll probably scrap or evolve these from their current form, since they have usability drawbacks.Thread Safety InferenceAsteracea components (by default only in the same crate) can transitively infer the thread-safety tag of their resulting VDOM, entirely at compile time.At least in theory that, since there seem to be frequent edge cases where this trips up type inference somewhat. (The core hack is deanonymization of opaque (impl ‚Ä¶) return types through the auto trait side channel. You can find more information on that in the lignin::auto_safety docs.)I‚Äôm considering letting all component-generated VDOM be only !Sync by default, while keeping the option to safely state otherwise. This would remove those edge cases (mostly dependency loops) where inference suddenly fails, and would probably improve build times a little.Native GUI TargetsThere‚Äôs nothing really stopping you from rendering a lignin VDOM in terms of a native GUI framework, however this currently maybe isn‚Äôt the best fit depending on the framework in question.As Asteracea doesn‚Äôt really take care of event bubbling and assumes all standard elements are present, a fairly thick glue layer may be required to make this work nicely.I made a quick proof of concept in this space, and it works well with low requirements, but this is not something I plan to pursue immediately.Future WorkThere are a few open points that I still haven‚Äôt figured out:More syntax/syntax revisionsI‚Äôd like to add plain let (and *let) bindings directly to the body grammar, and in exchange remove the with {} blocks that paste Rust code into the constructor or render function.Flow control expressions should consistently use {} around their branches, while embedded Rust expressions should be more explicit than that.There are also some flow control expressions or expression variants that aren‚Äôt implemented yet.Attribute/argument syntax is a bit too verbose. I should be able to make the {} optional (though expressions with . will have to be parenthesised, still).An efficient render-contextThis would make it easier to propagate transient state along the component tree, with the option to later remove contents from it without re-creating the affected components.rhizome is not suitable for this, as it unconditionally allocates at least twice for each new populated resource scope and is inflexible regarding removals.A mockable asynchronous HTTP clientThis should be a trait in Asteracea‚Äôs standard library, to be used as injected dependency.(I‚Äôll likely clone hyper‚Äôs API for this on some level, but I haven‚Äôt really looked into this.)OptimisationAsteracea feels fast as-is, but there‚Äôs likely a bunch of potential in giving the crates I proof-of-concept‚Äôd as dependencies any optimisation pass at all.(I‚Äôve constructed the public crate APIs with efficiency in mind already, but I took some shortcuts here and there as far as the internals go. This is my unpaid hobbyist project, after all, so I have to cut corners somewhere ;-) )A Remnant API and implementationThere‚Äôs currently only a placeholder VDOM node variant.‚ÄúRemnants‚Äù (as I call them) are (to be) lingering pieces of the DOM that are preserved for a while even after they are removed from the VDOM, existing outside the usual app update flow. This makes them useful for animating-out nodes.Raw HTML PastingI haven‚Äôt added this to the VDOM since I personally don‚Äôt need it, but someone is going to want that feature before long.Data Binding(This is a wishlist feature that I haven‚Äôt gotten around to seriously working on yet. I only have vague ideas how to implement this.)Declaring Cells and other interior-mutable fields seems okay when using the shorthand syntax, but I‚Äôd like to simplify how they are updated in high-level components. Take the following currently not functional syntax sketch for example (inspired by Angular):asteracea::component! { DataBinding()() let self.data = RefCell::new(&quot;&quot;.to_string()); &amp;lt;*TextField .(value)={&amp;amp;self.data}&amp;gt;&amp;lt;br&amp;gt; &quot;The text is currently: &quot; !(self.data.borrow())}The details of the binding implementation can be provided by a trait, similarly to how optional arguments work already. This way, you could use a plain Cell for types that are Copy.It should be possible to reuse the callback registry mechanism that DOM event subscriptions use here, with the control component (TextField) storing a CallbackReference it receives as render parameter. lignin‚Äôs CallbackRefs are opaque weak handles (meaning they contain only a number and are Copy), so there‚Äôs little overhead to just replacing them on render.Such data bindings should also automatically invalidate the current component using an implied priv dyn __Asteracea__invalidator? = dyn ::asteracea::services::Invalidator added to the constructor parameter list.Planned FeaturesThe following are in theory solved problems, but implementing each solution would either be a fairly large amount of work for me right now or is lower-priority for other reasons.A component traitComponents are currently duck-typed, with a mix of attached methods and type inference hacks to instantiate the appropriate arguments builders.It should be possible to at least partially implement a trait for the interface instead, which would make component implementations not using the component! macro a bit easier.Repeat parametersSimilarly to optional parameters with ?, the following declarations should also be valid in the parameter lists:zero_or_more*: Type, // Vec&amp;lt;_&amp;gt;?one_or_more+: Type, // `Vec1&amp;lt;_&amp;gt;` or similaroptionally_one_or_more+?: Type, // `Option&amp;lt;Vec1&amp;lt;_&amp;gt;&amp;gt;`optionally_zero_or_more*?: Type, // largely just for completeness, `Option&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;`Then, on the caller side, it should be possible to repeatedly add arguments for these parameters (or transcluded children to the same variadic slot!) and/or to spread an IntoIter&amp;lt;Item = Type&amp;gt; into them.I started work on the necessary infrastructure quite a while ago, but so far haven‚Äôt found the time and peace of mind to complete this pull request.Better missing argument errors on child componentsNow that const expression panics are available and appear as compile-time errors, it should be fairly straightforward to validate argument presence that way (using the same kind of method chaining as the actual builder, but without argument values). The raised panic would then appear as error on the child component‚Äôs identifier or reference-expression, and could clearly list which fields are still missing.(Ideally this would replace the deprecation message and errors from typed-builder, but I‚Äôm not entirely certain how feasible that is. I think it will be possible once inline const { ‚Ä¶ } blocks are available, as then this block could provide the initial builder and, on error, result in a somewhat more lenient vacant dummy type instead.)Other IssuesFor various additional rough edges, please see Asteracea‚Äôs issues on GitHub.How to support this project or me personallyThere are two good ways for individuals to contribute to Asteracea‚Äôs development right now: You can send me feedback or questions If a feature turns out to be unclear, that means I either have to add better documentation for it or revise the feature itself. (I‚Äôm writing a guide book in parallel to development, deployed automatically from and tested against develop. The ‚ÄúIntroduction‚Äù page is a bit outdated; I‚Äôll get around to updating it eventually.) You can contribute code to related repositories The main Asteracea repository is too in flux right now to efficiently take contributions, but there are a number of dependencies that have a stable API but are internally not optimised well or incomplete. These crates, for example tiptoe, also mostly have a generic API rather than one designed only for Asteracea, so they may be worth a look for your own projects too. I‚Äôm not currently in a position where I could invest small monetary contributions efficiently to further Asteracea‚Äôs development. (The most direct effect would be letting me eat better and showing me that there‚Äôs tangible interest in this side project of mine, which may lead to me spending more time on it and coding a bit faster.)If you‚Äôd like to tip me regardless, for example for this blog post here, I now have Ko-fi and GitHub Sponsors profiles. If you happen to use RPG Maker MV, you can also have a look at my Itch.io page where I published some tools and plugins.For anything else, you can reach me at the email address available from the sidebar.Project repositories ¬† ¬† Asteracea Component macro DSL and beginnings of a standard library. lignin VDOM and callbacks. lignin-schema Declarative (superficial) HTML, SVG and MathML schema, encoded in Rust‚Äôs type system.The name is something of a hold-over; there is no dependency relationship with lignin anymore. lignin-html (Partially-validating) VDOM-to-HTML renderer. lignin-dom DOM hydration and diffing. rhizome A lightweight runtime dependency injection container/reference-counted context tree. fruit-salad Trait object downcasts, among other features. Used by rhizome. pinus Value-pinning B-tree maps that can be added to through shared references. Used by rhizome. tiptoe Intrusively reference-counting smart pointers. Used by rhizome. Additional repositories ¬† ¬† lignin-azul, and asteracea-native-windows-gui and lignin-native-windows-gui Sketches/proofs of concept for using Asteracea to implement native GUIs. In practice, it might be a good idea to make lignin‚Äôs VDOM nodes generic over the element type type, to allow switching the &amp;amp;strs for an enum. an-asteracea-app WIP single page application demo project. Very rough, somewhat outdated, but shows the rotating VDOM buffers. Footnotes¬π SuspenseThis is the source code for the suspense component in its entirety:use crate::{ include::{ async_::{AsyncContent, ContentSubscription, Synchronized}, render_callback::RenderOnce, }, services::{ContentRuntime, Invalidator}, __::Built,};use lignin::{Guard, ThreadSafety};use std::cell::UnsafeCell;use typed_builder::TypedBuilder;#[derive(TypedBuilder)]pub struct NoParentParameters {}impl Built for NoParentParameters { type Builder = NoParentParametersBuilder&amp;lt;()&amp;gt;; fn builder() -&amp;gt; Self::Builder { Self::builder() }}asteracea::component! { /// Renders `&#39;spinner` unless `&#39;ready` has finished construction. /// /// `&#39;ready`&#39;s construction is scheduled automatically. pub Suspense( priv dyn runtime: dyn ContentRuntime, priv dyn invalidator?: dyn Invalidator, )&amp;lt;S: &#39;bump + ThreadSafety&amp;gt;( // Clearly missing syntactic sugar for these transclusion slots: spinner: (NoParentParameters, Box&amp;lt;RenderOnce&amp;lt;&#39;_, &#39;bump, S&amp;gt;&amp;gt;), mut ready: (NoParentParameters, AsyncContent&amp;lt;&#39;_, RenderOnce&amp;lt;&#39;_, &#39;bump, S&amp;gt;&amp;gt;), ) -&amp;gt; Guard::&amp;lt;&#39;bump, S&amp;gt; // Cancels on drop via strong/weak `Arc` reference counting. let self.subscription = UnsafeCell::&amp;lt;Option&amp;lt;ContentSubscription&amp;gt;&amp;gt;::new(None); { match ready.1.synchronize(unsafe{&amp;amp;mut *self.subscription.get()}) { Synchronized::Unchanged =&amp;gt; (), Synchronized::Reset(future) =&amp;gt; self.runtime.start_content_future(future, self.invalidator.clone()), } ready.1.render(bump).unwrap_or_else(|| (spinner.1)(bump))? }}As you can see, it‚Äôs quite concise already, and only generic over the thread-safety of the resulting VDOM.The part of the body wrapped in {} is plain Rust, as there is not much state management to be done here and the transcluded content already generates the finished drop-guarded VDOM handles. I plan to make the syntax for Rust blocks more explicit as I continue to move to brace-bodied flow control expressions." }, { "title": "Moving", "url": "/posts/Moving/", "categories": "Blogging", "tags": "Hashnode, Jekyll, ethics", "date": "2022-01-06 19:31:17 +0100", "snippet": "Hashnode unfortunately has been hard at work pushing their web3 tag, as well as various blockchain and NFT hackathons.This¬πiscompletely¬≤untenableforvariousreasons,which means I‚Äôm moving my blog to disassociate from that company as much as I can.¬π strong but appropriate language¬≤ a longer post explaining most of the scam(s) involved Side-note: The links above aren‚Äôt comprehensive regarding my problems with the web3/blockchain/NFT field.I also think engaging in them as a technologist is an absolutely disgusting breach of work ethics in multiple ways. If you‚Äôre thinking of trying to convince me, please leave.I do not want to waste energy talking to you, I would just block you everywhere, and I would never do business with you. Anyway:For now I‚Äôm using a fork of Chirpy Jekyll Themeüíé, but I‚Äôd like to eventually move to Asteracea-based templating üåºü¶Ä.I‚Äôll update this post with the changes I made to the theme to not break incoming links. Please consider filing a bug report if anything is broken! My theme customisations are improvised, so I‚Äôd greatly appreciate these reports. For general and technical issues: theme fork issue tracker(Do not file these on the upstream theme! Chances are it‚Äôs purely my fault.) Broken posts, images and other content-bugs: individual blog repository issue tracker Thank you!Running the Blog LocallyWhile this blog is deployed automatically on GitHub Pages when I push a new revision to the main branch,it‚Äôs still much faster to run it locally to edit more-or-less live. (This is actually more convenient than on Hashnode,as I can more easily see the markdown source and rendered page side by side.)Run bundle to initialise the lockfile for your blog after running the init script as per the theme instructions. Additionally run bundle lock --add-platform x86_64-linux to make the lockfile compatible with the automatic deployment Action.You should commit this lockfile to Git also, to make sure the site always builds reliably.Afterwards, you can run a live-editable version of the site like this:bundle exec jekyll sIt will tell you the local address to open.It can take a moment for file updates to be reflected, even after ‚Äú‚Ä¶done‚Äù first appears.If you don‚Äôt see your changes, refresh the page again or set up automatic refresh in your browser.Side-note: You may be able to speed up rebuilds on changes by adding the --incremental flag.I‚Äôm not sure if there was actually a speed-up though, as the timings are all over the place on my computer.Updating dependenciesApparently you can do this by running:bundle updatePorting PostsPosts seem to only appear if their file name follows the YYYY-MM-DD-Title.md schema, so to start porting,you can simply drop the *.md files from your Hashnode Git backup into the _posts/ folder in your blog repository root.Post metadata and redirectsI mostly followed these instructionsto set up redirects, with some small adjustments to instead show a message within the normal site layout and redirect only after a short delay.This means I only need to update the start of each markdown file as follows:## Building non-containers with Docker and VS Code&amp;lt;!-- ‚Ä¶ --&amp;gt;---title: Building non-containers with Docker and VS Codedate: 2020-02-27 14:48:00 +0100categories: [Build Automation]tags: [VS Code, Docker]redirects: # current Hashnode URL scheme - /building-non-containers-with-docker-and-vs-code # legacy URL, only necessary if your post existed before you switched it over - /building-non-containers-with-docker-and-vs-code-ck74szgf807g9d9s1s6o88c8f---&amp;lt;!-- ‚Ä¶ --&amp;gt;You can find the precise publication time of Hashnode posts by hovering over time date here: I guessed +0100 for the time zone, since that was mine at that time. This could be wrong.Rehosting imagesYou will have to rehost your images currently stored on the Hashnode CDN.They currently still work even if you keep the old URL (before shutting down your Hashnode blog entirely, at least), but that may change in the future.It‚Äôs definitely better to make a local copy in general, too, since they aren‚Äôt included in the automatic backup archive. Side-note: If you use images or other non-text files with a file extension other than .png, .jpg or .ico, make sure to adjust the .gitattributes file first!If you don‚Äôt do this, other image files may break in a way that‚Äôs very difficult to recover from.There doesn‚Äôt really seem to be a specific place to put them, so I just created a folder at /assets/img/posts/&amp;lt;same name as the md file&amp;gt;/ and dropped them in there. You can them update the post‚Äôs markdown as follows:- ![Code_JVjZIdealV.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1582800675358/UHG9unECP8.png) + ![[Select the build task to run] &amp;gt; Build schichler-dev](/assets/img/posts/2020-02-27-Building non containers with Docker and VS Code/run task Build schichler-dev.png)(I chose to also update the image‚Äôs alt text, within the leading ![‚Ä¶], to better support readers using screen reader software.)There‚Äôs a context menu entry to copy the relative path of a(n image) file in Code‚Äôs file picker.Make sure to prepend / if you are using the same theme as me, and to replace \\ with / on Windows.Markdown adjustmentThe markdown parser on Hashnode is non-standard (as far as a standard exists at all for markdown in practice), so parts of your post may render in unexpected way.For example, I had to made the following adjustment: &amp;gt; In this post:+ &amp;gt; &amp;gt; - example configuration &amp;gt; - command line breakdowns &amp;gt; - links to relevant documentation+ - - -Adding the newline between the title and list wasn‚Äôt strictly necessary, but fixed a warning given by markdownlint.Adding a line between the end of the quote block and the divider was necessary.MentionsHashnode allows mentions like this:@[Display Name](@handle)You can find all instances of this by searching globally for ](@.I had used only three mentions in the blog texts proper, so I replaced their target with the full URL manually instead of writing a plugin.EmbedsThe following syntax shows a preview card on Hashnode, but is non-standard and breaks in the move:%[https://blog.schichler.dev/intrusive-smart-pointers-heap-only-types-ckvzj2thw0caoz2s1gpmi1xm8]I tried to bodge a plugin for this, but failed.(I don‚Äôt know nearly enough efficiently Ruby to figure out how requiring link_preview breaks things elsewhere, and link_preview_generator depends on conflicting nokogiri which means bundler gets stuck on Windows.)For now the plugin just outputs warnings like this:Warning: Replacing rich preview `%[https://blog.schichler.dev/intrusive-smart-pointers-heap-only-types-ckvzj2thw0caoz2s1gpmi1xm8]` in C:/Users/Tamme/Documents/Projekte/blog.schichler.dev/_posts/2021-11-24-Pinning in plain English.md with plain link `&amp;lt;https://blog.schichler.dev/intrusive-smart-pointers-heap-only-types-ckvzj2thw0caoz2s1gpmi1xm8&amp;gt;`.Replace the embed with a proper link to fix it.Heading linksHeadings‚Äô id=s are prefixed with heading- on hashnode but not in this blog theme.You can quickly globally find-and-replace #heading- with #, as long as the former doesn‚Äôt appear in your posts‚Äô text.RSS FeedAs Hashnode uses /rss.xml but Chirpy only comes with /feed.xml (Atom), I created a new RSS feed template and included that with my theme fork.This means previous feed reader subscriptions won‚Äôt break, even though the HTML pages currently still only present the Atom feed behind the icon in the bottom left.Both feeds should have the same content (except for some meta data). I also removed the five-most-recent post limit from the Atom feed." }, { "title": "Cheese-olive dish", "url": "/posts/Cheese-olive-dish/", "categories": "Cooking, Salads", "tags": "cheese, olives, chili, pepper", "date": "2021-12-15 18:48:00 +0100", "snippet": " One of these days I‚Äôll get a light box, but today is not that day.I don‚Äôt only write software, so there will occasionally be other topics mixed in here.Today‚Äôs is a super fast snack recipe that‚Äôs probably not super healthy (üßÇ),but can get rid of sleepiness quite quickly.Cheese-olive dishA wake-up snack. Difficulty Time Salty üüÇ (very easy) 2-3 min. at most Yes Ingredients (1 serving) Ingredient Amount Notes semi-hard brined cheese 180g Sirene is the closest in English, I think.This one is made from cow‚Äôs milk. pitted green olives ~65g? Don‚Äôt wash off the salt. chili flakes just a few e.g. from pizza delivery,because they always add too many if separate ground black pepper a little ¬† Utensils A sharp knife and small cutting board An appetiser bowlStepsCut the cheese into ~1.5cm cuboids and pile it and the olives up in the appetiser bowl.Add a small amount of chili flakes just on top.Finish with a bit of pepper to taste.CommentsI don‚Äôt drink coffee, so to wake myself up if I‚Äôm really half-asleep, I like to go with (fresh or spicy preserved) produce.The salt and tanginess do about equal work here, where the latter is concentrated in the upper layers and the lower ones will be a little more watery due to the olives‚Äô and cheese‚Äôs moisture.You‚Äôll likely want to serve this unstirred with a small salad fork, and enough water nearby due to the high amount of salt in this dish. The effect is probably somewhat subjective too. I‚Äôm sensitive to tanginess, especially to pepper, so I didn‚Äôt have to add much in terms of spices. (I did add a tiny bit of salt extra, but I don‚Äôt think it made a noticeable difference.)I don‚Äôt technically eat this regularly as such, since I don‚Äôt need this every day and rarely ever improvise the same dish twice if I do (beyond the general category), but this one turned out well and had the intended effect, so I‚Äôm sharing it here. You can substitute the olives with diced bell pepper or cucumber if you‚Äôd like a milder version." }, { "title": "Pinning in plain English", "url": "/posts/Pinning-in-plain-English/", "categories": "Rust, Pinning", "tags": "patterns, api, guide", "date": "2021-11-24 17:10:00 +0100", "snippet": " A mirrored bell pepper is still clearly the same fruit, but the mirror image, if physically placed outside the mirror, would largely only be compatible with a fundamentally different biology, as many of its more complex molecules are chiral. It was fresh and refreshing. Pinning in Rust is a powerful and very convenient pattern that is, in my eyes, not supported well enough in the wider ecosystem.A common sentiment is that it‚Äôs hard to understand and that the pin module documentation is confusing. (Personally, I think it works well as reference to answer questions about edge cases, but it‚Äôs a dense read and not necessarily a good intro text.)This post is my attempt to make the feature more approachable, to hopefully inspire more developers to make their crates pinning-aware where that would be helpful.License and TranslationsSee past the end of this post. In short, this post as a whole is licensed under CC BY-NC-SA 2.0 except for code citations explicitly marked as such. Code snippets and blocks that are not marked as citations are also licensed under CC0 1.0.Community translations: ChineseAlright, on to the actual content!Note that I‚Äôve added links to (mostly) the Rust documentation in various places.These are ‚Äúfurther reading‚Äù, so I recommend reading this post entirely before looking into them. They‚Äôll (hopefully) be much easier to understand that way around.The ProblemIn Rust, any instance is considered trivially movable as long as its size is known at compile-time, which means that anyone who owns or has an &amp;amp;mut (a plain exclusive reference) to an instance can copy its unstructured data (i.e. its directly contained bytes) to a different memory address, and can then expect nothing to break when they reuse the old location otherwise or use the moved instance.Unlike in C# or JavaScript, this matters:References, pointers and addresses can be fairly readily converted between each other, and addresses (and to some extent pointers) are plain numbers that can be used in offset calculations.This makes it possible to, for example, create very efficient generic collections, as they can always store instances ‚Äúby-value‚Äù in the same allocation. If they‚Äôve run out of space to add a new item, they implicitly reallocate their storage, possibly moving their contents to a new location in memory.However, unlike in C++(1,2,3,4), there is no built-in mechanism to update pointers and addresses not known directly to the owner of an instance, or to prevent moves completely for a specific type: You can‚Äôt overload or delete the plain assignment operator =, and there is no concept of a move or copy constructor that could be called when an instance is moved implicitly.Rust-style references (&amp;amp; or &amp;amp;mut) are lightweight pointers with some aliasing restrictions that are always valid¬π and can‚Äôt be automatically updated from elsewhere, which in turn rules out reallocation of their target entirely during these borrows (but code with access to the exclusive &amp;amp;mut T can still swap instances freely).(¬π more specifically: References are always guaranteed to be dereferenceable, which allows the compiler to load and cache their pointed-to values early in many cases. C++ makes the same dereferenceability guarantee, but allows mutable aliasing by default.)All this together makes it tricky to write a memory-safe API that relies on the known location of an instance between calls into it, as taking continuous possession of it through ownership or a borrow would be inflexible and often inconvenient, and using an indirect handle would be too inefficient for many low-level components.Pinning TL;DR (simplified)Instead, Rust opts to explicitly change the visible type of a reference (and with that the API) to prevent accidental moves outside of unsafe code.While there are some exceptions to this, the default assertion of pinning is that ‚ÄúIf a Pin&amp;lt;&amp;amp;T&amp;gt; is accessible, then that instance of T will be available at that address until dropped.‚ÄùIt‚Äôs possible to weaken this somewhat but, aside from when T: Unpin, only by using unsafe in some way.Whenever a type implements Unpin, pinning its instances is meaningless however.For simplicity, types of pinned values (in this post: T) are implied to be !Unpin for the rest of this post, unless otherwise noted. This means some sentences won‚Äôt be true if you, for example, try to pin an f64 or a struct where all of its members are Unpin. Please keep this in mind while reading on.‚Äúpin‚Äù vs. ‚Äúpinned‚ÄùWhenever pinning happens in Rust, there are two components involved: A ‚Äúpin‚Äù type that asserts ‚Äúthe value can‚Äôt be moved (by safe Rust)‚Äù. This is often called a ‚Äúpinning pointer‚Äù. Pins are very often Unpin, but this isn‚Äôt relevant to their function.Instead, this rule is enforced only through API constraints of the pin. A pinned value, which can‚Äôt be moved by the consumer of an API. This is always a specific value, not all members of a type in general, as ‚Äúpinned‚Äù is not an inherent property of any type. Pins are often compoundsFor example, look at the signature of Box::pin:// Citation.pub fn pin(x: T) -&amp;gt; Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; { ‚Ä¶ }This function pins the value x of type T behind a pinning smart pointer of type Pin&amp;lt;Box&amp;lt;_&amp;gt;&amp;gt;.Think of Pin&amp;lt;Box&amp;lt;_&amp;gt;&amp;gt; as ‚Äúpinning Box‚Äù, and not as ‚ÄúBox inside a Pin‚Äù. Pin is not a container that the Box can be safely taken out of (unless T: Unpin).Side note: A plain Pin&amp;lt;Box&amp;lt;_&amp;gt;&amp;gt; is pinning but not pinned.In fact, Pin&amp;lt;Box&amp;lt;_&amp;gt;&amp;gt; is always Unpin (because Box&amp;lt;_&amp;gt; is always Unpin) and as such can not be meaningfully pinned by itself.This, including Unpin on the pin, is the same for all standard smart pointers and Rust references: Rust English Pin&amp;lt;Box&amp;lt;_&amp;gt;&amp;gt; ‚Äúpinning Box‚Äù Pin&amp;lt;Rc&amp;lt;_&amp;gt;&amp;gt; ‚Äúpinning Rc‚Äù Pin&amp;lt;Arc&amp;lt;_&amp;gt;&amp;gt; ‚Äúpinning Arc‚Äù Pin&amp;lt;&amp;amp;_&amp;gt; ‚Äúpinning (shared) reference‚Äù Pin&amp;lt;&amp;amp;mut _&amp;gt; ‚Äúpinning (exclusive) reference‚Äù I often shorten ‚Äúpinning Box‚Äù to ‚ÄúPin-Box‚Äù for myself when reading silently, and you should be understood when saying it out loud like that too.Unpin is an auto traitVery few types in Rust are actually !Unpin. As Unpin is an auto trait, it is implemented for all composed types (structs, enums and unions) whose members are Unpin already. It‚Äôs auto-implemented for nearly all built-in types and implemented explicitly also for pointers! This means that pointer wrappers like NonNull are also Unpin!In fact, the only type that is explicitly !Unpin as of stable Rust 1.56, including in custom crates, is core::marker::PhantomPinned, a marker you can use as member type to make your custom type !Unpin.You can see the full list of (non-)implementors here: Unpin#implementorsValues (mostly) don‚Äôt start out pinnedEven for T where T is not Unpin, a plain instance of T on the stack or accessible through a plain &amp;amp;mut T is not yet pinned. This also means it could be discarded without running its destructor, by calling mem::forget with it as parameter for example.An instance of T only becomes pinned when passed to a function like Box::pin that makes these guarantees (and ideally exposes Pin&amp;lt;&amp;amp;T&amp;gt; somehow, as necessary).Function of Pin&amp;lt;_&amp;gt;The only differences between Box&amp;lt;T&amp;gt; and Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; are that: Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; never exposes &amp;amp;mut T or a plain T, so moving the value elsewhere is impossible. Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; exposes Pin&amp;lt;&amp;amp;T&amp;gt; and Pin&amp;lt;&amp;amp;mut T&amp;gt;. This is called ‚Äúpin projection‚Äù (towards the stored value). Getting access to these pinning references lets you call methods on the value that require self: Pin&amp;lt;&amp;amp;Self&amp;gt; or self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, and also associated functions with similar argument types. The plain &amp;amp;T value reference is accessible like before, and can also be found as such by dereferencing Pin&amp;lt;&amp;amp;T&amp;gt;, regardless of whether T is Unpin.All smart pointers and references that are Deref&amp;lt;Target = T&amp;gt; (and optionally, for mutable access, DerefMut) function exactly like this when pinning.In order to keep the rest of the post easy to read:Definitions (valid in this post only): Shorthand implied constraint English T not T: Unpin ‚Äú[arbitrary] type‚Äù / ‚Äú[arbitrary] value‚Äù a pinned T not T: Unpin ‚Äúa pinned value‚Äù P P: Deref&amp;lt;Target = T&amp;gt;,optionally P: DerefMut ‚Äúpointer‚Äù Pin&amp;lt;P&amp;gt; P: Deref&amp;lt;Target = T&amp;gt;,optionally P: DerefMut ‚Äúpinning pointer‚Äù Pinning is a compile-time-only conceptPin&amp;lt;P&amp;gt; is a #[repr(transparent)] wrapper around its single member, a private field with type P.In other words:Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; (for example) has the exact same runtime representation as Box&amp;lt;T&amp;gt;.Since Box&amp;lt;T&amp;gt; in turn has the same runtime representation as its derived &amp;amp;T, dereferencing Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; to arrive at &amp;amp;T is an identity function that returns the exact same value it started out from, which means (but only with optimisations!) no runtime operation is necessary at all.Converting a pointer or container into its pinning version is an equally free action.This is possible because moves in Rust are already pretty explicit once references are involved: The underlying assignment maybe be hidden inside another method, but there is no system that will move heap instances around without being told to do so (unlike for example in C#, where pinning is a runtime operation integrated into the GC API.)The only exception to this, where a &amp;amp;-referenced instance‚Äôs copy can appear with a new address implicitly, are types that are Copy. This trait isn‚Äôt auto, which means it must be derived explicitly for each type for which implicit trivial copies should be available.(Side-note: Don‚Äôt implement Copy on types where identity matters at all. Deriving Clone is usually enough.Copy is largely convenience for immutable instances that you want to pass by value a lot, so for example Cell does not implement it even if the underlying type does.)Pinning is a matter of perspectiveA value becomes pinned by making it impossible for safe Rust to move the instance or free its memory without dropping it first. (A pin giving safe Rust access to Pin&amp;lt;&amp;amp;T&amp;gt; or Pin&amp;lt;&amp;amp;mut T&amp;gt; asserts this formally, especially towards T‚Äôs unrelated implementation.)However, as the type of the pinned instance itself does not change, it can remain visible ‚Äúunpinned‚Äù inside the module that implements a pin in the first place.Pin&amp;lt;_&amp;gt; hides the normal mutable API only through encapsulation, but can‚Äôt erase it entirely.This is especially true for pins with interior mutability or composed of non-pinning fields, since they will normally share much of their implementation between the non-pinning and pinning API.Safe code inside such modules will (currently) often handle &amp;amp;mut T while a derived Pin&amp;lt;&amp;amp;T&amp;gt; could have been presented outwards before, and extra care must be taken to avoid unsound moves in that case.This may change in the future as more pinning pointers and collections become available and if Rust makes it easier to add methods to custom types wrapped in Pin&amp;lt;_&amp;gt;.Collections can pinThis is most obvious with Box&amp;lt;T&amp;gt; or Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; where the Box acts as 1-item collection of T. The same can be said about these types with ‚ÄúArc‚Äù and ‚ÄúRc‚Äù instead of ‚ÄúBox‚Äù.As such, it makes sense to also pay attention to C where C is a collection of items of type T.It‚Äôs likewise possible to use Pin to create a new type Pin&amp;lt;C&amp;gt; that behaves similarly to how a pinning smart pointer would, by giving out neither &amp;amp;mut T or T.Definitions (valid in this post only): Shorthand implied constraint English C owns instances of type T ‚Äúcollection‚Äù Pin&amp;lt;C&amp;gt; owns instances of type T ‚Äúpinning collection‚Äù (The standard library doesn‚Äôt have many utilities for this, as general collections are much more diverse than smart pointers. If you decide to write a pinning-aware collection, you will have to implement much of the API yourself and, as of Rust 1.56, may have to provide extension methods through traits to make calling it seamless.)A collection C ‚Äúcan pin‚Äù if it allows some projection from its pinned form (&amp;amp;Pin&amp;lt;C&amp;gt; or &amp;amp;mut Pin&amp;lt;C&amp;gt;) to Pin&amp;lt;&amp;amp;T&amp;gt; and optionally to Pin&amp;lt;&amp;amp;mut T&amp;gt;.A collection may also be inherently pinning, in which case it will act like Pin&amp;lt;C&amp;gt; without Pin appearing in the type. We won‚Äôt look at this kind of collection directly here.Pin&amp;lt;P&amp;gt; vs. Pin&amp;lt;C&amp;gt; vs. THow plain (non-pinning) pointers and collections behave should be clear enough, so I‚Äôll only compare how their and T‚Äôs API tend to differ when they are pinning or pinned: ¬† Pin&amp;lt;P&amp;gt; Pin&amp;lt;C&amp;gt; T behind Pin&amp;lt;&amp;amp;T&amp;gt; or Pin&amp;lt;&amp;amp;mut T&amp;gt; English ‚Äúpinning pointer‚Äù ‚Äúpinning collection‚Äù ‚Äúpinned value‚Äù : Unpin nearly always very often rarely in practice, as pinning with T: Unpin is meaningless. APIs accessiblevs. without pinning Access to Pin&amp;lt;&amp;amp;T&amp;gt;and optionally Pin&amp;lt;&amp;amp;mut T&amp;gt; varies,but often similar to Pin&amp;lt;P&amp;gt; Functions that require Pin&amp;lt;&amp;amp;T&amp;gt; or Pin&amp;lt;&amp;amp;mut T&amp;gt; APIs inaccessibleafter pinning Access to &amp;amp;mut T,unwrapping T varies, but usually:Access to &amp;amp;mut T, removing T,anything that would reallocate T Functions that require &amp;amp;mut T Unchanged APIs(examples) Access to &amp;amp;T Access to &amp;amp;T,dropping T in place Functions that require &amp;amp;T : Clone usually possiblywhere T: Clone¬π varies ¬π If implemented that way, then pub fn clone_unpinning(this: &amp;amp;Pin&amp;lt;Self&amp;gt;) -&amp;gt; Self { ‚Ä¶ } can also be implemented. However, if T: Clone, then it‚Äôs likely that T is also Unpin, which makes pinning pretty much useless.See the end of this post for a more useful implementation that can clone meaningfully pinned instances also.Which functions require Pin&amp;lt;&amp;amp;T&amp;gt;?How Pin&amp;lt;&amp;amp;T&amp;gt; and Pin&amp;lt;&amp;amp;mut T&amp;gt; are used varies, but there are three broad categories most cases fall into:Avoiding reference-countingIf smart pointers to an instance are copied often but accessed rarely, and references cannot be used because their lifetime can‚Äôt be constrained statically, then it makes sense to shift the runtime cost from cloning the pointers into a validity check on access instead. The smart pointers are replaced by copiable handles, in this case.How do the handles know when their target has disappeared? Pinning a T asserts that &amp;lt;T as Drop&amp;gt;::drop will run for that particular instance, so there will be an opportunity to notify a longer-lived registry.This also enables use cases where the handles cannot be dropped explicitly, like if they are stored directly by an arena allocator like bumpalo. You can see an example of this pattern in my crate lignin, which supports (V)DOM callbacks this way.Embedding externally-managed dataMy crate tiptoe stores its smart pointers‚Äô reference counts directly inside the hosted value instances. Pinning allows them to still expose an exclusive reference as Pin&amp;lt;&amp;amp;mut T&amp;gt;.You can read more about intrusive reference-counting and the heap-only pattern it enables in this earlier post: Intrusive Smart Pointers + Heap Only Types = üíûPersisting self-referencesConsider the following async block:async { let a = &quot;Hello, future!&quot;; let b = &amp;amp;a; yield_once().await; println!(&quot;{}&quot;, b);}This code creates an opaquely-typed Future instance that will, at least formally, contain a reference to another of its fields after it is polled for the first time.The instance won‚Äôt be externally borrowed anymore at that time, but moving it would break the private reference b to a, so Future::poll(‚Ä¶) requires self: Pin&amp;lt;&amp;amp;mut Self&amp;gt; as receiver.This ensures that instances of impl Future will only enter such a state when they are already guaranteed not to be moved again. If an executor does need to move Futures, it can require Future + Unpin instead, which allows converting &amp;amp;mut _ to Pin&amp;lt;&amp;amp;mut _&amp;gt; on the fly.Side note: Pinning is a huge deal for safe async performance! As even instances of eventually self-referential impl Futures start out unpinned, they are directly composable without workarounds like lifting their state onto the heap on demand. This results in less fragmentation, less unusual control flow and smaller code size (before inlining, at least) in the generated state machines, all of which makes it much easier to evaluate them quickly. (Or rather: It raises the ceiling for what an async runtime can reasonably achieve, as it won‚Äôt be held back by generated code it has no control over. While a simple async runtime is fairly easy to write in Rust, great ones are schedulers that operate very ‚Äúclose to the metal‚Äù and as such are often strongly affected by hardware quirks. Their development is quite interesting to follow.)Weakening non-moveabilityFor the final section of this post, let‚Äôs take a step back and look at the initial pinning guarantee again.While pinned instances can‚Äôt be moved safely by other unrelated code, it‚Äôs still often possible to provide functions like the following:/// Swaps two pinned instances, making adjustments as necessary.pub fn swap( a: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, b: Pin&amp;lt;&amp;amp;mut Self&amp;gt;,) { ‚Ä¶ }As swap has access to Self‚Äôs private fields (and can rely on internal implementation details regarding how Self makes use of pinning exactly), it‚Äôs able to patch any self-referential or global instance registry pointers as necessary during the exchange.It‚Äôs also possible to similarly recreate the rest of C++‚Äôs address-aware value movement infrastructure, as pointed out by Miguel Young in April in Move Constructors in Rust:Is it possible? and implemented in the moveit crate.In addition to a Rust program more nicely interfacing with C++ this way, pinning collections can also use moveit‚Äôs MoveNew and CopyNew traits to port part of their non-pinning API to their pinning interface in a more Rust-like fashion:impl&amp;lt;T&amp;gt; C&amp;lt;T&amp;gt; { pub fn push_pin( this: &amp;amp;mut Pin&amp;lt;Self&amp;gt;, value: T, ) -&amp;gt; Pin&amp;lt;&amp;amp;mut T&amp;gt; where T: MoveNew { todo!(&quot;Potentially reallocate existing items.&quot;) } pub fn push_pinned( this: &amp;amp;mut Pin&amp;lt;Self&amp;gt;, value: Pin&amp;lt;MoveRef&amp;lt;&#39;_, T&amp;gt;&amp;gt;, ) -&amp;gt; Pin&amp;lt;&amp;amp;mut T&amp;gt; where T: MoveNew { todo!(&quot;Potentially reallocate existing items, move new item.&quot;) }}// Careful: This also enables `Clone` for `Pin&amp;lt;C&amp;lt;T&amp;gt;&amp;gt;`!impl&amp;lt;T: CopyNew&amp;gt; Clone for C&amp;lt;T&amp;gt; { pub fn clone(self) -&amp;gt; Self { todo!(&quot;Clone items in an address-aware way.&quot;) }}Collections with stable backing storage can often accept new values regardless of whether they are currently pinning, but a pinning Vec-like for example sometimes has to reallocate and as such must allow its values to patch pointers to expand arbitrarily.The CopyNew trait can be implemented more broadly than the standard Clone, which can‚Äôt be used where internal pointers or certain types of back-reference may exist (e.g. non-owning ‚Äúmulticast‚Äù-like references to the instance in question).ThanksTo Robin Pederson and telios for proof-reading and various suggestions on how to improve clarity, and to Milou for criticism and suggestions from a C++ perspective.License and Translations (in detail)This post as a whole with exception of citations is licensed under CC BY-NC-SA 2.0. All code samples (that is: code blocks and snippets formatted like this), except for citations, are additionally licensed under CC0 1.0, so that you can freely use them in your projects under any license or no license.Citations from official Rust projects retain their original MIT OR Apache-2.0 license and are used as permitted at https://www.rust-lang.org/policies/licenses. Sorry about the complexity here, unfortunately my country barely recognises fair use.If you translate this post, please let me know so that I can link it above. I should be able to post a German translation myself before long.(I suggest using the same license structure for code snippets in translations as here, though this is not something I can enforce. If a translation uses a different license, you can likely still take the code you need from the original here under CC0.)" }, { "title": "Intrusive Smart Pointers + Heap Only Types = üíû", "url": "/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/", "categories": "Rust", "tags": "patterns, api, walkthrough, crate included", "date": "2021-11-14 18:44:00 +0100", "snippet": " In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomatic? (Yes, if‚Ä¶) Heap-only mutability Intrusive counting How to do this 99% safely? (I made a crate.) The Clone hole ‚ö† Plugging the Clone hole Where to go from here Prior work: The initial approach is inspired by triomphe::ArcBorrow. Cover image made using https://feynman.aivazis.com/.Not physically accurate. Time is horizontal. Lifetime dependencies omitted.Please note that this post is a proof of concept. I‚Äôm confident it can be implemented in a way that has no or negative overhead compared to, for example, the standard library‚Äôs smart pointers, but I have not gotten around to do this yet.Heap Only TypesRust can model (at least) two kinds of heap-only-ish types: Unsized types, which cannot be placed on the stack by the compiler because their size is unknown, and semantically heap-only types, which are contextually heap-only whenever an API doesn‚Äôt allow them to be observable elsewhere.As usual, these limitations don‚Äôt exist for unsafe Rust, which is beyond the scope of this post.The type examined here is only semantically heap-only towards a consumer in a different crate, but the pattern I present also works for unsized (dynamically-sized) types.Where do they appear?There is an opportunity to make a type heap-only whenever it would otherwise be useless. A good example is the following reference-counted inverse tree:// ances-tree/lib.rsuse std::{borrow::Borrow, sync::Arc};use tap::Pipe; // ¬π#[cfg(doctest)]pub mod readme { doc_comment::doctest!(&quot;../README.md&quot;);}/// A reference-counting inverse tree node.#[derive(Debug, Clone)]pub struct Node&amp;lt;T&amp;gt; { pub parent: Option&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt;, pub value: T,}impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { /// Creates a new [`Node`] instance with the given `parent` and `value`. pub fn new(parent: Option&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt;, value: T) -&amp;gt; Self { Self { parent, value } } /// Retrieves a reference to a [`Node`] with a value matching `key` iff available. /// /// See also: &amp;lt;https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.get&amp;gt; #[must_use] pub fn get&amp;lt;Q: ?Sized&amp;gt;(&amp;amp;self, key: &amp;amp;Q) -&amp;gt; Option&amp;lt;&amp;amp;Self&amp;gt; where T: Borrow&amp;lt;Q&amp;gt;, Q: Eq, { let mut this = self; while this.value.borrow() != key { this = this.parent.as_ref()? } Some(this) } // Abridged. See omitted code at ¬≤.}¬π Not shown in this abridged snippet, I‚Äôm using myrrlyn‚Äôs excellent tap crate to organise long expressions in execution order.¬≤ Tamschi/ances-tree üîñblog-link/basic-inverse-tree (lib.rs#L46-L124)üíÅ‚Äç‚ôÇÔ∏è I‚Äôve published this example crate on GitHub and will occasionally link tags and diffs for you to follow along. The project that inspired this pattern, rhizome, is too verbose and messy to cite here, but follows generally the same structure.You can see the changes for each section in this post in the blog-steps branch. GitHub isn‚Äôt too clear about this, but the section title ones are merge commits that together contain all changes.Note that the above doesn‚Äôt make Node heap-only yet!Handling heap only typesTo restrict a type to the heap, we pin it behind a smart pointer (in this case Arc) as follows:use std::{borrow::Borrow, marker::PhantomPinned, pin::Pin, sync::Arc};use tap::Pipe;/// A reference-counting inverse tree node.#[derive(Debug)] // No `Clone`!pub struct Node&amp;lt;T&amp;gt; { pub parent: Option&amp;lt;Pin&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt;&amp;gt;, pub value: T, // The private field also prevents construction elsewhere. _pin: PhantomPinned,}impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { /// Creates a new [`Node`] instance with the given `parent` and `value`. pub fn new(parent: Option&amp;lt;Pin&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt;&amp;gt;, value: T) -&amp;gt; Pin&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt; { Self { parent, value, _pin: PhantomPinned, } .pipe(Arc::pin) } // `.get(‚Ä¶)` unchanged. // `.get_mut(‚Ä¶)` and `.make_mut(‚Ä¶)` removed for now.}The consumer now never sees a Node or &amp;amp;mut Node directly, which means the instances can‚Äôt be moved away from the heap.The .get(‚Ä¶) method remains unchanged as &amp;amp;Node is still accessible through impl&amp;lt;P: Deref&amp;gt; Deref for Pin&amp;lt;P&amp;gt;..get_mut(‚Ä¶) and .make_mut(‚Ä¶) have been removed for now since the Rust standard library doesn‚Äôt provide equivalents of its Arc::get_mut and Arc::make_mut functions for Pin&amp;lt;Arc&amp;lt;‚Ä¶&amp;gt;&amp;gt;.Note that even exclusively held Node‚Äôs are effectively read-only now. There are work-arounds for all of this, of course, but they involve a lot of unsafe. This feature will safely come back later on, though.Cloning a handle from a heap-only borrow?When borrowing the contents of an Arc&amp;lt;T&amp;gt;, we usually want to handle a &amp;amp;T rather than an &amp;amp;Arc&amp;lt;T&amp;gt; to avoid a double-indirection when accessing the value.Since any API consumer will only see pinned Nodes, we know that any &amp;amp;Node we see actually points to an instance managed by Arc. Can we increment the reference count to create an additional Arc?The answer is, unfortunately here but fortunately in general, no.Even if Arc had a known layout with a known pointer offset, we would not be allowed to magic-up a borrow using pointer maths:As the Arc reference count is stored outside Node, we must not* access it through &amp;amp;Node even using pointer maths, as this would be an out-of-bounds read.üíÅ‚Äç‚ôÇÔ∏è *Technically code like that works right now, but I‚Äôm told it‚Äôs still considered UB. Never allowing out-of-bounds access through references could enable or at least simplify powerful optimisations in the future.As triomphe has a matching known-Arc-borrow API, we can quickly see what this would look like if we borrowed into a pointer and abstracted instead.First, we switch out the Arc import:use std::{borrow::Borrow, marker::PhantomPinned, pin::Pin};use tap::Pipe;use triomphe::{Arc, ArcBorrow};and adjust the constructor a bit since triomphe isn‚Äôt Pin-aware:impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { /// Creates a new [`Node`] instance with the given `parent` and `value`. pub fn new(parent: Option&amp;lt;Pin&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt;&amp;gt;, value: T) -&amp;gt; Pin&amp;lt;Arc&amp;lt;Self&amp;gt;&amp;gt; { Self { parent, value, _pin: PhantomPinned, } .pipe(Arc::new) .pipe(|arc| unsafe { Pin::new_unchecked(arc) }) } // `.get(‚Ä¶)` unchanged. // `.get_mut(‚Ä¶)` and `.make_mut(‚Ä¶)` still missing.}We also have to shim the following functions:#[must_use]pub fn borrow&amp;lt;T&amp;gt;(this: &amp;amp;Pin&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Pin&amp;lt;ArcBorrow&amp;lt;&#39;_, Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt; { unsafe { &amp;amp;*(this as *const Pin&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;).cast::&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;() } .pipe(Arc::borrow_arc) .pipe(|arc_borrow| unsafe { Pin::new_unchecked(arc_borrow) })}#[must_use]pub fn clone_arc&amp;lt;T&amp;gt;(this: &amp;amp;Pin&amp;lt;ArcBorrow&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Pin&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt; { unsafe { &amp;amp;*(this as *const Pin&amp;lt;ArcBorrow&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;).cast::&amp;lt;ArcBorrow&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;() } .pipe(ArcBorrow::clone_arc) .pipe(|arc| unsafe { Pin::new_unchecked(arc) })}So far so good.Their signatures are a mouthful, so we‚Äôll change the code again to abstract the borrow type a bit, and use that abstraction everywhere it‚Äôs applicable.First the borrow:#[derive(Debug)]pub struct NodeBorrow&amp;lt;&#39;a, T&amp;gt; { arc_borrow: Pin&amp;lt;ArcBorrow&amp;lt;&#39;a, Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;,}impl&amp;lt;T&amp;gt; Deref for NodeBorrow&amp;lt;&#39;_, T&amp;gt; { type Target = Node&amp;lt;T&amp;gt;; fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Self::Target { &amp;amp;*self.arc_borrow }}And then the handle:#[derive(Debug)]pub struct NodeHandle&amp;lt;T&amp;gt; { arc: Pin&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;,}impl&amp;lt;T&amp;gt; NodeHandle&amp;lt;T&amp;gt; { /// Creates a new [`Node`] instance with the given `parent` and `value`. pub fn new(parent: Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt;, value: T) -&amp;gt; Self { Node { parent, value, _pin: PhantomPinned, } .pipe(Arc::new) .pipe(|arc| unsafe { Pin::new_unchecked(arc) }) .pipe(|arc| Self { arc }) } #[must_use] pub fn borrow(this: &amp;amp;Self) -&amp;gt; NodeBorrow&amp;lt;&#39;_, T&amp;gt; { unsafe { &amp;amp;*(&amp;amp;this.arc as *const Pin&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;).cast::&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;() } .pipe(Arc::borrow_arc) .pipe(|arc_borrow| unsafe { Pin::new_unchecked(arc_borrow) }) .pipe(|arc_borrow| NodeBorrow { arc_borrow }) } #[must_use] pub fn clone_handle(this: &amp;amp;NodeBorrow&amp;lt;T&amp;gt;) -&amp;gt; Self { unsafe { &amp;amp;*(&amp;amp;this.arc_borrow as *const Pin&amp;lt;ArcBorrow&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;).cast::&amp;lt;ArcBorrow&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;() } .pipe(ArcBorrow::clone_arc) .pipe(|arc| unsafe { Pin::new_unchecked(arc) }) .pipe(|arc| Self { arc }) }}impl&amp;lt;T&amp;gt; Deref for NodeHandle&amp;lt;T&amp;gt; { type Target = Node&amp;lt;T&amp;gt;; fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Self::Target { &amp;amp;*self.arc }}Node itself loses its constructor and now stores a NodeHandle as parent reference:/// A reference-counting inverse tree node.#[derive(Debug)]pub struct Node&amp;lt;T&amp;gt; { pub parent: Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt;, pub value: T, _pin: PhantomPinned,}impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { // Constructor removed, otherwise unchanged.}That‚Äôs fairly nice now. The only sticking points are that we have a NodeBorrow&amp;lt;&#39;a, T&amp;gt; instead of an &amp;amp;&#39;a Node and no exclusive/mutable references to Node.Exposing two bespoke helper types to fix clumsy signatures also isn‚Äôt ideal, but more of an incidental issue.Can this be more idiomatic?Let‚Äôs say we had a hypothetical Arc&amp;lt;T&amp;gt; that was legal to borrow from &amp;amp;T. Let‚Äôs also say it was pinning-aware so that we can skip some boilerplate while preventing any de-boxing.First, our NodeHandle is now a type alias, since we won‚Äôt need additional functions:pub type NodeHandle&amp;lt;T&amp;gt; = Pin&amp;lt;Arc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;;Second,pub type NodeBorrow&amp;lt;&#39;a, T&amp;gt; = &amp;amp;&#39;a Node&amp;lt;T&amp;gt;;, but since that type alias is longer than its original type, we‚Äôll just write &amp;amp;Node&amp;lt;T&amp;gt; instead.Third, Node remains unchanged for now, but all functions are concentrated on that type like this:impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { /// Creates a new [`Node`] instance with the given `parent` and `value`. pub fn new(parent: Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt;, value: T) -&amp;gt; NodeHandle&amp;lt;T&amp;gt; { Node { parent, value, _pin: PhantomPinned, } .pipe(Arc::pin) } /// Retrieves a reference to a [`Node`] with a value matching `key` iff available. /// /// See also: &amp;lt;https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.get&amp;gt; #[must_use] pub fn get&amp;lt;Q: ?Sized&amp;gt;(&amp;amp;self, key: &amp;amp;Q) -&amp;gt; Option&amp;lt;&amp;amp;Self&amp;gt; where T: Borrow&amp;lt;Q&amp;gt;, Q: Eq, { let mut this = self; while this.value.borrow() != key { this = this.parent.as_ref()? } Some(this) } #[must_use] pub fn clone_handle(&amp;amp;self) -&amp;gt; NodeHandle&amp;lt;T&amp;gt; { todo!() // ü§î } // Mutability will be back, eventually.}The Arc can‚Äôt know that our Node is only ever visible behind Arc, so we have to provide a safe .clone_handle() method ourselves.Heap-only mutabilityThe signature of an exclusive borrow in Rust is Pin&amp;lt;&amp;amp;mut _&amp;gt;. While the Arc can‚Äôt be DerefMut (which would allow us to use Pin::as_mut), it can generically provide us with pinning alternatives to its get_mut and make_mut methods.We can use these to go from &amp;amp;mut NodeHandle&amp;lt;T&amp;gt; to Pin&amp;lt;&amp;amp;mut Node&amp;lt;T&amp;gt;&amp;gt;.üíÅ‚Äç‚ôÇÔ∏è Pin&amp;lt;&amp;amp;mut Node&amp;lt;T&amp;gt;&amp;gt; is Deref&amp;lt;Target = Node&amp;lt;T&amp;gt;&amp;gt; (because &amp;amp;mut Node&amp;lt;T&amp;gt; is the same), so we could access a shared reference and clone the NodeHandle&amp;lt;T&amp;gt;, which would give us a parallel shared reference to our now-free-again exclusive reference (&amp;amp;Node&amp;lt;T&amp;gt; and parallel &amp;amp;mut Node&amp;lt;T&amp;gt;). This would be extremely bad.We‚Äôll assume that the Arc already protects against this invalid construct, at the cost of slight (additional) overhead per exclusive borrow.This isn‚Äôt quite enough to let a consumer change the contents of the instance, since we still aren‚Äôt providing mutable access to the public fields. Manual pin-projection is somewhat error-prone to implement, so we‚Äôre going to let the pin-project crate take care of that:/// A reference-counting inverse tree node.#[pin_project::pin_project]#[derive(Debug)]pub struct Node&amp;lt;T&amp;gt; { pub parent: Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt;, pub value: T, #[pin] // Required to keep `Node&amp;lt;T&amp;gt;: !Unpin`! _pin: PhantomPinned,}impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { #[must_use] pub fn parent_mut&amp;lt;&#39;a&amp;gt;(self: &amp;amp;&#39;a mut Pin&amp;lt;&amp;amp;mut Self&amp;gt;) -&amp;gt; &amp;amp;&#39;a mut Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt; { self.as_mut().project().parent } #[must_use] pub fn value_mut&amp;lt;&#39;a&amp;gt;(self: &amp;amp;&#39;a mut Pin&amp;lt;&amp;amp;mut Self&amp;gt;) -&amp;gt; &amp;amp;&#39;a mut T { self.as_mut().project().value }}We must mark _pin as structural(ly pinned) here; otherwise pin_project would impl&amp;lt;T&amp;gt; Unpin for Node&amp;lt;T&amp;gt; {} with no constraints.The self: &amp;amp;&#39;a mut Pin&amp;lt;&amp;amp;mut Self&amp;gt; parameter on these methods looks a bit strange, but lets a consumer call them directly on the guard we get from Arc::get_mut:#[test]fn test() { let mut handle = Node::new(None, 1); { let mut exclusive = Arc::get_mut(&amp;amp;mut handle).unwrap(); let _: &amp;amp;mut i32 = exclusive.value_mut(); let _: &amp;amp;mut Option&amp;lt;NodeHandle&amp;lt;i32&amp;gt;&amp;gt; = exclusive.parent_mut(); } let second_handle = Pin::clone(&amp;amp;handle); assert!(Arc::get_mut(&amp;amp;mut handle).is_none()); assert_eq!(second_handle.value, 1);}üíÅ‚Äç‚ôÇÔ∏è It‚Äôs likely a good idea to inline parent_mut and value_mut. However, performance-optimisation is arbitrarily out of scope for this post.Intrusive countingThe reason alloc::sync::Arc and triomphe::Arc can‚Äôt quite soundly go from ‚Äú&amp;amp;T-behind-Arc&amp;lt;T&amp;gt;‚Äù to a cloned Arc&amp;lt;T&amp;gt; is only the required out-of-bounds access to the Arc‚Äôs reference counter in those case.If we can move the reference-counter inside the contained instance, we are then able to get a reference to it and, by effectively reimplementing alloc::sync::Arc&amp;lt;T&amp;gt; without exposing &amp;amp;mut T, can arrive at the API above.At this point, only the following types are exposed: A generic Arc&amp;lt;T&amp;gt; that acts much like the standard library‚Äôs. A generic guard that ensures mutable borrow exclusivity dynamically. Our Node&amp;lt;T&amp;gt;, which contains the entirety of our API.How to do this (almost) safely?The necessary smart pointer I needed for the above turned out to be really easy to abstract, so I‚Äôve turned it into a crate that you can find here: üì¶tiptoe(Be sure to activate the &quot;sync&quot; feature to use Arc.)You still have to adjust your struct to make it compatible, but this can be done in few lines of code and without using unsafe more than once:use std::{borrow::Borrow, pin::Pin};use tap::Pipe;use tiptoe::{Arc, IntrusivelyCountable, TipToe};/// A reference-counting inverse tree node.#[pin_project::pin_project]#[derive(Debug)]pub struct Node&amp;lt;T&amp;gt; { pub parent: Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt;, pub value: T, #[pin] // Required to keep `Node&amp;lt;T&amp;gt;: !Unpin`! tip_toe: TipToe,}impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { /// Creates a new [`Node`] instance with the given `parent` and `value`. pub fn new(parent: Option&amp;lt;NodeHandle&amp;lt;T&amp;gt;&amp;gt;, value: T) -&amp;gt; NodeHandle&amp;lt;T&amp;gt; { Node { parent, value, tip_toe: TipToe::new(), } .pipe(Arc::pin) }}unsafe impl&amp;lt;T&amp;gt; IntrusivelyCountable for Node&amp;lt;T&amp;gt; { type RefCounter = TipToe; #[inline(always)] fn ref_counter(&amp;amp;self) -&amp;gt; &amp;amp;Self::RefCounter { &amp;amp;self.tip_toe }}TipToe, the reference-counting slot, is written to be as unobtrusive as possible: It‚Äôs transparent to all standard comparisons and hashing. It implements Default and Clone (but the clone always has the default value). It‚Äôs !Unpin, so it can be used to pin the surrounding struct.tiptoe::Arc&amp;lt;T&amp;gt; will never provide a &amp;amp;mut reference to its contents directly (and provides Pin&amp;lt;&amp;amp;mut _&amp;gt; only as Pin&amp;lt;Arc&amp;lt;_&amp;gt;&amp;gt;), but if T: Unpin, then Arc&amp;lt;T&amp;gt; and Pin&amp;lt;Arc&amp;lt;T&amp;gt;&amp;gt;, and Pin&amp;lt;&amp;amp;mut T&amp;gt; and &amp;amp;mut T, are equivalent and can be converted safely. Keep this in mind when exposing instances of your types through a conversion that requires unsafe.TipToed, the trait by which Arc finds the intrusive counter, is unsafe as Rust‚Äôs type system can‚Äôt guarantee a ‚Äúboring‚Äù implementation with only one embedded counter returned at all times. (The actual safety requirements are actually slightly more lenient than that, though. The true requirement is that it mustn‚Äôt confuse the count in a way that would cause instances to be dropped early, and that the call must have absolutely no (observable) effect.)Since Node is a heap-only and Arc-only type via pinning, we can additionally provide the following method:impl&amp;lt;T&amp;gt; Node&amp;lt;T&amp;gt; { #[must_use] pub fn clone_handle(&amp;amp;self) -&amp;gt; NodeHandle&amp;lt;T&amp;gt; { Pin::clone(unsafe { Arc::borrow_pin_from_inner_ref(&amp;amp;self) }) }}As you can see, we assume &amp;amp;self is behind a Pin&amp;lt;Arc&amp;lt;_&amp;gt;&amp;gt;. Arc&amp;lt;_&amp;gt; is ABI-compatible with a plain shared reference, so it can be borrowed from one (via a short detour through &amp;amp;&amp;amp;self).The Clone hole ‚ö†tiptoe::Arc also provides a make_mut function, which has the same copy-on-write functionality as in the standard library. However, there is a problem with making this available for our Node&amp;lt;T&amp;gt;: alloc::sync::Arc::&amp;lt;T&amp;gt;::make_mut requires T: Clone.We cannot implement Clone on Node&amp;lt;_&amp;gt; because that would allow a consumer to move from &amp;amp;Node&amp;lt;T&amp;gt; to Node&amp;lt;T&amp;gt;, an instance decidedly off-heap.Plugging the Clone holeFor this reason, tiptoe::Arc::&amp;lt;T&amp;gt;::make_mut instead requires tiptoe::ManagedClone. This trait has the same shape as Clone but its methods are unsafe and it comes with a caller restriction:/// # Safety////// This method may only be used to create equally encapsulated instances.////// For example, if you can see the instance is inside a [`Box`](`alloc::boxed::Box`),/// then you may clone it into another [`Box`](`alloc::boxed::Box`) this way.////// If you have only a reference or pointer to the implementing type&#39;s instance,/// but don&#39;t know or can&#39;t replicate its precise encapsulation, then you must not call this method.////// You may not use it in any way that could have side-effects before encapsulating the clone./// This also means you may not drop the clone. Forgetting it is fine.unsafe fn managed_clone(&amp;amp;self) -&amp;gt; Self;In short: This method mustn‚Äôt be used by an API consumer to interact with unwrapped instances.(Any type that is Clone is automatically ManagedClone.)You can find this final step in the implementation here:Tamschi/ances-tree üîñblog-link/managed-clone (lib.rs#L83-L94)The develop branch also contains a rehash of the assumptions made at each location where unsafe is used.Where to go from hereI‚Äôve implemented tiptoe only as far as I personally need it, so there are a few open points where it could be more useful: Nobody has audited tiptoe so far. It contains a lot of unsafe snippets, so getting a few more eyes on it would be helpful in this regard. I currently only need Arc, not Rc. I‚Äôve implemented TipToe in such a way that it can alternatively act as Rc reference counter with no synchronisation overhead, so it should be fairly easy to copy-paste the latter from the former if needed. The crate is unoptimised in terms of speed. I don‚Äôt have experience with benchmarking Rust and don‚Äôt need the crate to be particularly fast right now. TipToe is a strong reference counter only. From what I can tell, tiptoe::Arc and an eventual tiptoe::Rc could become compatible with an additional intrusive strong/weak counter without breaking API changes. I may add an ExclusiveArc&amp;lt;_&amp;gt; or Unique&amp;lt;_&amp;gt; type in the future, which would behave like a standard Box&amp;lt;_&amp;gt; but set the internal counter to the exclusivity value until converted into an Arc. It‚Äôs also likely possible to improve the way dynamic exclusivity works, but I suspect I currently lack the necessary skills for that. " }, { "title": "Some thoughts on Bubble", "url": "/posts/Some-thoughts-on-Bubble/", "categories": "Web Development", "tags": "tooling, evaluation, critique, PaaS", "date": "2021-07-19 19:51:00 +0200", "snippet": "I tend to be a bit doubtful if there‚Äôs a new technological trend that I know has in reality been tried (to mediocre success) for upwards of twenty years, to varying levels of fanfare. This also applies to ‚Äúwithout coding‚Äù or ‚ÄúNo Code‚Äù software or service creation.I shared some general scepticism in this regard when I came across it on Twitter, and got a reply pointing out a specific implementation:https://twitter.com/nocodechris/status/1417035866011275266Technology changes, so it would be unfair to immediately dismiss this.I spent about an hour evaluating Bubble, by watching a video tutorial, going through the onboarding process, playing around a bit with the editor, looking through the template selection and examining a few sites built with it. That‚Äôs not enough for a thorough review, as the tool is complex enough to be the subject of multiple tutorial series, but it was enough to run into some rough edges, which I‚Äôll go over below.Quick Navigation: Poor output quality Accessibility issues Not no code Cost Lock-in ConclusionPoor output qualityThis is the elephant in the room, so I‚Äôll go over it first.Before continuing, I encourage you to visit Bubble‚Äôs showcase page. Play around with a few sites, resize the window, hover over parts of the page, inspect the document model.Here‚Äôs what I noticed while doing so: Pages are unexpectedly slow I believe this is due to a mixed over-reliance on both JavaScript and inline styling. No static version of the site is served (for which there is no technical reason; Especially with a WYSIWYG editor, it should be feasible to render at least an initial version of a page on the server). Instead, the page comes up completely blank with disabled scripts, and with enabled scripts takes about 1.5 seconds to show any content at all for a simple static page: (The Sprrk.ly main page, which does not contain much or dynamic content, takes 1.5 seconds to show and over three seconds to stabilise.) This isn‚Äôt great in terms of end user experience, but it‚Äôs not necessarily a complete deal breaker. However, it does mean that your site may perform considerably worse in places with poor connectivity, like in Germany for example. (I‚Äôm using a fast connection though, fortunately.) Something else you may have noticed is that many of the page‚Äôs resources start loading very late. This could be improved considerably by adding them as &amp;lt;link rel=reload as=&quot;‚Ä¶&quot; href=&quot;‚Ä¶&quot;&amp;gt; elements to the page‚Äôs static HTML header. Lag There is a noticeable delay between resizing the browser window and the page reacting with a layout update, or there can even be a series of staggered layout updates. This occurs because Bubble seems to rely on JavaScript and absolute positioning to lay out elements on the page: (goodgigs.app‚Äôs landing page takes quite a while to stabilise after a resize.) The fix here would be to use a robust slot-based layout system with static CSS styles, but this would likely be incompatible with all existing Bubble apps. JavaScript-based layout like the above tends to drain device batteries quickly, turning away mobile users and users of low-power or currently energy-saving devices, where the performance impact is more noticeable. Wrong mouse cursors/inconsistently clickable elements It‚Äôs a minor issue, but some of the pages I saw didn‚Äôt use the correct mouse cursor appearance for clickable elements or had nested elements that made regions of their parent unexpectedly not clickable. I didn‚Äôt see a way to adjust this in the editor, but it‚Äôs likely fixable by writing some CSS. Accessibility issuesBubble‚Äôs editor has zero support for accessibility features. Seemingly not even image alt texts.Combined with a lack of support for semantic HTML, this makes sites built with it hard or in some cases impossible to use for many disabled Internet users.(If you are unfamiliar with concept of web accessibility, here is a list of resources by the relevant standards body: W3C WAI - Accessibility Fundamentals Overview)Something I noticed that stood out to me negatively is that a (third-party) tutorial recommended using an ‚Äúicon‚Äù element as custom-styled check-box. Bubble‚Äôs plugin search dialog appears to use similar replacement elements, likely manually coded but still inaccessible.While this is common for professional web developers to do in HTML too, we have to take care to add back the right semantics (like being able to use the tab key to navigate, the right ARIA role, or read-aloud checked-state information) to make the element usable not only visually and not only via mouse!You can get a rough estimate of a page‚Äôs accessibility using the Lighthouse tab in Chomium browsers‚Äô developer tools: (The Bubble website itself appears to be built using their tool, so it too fares badly.The rating varies by page, but the Academy one seemed like a typical content mix.)Not no codeThis is probably a matter of perspective, but Bubble sites appear to still require a lot of coding if you are looking to create a cohesive user experience. Take for example this ‚ÄúSelect All‚Äù button tutorial:https://www.youtube.com/watch?v=ImJausGZLs4&amp;amp;t=170s(The video should start at 2:50, as the workflow is set up.)This looks a lot like coding to me. It‚Äôs in English, but the complexity is about the same as if I‚Äôd write this in TypeScript or JavaScript. It‚Äôs a little bit more cumbersome if you use the mouse like this, though.What Bubble succeeds at is removing the barrier of entry for basic dynamic website creation, but you‚Äôll still have to either hire or become a coder to make something a bit more complex or convenient.The available options are metaphorically at your fingertips through popup lists, but I think it‚Äôs still likely you‚Äôll have to look up tutorials to use them correctly, as there are not always documentation links.In fairness: It‚Äôs most likely possible to wrap this functionality into a plugin. However, this was not available when I looked for it in July 2021. If your specific feature hasn‚Äôt been made available yet, you‚Äôll either have to click or write some code or pay someone for it.CostNot writing code costs a lot (relatively speaking).As of writing this, the lowest-cost useful plan (that is: one that can actually deploy a live version) costs $25 monthly if paid annually, $29 on a true monthly basis.This comes with one editor (user) and 10GB storage, though seemingly no limit regarding the number of apps that can be deployed.If you‚Äôre an agency and would like to provide ongoing support using this platform, you will have to pay at least $71/month/person.For comparison, generic dynamic hosting with similar specification seems to start around 2‚Ç¨ monthly, including top level domain registration. If you can code traditionally and want to support your product into a polished state, that‚Äôs likely more economical, as Bubble‚Äôs editor won‚Äôt help much with those last 20% where you get rid of styling edge cases and general jank.(As Lighthouse mentions, optimizing site performance can also give you a major conversion rate boost. I‚Äôm not sure doing that is even possible on Bubble.)If you‚Äôre looking to host a static personal page, you can do that for free using GitHub Pages, or if you would like to avoid writing code, then Carrd lets you make basic SPAs for $9/year for three of those. (I‚Äôm paying a little more - $19/year with a limit of 10 - since I‚Äôm spicing mine up with a bit of JavaScript.)Lock-inThis might be a serious issue. I don‚Äôt see any way a Bubble app could be portable between services, so if Bubble disappears, so will the apps built with it.That said, since all useful plans are paid and have a significant margin, it‚Äôs unlikely that the service will close down outright while there are still people relying on it, at least in terms of financial reasons. With a launch date in 2012 it‚Äôs also relatively long-running, though I would have expected a much higher-quality user- and technical experience by now. The app feels more like a startup that launched its product between two and three years ago‚Äôs.ConclusionI still think that no-code or reduced-code service development is an interesting area, but it‚Äôs not quite there yet, still, in my eyes.As of right now, it still (in this case) appears to be a niche tool for a very specific group that‚Äôs neither too wealthy nor too poor, not too skilled at web development but somewhat familiar with data processing, for applications that are not simple enough to work with static or purpose-bound hosting but also not complex enough to benefit from the scaling effects of frequent code reuse and a solid layout system.It‚Äôs rather ironic that Bubble has a tutorial series on cloning famous services:While Bubble apps are potentially viable while small, Bubble‚Äôs performance and accessibility issues make them a prime target for hostile clones.This means that, should an app built with Bubble be innovative enough to start blowing up, it‚Äôs likely for an investor or programmer/designer team to come along, commission or create a performant clone of the same business model, and then eat away the original‚Äôs market share through lower margins and better user experience.Personally, I won‚Äôt add Bubble to my toolset. For professional projects, it‚Äôs easier and faster for me to write a website directly in Angular or React (or even in plain HTML, if it‚Äôs simple enough), and to manage the database semi-manually.For personal projects, I‚Äôm already stringing together specialised hosted solutions that are all-together easier to use and less expensive than what I could achieve through Bubble‚Äôs interface as a single developer. (This is largely a result of tooling network effects. A more incremental, more compatible and more open no-code tool would likely work much better for me, but this couldn‚Äôt exist as #SaaS or #PaaS.)‚Üë " }, { "title": "Semantic FFI Bindings in Rust - Reactivating the Borrow Checker", "url": "/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/", "categories": "Rust, FFI", "tags": "patterns, api, walkthrough", "date": "2020-10-31 16:10:00 +0100", "snippet": " In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks Prerequisites:The Rustonomicon‚Äôs pages on How Safe and Unsafe Interact and on FFI Optional reading:cppreference.com on the restrict type qualifier üé® The image displayed on my watch is unsafe!Ferris by @‚Äçwhoisaldeka on Twitter, first posted here under CC-BY‚Ä¶ though technically speaking I downscaled the SVG version that‚Äôs in the Rustonomicon.I recently succeeded at writing a watch app for my old Kickstarter Pebble and made some discoveries in the process that may be interesting to others working on similar projects or FFI bindings in general. This post is part one of a two-part series, with the other (planned to be) covering some tricks you can use when wrapping an OOP C API.üíÅ‚Äç‚ôÇÔ∏è Some of the advice in this post hinges on the e.g. nightly-2020-10-30 #![feature(extern_types)]. To my knowledge, there is currently no fully sound way to use fully opaque references on stable!Should the feature change, please ping me with a comment and I‚Äôll update this post accordingly.A good starting point when writing FFI bindings is to transliterate the original C headers as closely as possible. For example‚Äôs sake, we‚Äôll examine a few functions from this page of the Pebble SDK docs:typedef struct Layer Layer;typedef struct Window Window;Window * window_create(void);bool window_is_loaded(Window * window);window_set_background_color(Window * window, GColor background_color);struct Layer * window_get_root_layer(const Window * window);void window_destroy(Window * window);becomesextern &quot;C&quot; { type Layer; // Nightly feature: extern_types type Window; fn window_create() -&amp;gt; *mut Window; fn window_is_loaded(window: *mut Window) -&amp;gt; bool; fn window_set_background_color(window: *mut Window, background_color: GColor); fn window_get_root_layer(window: *const Window) -&amp;gt; *mut Layer; fn window_destroy(window: *mut Window);}Extern types have a few useful properties, like not implementing any of the auto-traits by default. They are considered fully thread-unsafe and panic-unsafe, unless you explicitly specify otherwise. We‚Äôre dealing with a watch that doesn‚Äôt support threading at all, and also doesn‚Äôt know exceptions beyond bailing from a faulty app, so for the most part we‚Äôll ignore this aspect.A more interesting, and unique, property is that references (&amp;amp; and &amp;amp;mut) to extern types are FFI-safe as slim pointers while the type itself is considered unsized.Rust normally really likes to reorganise the backing storage of references: Small values passed by reference can be ‚Äúinlined‚Äù and passed by value instead, if that produces faster or smaller code. Even data behind a mutable reference can be copied and later written back due to Rust‚Äôs strict aliasing rules. However, if the size of the data isn‚Äôt known, it can‚Äôt:Rust preserves pointer identity of references to extern types!That‚Äôs it, that‚Äôs the post.‚ãÆNo, not really. There are a few finer points to take care of here. You may have noticed that I didn‚Äôt cite any of the non-code documentation. (Examples aren‚Äôt necessary exact copies from here on out.)/* Creates a new Window on the heap and initializes it with the default values. * [information about default values] * * RETURNS: * A pointer to the window. * `NULL` if the window could not be created. */Window * window_create(void);/* Destroys a Window previously created by window_create.*/void window_destroy(Window * window);Hm‚Ä¶ So this window creation function is actually fallible, but window_destroy expects a valid Window handle ü§îWe couldn‚Äôt tell from the signature alone because in C, all pointers are nullable. The developers would have had to compromise on convenience and/or write unidiomatic code to avoid this. That window_create can fail but window_destroy expects an actual instance makes sense too: This API is the same across all watch generations that were made, which includes my ‚Äúaplite‚Äù with only 100kB RAM in total, and only 24kB for app executable and heap combined. Creating too many Windows will fail eventually.Apps will usually configure their windows, so it‚Äôs more efficient to assume they will branch once after creation than making every other function accept null pointers. On a low power device, that‚Äôs a sensible design in my opinion.In any case, the first binding above lets us write the following unsound code without a complaint from the compiler:unsafe { window_destroy(window_create()) } // No!!!That‚Äôs a segfault in the making.Can we do better? In stable Rust, the answer is ‚Äúsomewhat‚Äù:struct Layer([u8; 0]); // Extern types aren&#39;t stable as of 2020-10-31.struct Window([u8; 0]);extern &quot;C&quot; { fn window_create() -&amp;gt; Option&amp;lt;NonNull&amp;lt;Window&amp;gt;&amp;gt;; fn window_is_loaded(window: NonNull&amp;lt;Window&amp;gt;) -&amp;gt; bool; fn window_set_background_color(window: NonNull&amp;lt;Window&amp;gt;, background_color: GColor); fn window_get_root_layer(window: NonNull&amp;lt;Window&amp;gt;) -&amp;gt; NonNull&amp;lt;Layer&amp;gt;; fn window_destroy(window: NonNull&amp;lt;Window&amp;gt;); /// Destroys a layer previously created by layer_create. fn layer_destroy(window: NonNull&amp;lt;Layer&amp;gt;);}It‚Äôs a bit awkward, but NonNull is FFI-safe and tells us precisely when the pointer points to actual memory.We lost the const qualifier on window_get_root_layer‚Äôs argument, but that‚Äôs an okay tradeoff to avoid a hard-to-debug segfault.We can now use the bindings like this:unsafe { let window = window_create().unwrap(); // Not elegant, but panics do create a trace! window_set_background_color(window, GREEN); let layer = window_get_root_layer(window); // ‚Ä¶ if !window_is_loaded(window) { window_destroy(window); } // ‚Ä¶ window_destroy(window); // Oh. layer_destroy(layer); // Oh no!}That‚Äôs one conditional double free and one API contract violation üôÅ(This layer wasn‚Äôt ‚Äúcreated by layer_create‚Äù. We got it from the Window instance which presumably dismantles it on destruction.)Can we do better? Not on stable. Our opaque newtypes above are zero-sized, so their address would likely be erased when handling references to them. Similarly the core type c_void is, as of Rust 1.47.0, implemented as#[repr(u8)]#[stable(feature = &quot;core_c_void&quot;, since = &quot;1.30.0&quot;)]pub enum c_void { #[unstable( feature = &quot;c_void_variant&quot;, reason = &quot;temporary implementation detail&quot;, issue = &quot;none&quot; )] #[doc(hidden)] __variant1, #[unstable( feature = &quot;c_void_variant&quot;, reason = &quot;temporary implementation detail&quot;, issue = &quot;none&quot; )] #[doc(hidden)] __variant2,}That‚Äôs not unsized. It‚Äôs actually quite a bit smaller than a usual reference too, so the compiler will most likely shift this memory around a lot if we create a &amp;amp; or &amp;amp;mut reference to this type!üíÅ‚Äç‚ôÇÔ∏è But even creating the Rust references would be undefined behaviour already, if we use it as stand-in for opaque C types: We can‚Äôt be sure that the memory location contains a valid discriminant for this enum (or, for that matter, exists at all, but that‚Äôs secondary here). Creating a Rust reference to a (potentially) invalid value is immediately unsound, even without dereferencing it!There is a better way (coming)As mentioned before, it is safe to create references to extern types regardless of their underlying data (though the API in question may limit this). With this in mind, we can rewrite our FFI bindings with full (shortened) documentation like this:üíÅ‚Äç‚ôÇÔ∏è There is one important caveat to this. I‚Äôll get to it later, and it‚Äôs a bit of a nasty footgun, so please bear with me.extern &quot;C&quot; { type Layer; // Nightly feature: extern_types type Window; /// [information about default values] fn window_create() -&amp;gt; Option&amp;lt;&amp;amp;&#39;static mut Window&amp;gt;; /// True if between `load` and `unload` callbacks. fn window_is_loaded(window: &amp;amp;mut Window) -&amp;gt; bool; /// This color is drawn by the window&#39;s root [`Layer`]. fn window_set_background_color(window: &amp;amp;mut Window, background_color: GColor); /// [information about layer layering] fn window_get_root_layer(window: &amp;amp;Window) -&amp;gt; &amp;amp;mut Layer; /// Destroys a [`Window`] previously created by [`window_create`]. fn window_destroy(window: &amp;amp;&#39;static mut Window); /// Destroys a [`Layer`] previously created by [`layer_create`]. fn layer_destroy(window: &amp;amp;&#39;static mut Layer);}That‚Äôs short! The functions‚Äô signatures say a lot about how to call them already, so there was room to add other information undisturbed.Something a bit peculiar is how commonly &amp;amp;&#39;static mut ExternType appears, which is pretty unidiomatic in regular Rust. I think the best way to describe these references is as ‚Äúexclusive handle‚Äù: There are no storage limitations on them, so you can move them across the heap without problem, but once you pass them into a function (like the destructors here), they are gone.Let‚Äôs try the previous usage example again:unsafe { let window = window_create().unwrap(); // Not elegant, but panics do create a trace! window_set_background_color(window, GREEN); let layer = window_get_root_layer(window); // ‚Ä¶ if !window_is_loaded(window) { window_destroy(window); } // ‚Ä¶ // Doesn&#39;t compile: // cannot borrow `*window` as mutable more than once at a time window_destroy(window); // Causes issues above: // cannot borrow `*window` as mutable because it is also borrowed // as immutable layer_destroy(layer);}Great! Note that this isn‚Äôt perfect - we could for example destroy the root layer if we leak the window, which could be prevented with likely zero runtime cost with additional #[repr(transparent)] newtype wrappers and proxy functions - but for concise FFI bindings this is a seriously low footgun density.üíÅ‚Äç‚ôÇÔ∏è This is still an unsafe API in other respects. For example, the window stack API gives out long-lived window handles that collide with handles we already hold, and there are some places where valid parameters are limited in a way Rust‚Äôs type system can‚Äôt represent directly.The CaveatThere is one really important rule to keep in mind when designing FFI bindings like this: A mutable reference cannot be aliased. Doing so is immediately undefined behaviour.On a safe API, this generally isn‚Äôt a problem: There would be either exactly one location to acquire an exclusive handle like this, or wrapper types that drop the restriction internally. (We can‚Äôt quite do this in a pure FFI binding, because the type in question would have to follow borrow semantics while implementing Copy to be passed as value.)Here‚Äôs an example:// This is a misleading binding!extern &quot;C&quot; { fn window_create() -&amp;gt; Option&amp;lt;&amp;amp;&#39;static mut Window&amp;gt;; fn window_stack_push(window: &amp;amp;mut Window, animated: bool); fn window_stack_pop(animated: bool) -&amp;gt; Option&amp;lt;NonNull&amp;lt;Window&amp;gt;&amp;gt;;}unsafe { let window = window_create()?; window_stack_push(window, true); // ‚Ä¶ let popped = window_stack_pop(true)?; // ‚Ä¶ window_stack_push(&amp;amp;mut *popped, true); // Whoops.}In the last line, window and the temporary mutable reference &amp;amp;mut *popped are aliased. Most importantly, this was low friction on the consumer‚Äôs part, too. Not¬†good!What went wrong? The issue here is that window_stack_push sets us up for retrieving the window handle later, but doesn‚Äôt take exclusive ownership of it. In C this makes sense: No part of the API is marked restrict, the handle stays valid after this API call and manipulating it afterwards is a common pattern.Rust isn‚Äôt so lenient, so let‚Äôs fix the extern declarations for our purposes:extern &quot;C&quot; { fn window_create() -&amp;gt; Option&amp;lt;&amp;amp;&#39;static mut Window&amp;gt;; fn window_stack_push(window: &amp;amp;&#39;static /* ‚Üê */ mut Window, animated: bool); fn window_stack_pop(animated: bool) -&amp;gt; Option&amp;lt;NonNull&amp;lt;Window&amp;gt;&amp;gt;;}unsafe { let window = window_create()?; window_stack_push(window, true); // ‚Ä¶ let popped = window_stack_pop(true)?; // ‚Ä¶ window_stack_push(&amp;amp;mut *popped, true); // Sound!}Barely anything changed, but‚Ä¶ suddenly the program is well-formed?The reason for this is that popped is now directly derived from the window borrow, without releasing it in the meantime. Parallel aliased &amp;amp;mut references are UB, but they are also nestable and reentrant¬π, which means the code above checks out.üíÅ‚Äç‚ôÇÔ∏è A high level wrapper will probably want to reorganise the API so that it holds onto a Window reference independently of threading it through the C callback API mentioned further below. This can be done by downgrading it to a pointer while at rest, combined with careful (safe) API surface restrictions, but the details of that are material for another post.Lifetime-generic opaque referencesIn the Pebble API, certain instances reference external data. Unfortunately, extern types don‚Äôt support generics directly, soextern &quot;C&quot; { pub type NumberWindow&amp;lt;&#39;a&amp;gt;;}does not compile.üíÅ‚Äç‚ôÇÔ∏è Visibilities didn‚Äôt matter much before this, so I left them out to reduce noise. I‚Äôll include them from here on out.Instead, the way we can model the API correctly is as follows:#[repr(transparent)]pub struct NumberWindow&amp;lt;&#39;a&amp;gt;(PhantomData&amp;lt;&amp;amp;&#39;a ()&amp;gt;, ExternData);extern &quot;C&quot; { type ExternData; type CStr; pub type void; // Actually like C&#39;s `void`. pub fn number_window_create&amp;lt;&#39;a&amp;gt;( label: &amp;amp;&#39;a CStr, // Can be changed later. callbacks: NumberWindowCallbacks, callback_context: &amp;amp;&#39;a mut void, ) -&amp;gt; Option&amp;lt;&amp;amp;&#39;a mut NumberWindow&amp;lt;&#39;a&amp;gt;&amp;gt;; pub fn number_window_destroy(number_window: &amp;amp;&#39;static mut NumberWindow);}NumberWindow inherits properties from both PhantomData (here a variant lifetime, but no accessible data) and ExternData (unsized with slim pointer). It‚Äôs a newtype that behaves as ‚Äúlimited-lifetime¬†foreign¬†type‚Äù.üíÅ‚Äç‚ôÇÔ∏è NumberWindow sports a user data pointer (callback_context above) on the C side, and I‚Äôd very much like to expose that in a strongly typesafe way too. Making NumberWindow itself generic over a type isn‚Äôt a problem because of PhantomData, but the following is unfortunately not legal in Rust:extern &quot;C&quot; { fn function&amp;lt;T&amp;gt;(); // E0044: foreign items may not have type parameters}Something to note is that number_window_destroy still takes an indefinite exclusive borrow (&amp;amp;&#39;static mut). This parameter can‚Äôt be relaxed more without making unsound usage convenient.The NumberWindow here is still NumberWindow&amp;lt;&#39;_&amp;gt;, but Rust doesn‚Äôt actually allow a &amp;amp;&#39;static NumberWindow&amp;lt;&#39;_&amp;gt; to exist, so the consumer has to use a slightly longer pointer cast (&amp;amp;mut *(number_window as *mut _ as *mut void as *mut _)) to destroy it. If you have a better idea for how to bind this (in context!), I‚Äôm all ears.Lifetime-generic callbacksThere is one final point I‚Äôd like to cover, which is the interaction of generic foreign types and function pointer types. On the C side, the following definition exists:typedef void(* NumberWindowCallback)( struct NumberWindow *number_window, void *context);C‚Äôs function pointer type definitions aren‚Äôt all that easy to read, but here‚Äôs a compatible Rust function that matches our earlier FFI declarations:extern &quot;C&quot; fn example_handler&amp;lt;&#39;a&amp;gt;( number_window: &amp;amp;&#39;a mut NumberWindow&amp;lt;&#39;a&amp;gt;, context: &amp;amp;mut void,) { // This is a concrete implementation.}The function has a generic parameter, so to declare the matching pointer type we can either use a concrete lifetime and thread that through the container hierarchy a bit or, more conveniently and accurately, we can use a type alias to a polymorphic function pointer type:pub type NumberWindowCallback = for&amp;lt;&#39;a&amp;gt; extern &quot;C&quot; fn( number_window: &amp;amp;&#39;a mut NumberWindow&amp;lt;&#39;a&amp;gt;, context: &amp;amp;mut void, );üíÅ‚Äç‚ôÇÔ∏è Rust‚Äôs documentation doesn‚Äôt quite spell out that this is possible for plain function pointers in addition to traits, or what to call it. The one specific mention I found after digging for a bit is the ForLifetimes? in the formal grammar on function pointer types, which just links to the section on where clauses.(Thanks for the correction, Mazdak Farrokhzad!)What‚Äôs nextI hope this post has been helpful so far. pebble-sys is still a work in progress, but I believe it‚Äôs on a good trajectory and this is just about everything I learned while working on it so far. It‚Äôs actually my first FFI binding (not counting C#), but it‚Äôs fun to go a bit beyond transliterating the C declarations üòÖFor the next post, I want to cover the constructs I used to reconcile Pebble‚Äôs polymorphic OOP API, memory safety, and 24kB of app working memory in pebble-skip. You‚Äôll also see a custom fallible Box with direct unsizing coercions.¬π Full disclosure: I was unable to find a direct mention of this latter bit. However, without reentrant mutable references, available pointer arithmetic would essentially be nonsensical, so I‚Äôm pretty sure re-entering mutable references from pointers is legal. It would be good to have some clarification here." }, { "title": "Building non-containers with Docker and VS Code", "url": "/posts/Building-non-containers-with-Docker-and-VS-Code/", "categories": "Build Automation", "tags": "VS Code, Docker", "date": "2020-02-27 14:48:00 +0100", "snippet": " In this post: example configuration command line breakdowns links to relevant documentation I recently set up containerised builds for my website [It‚Äôs not quite ready yet.] and thought I‚Äôd share the configuration for others to use as reference.üíÅ‚Äç‚ôÇÔ∏è Note that I‚Äôm using Docker mainly to avoid installing tooling globally. If this isn‚Äôt the case for you, then a different build strategy will likely be better.Additionally, some command lines will contain placeholders with example content {EX:like this} and optional segments [OPT:like this]. You will have to at least remove the respective parentheses and EX: or OPT: to make them work..vscode/tasks.json{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format¬π &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Create {EX:target/bundle/schichler-dev}/&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;mkdir --parents {EX:target/bundle/schichler-dev}&quot;, &quot;windows&quot;: { &quot;command&quot;: &quot;if not exist {EX:target/bundle/schichler-dev}/NUL mkdir {EX:target\\\\bundle\\\\schichler-dev}&quot; } }, { &quot;label&quot;: &quot;Build {EX:schichler-dev}&quot;, &quot;dependsOn&quot;: [ &quot;Create {EX:target/bundle/schichler-dev}/&quot; ], &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;docker build -t {EX:schichler-dev} -f {EX:schichler-dev/Dockerfile} {EX:.} &amp;amp;&amp;amp; docker run [OPT:--read-only] --mount type=bind,source=${workspaceFolder}{EX:/target/bundle/schichler-dev},destination=/mnt/target --rm {EX:schichler-dev}&quot;, // The task group shown by Tasks: Run Build Task. &quot;group&quot;: &quot;build&quot;, &quot;presentation&quot;: { // Automatically show the problems panel if any problems are matched. // The default here is &quot;never&quot;. &quot;revealProblems&quot;: &quot;onProblem&quot; }, // Prevents Code&#39;s prompt whether to show output. // This was added automatically when I selected never to. // You can add problem matchers¬≤ to make Code recognise &quot;problemMatcher&quot;: [] } ]}¬π Integrate with External Tools via Tasks; comment from default tasks.json.¬≤ See # Processing task output with problem matchers.This creates the following entry in the Tasks: Run Build Task command menu, by default bound to Ctrl + Shift + B:‚Ä¶which runs the following shell commands in dependent sequence:docker build -t {EX:schichler-dev} -f {EX:schichler-dev/Dockerfile} {EX:.}docker run [OPT:--read-only] --mount type=bind,source=${workspaceFolder}{EX:/target},destination=/mnt/target --rm {EX:schichler-dev}In my case: Make the directory (mkdir) path (--parents) target/bundle/schichler-dev, if it doesn‚Äôt exist yet (--parents). üíÅ‚Äç‚ôÇÔ∏è Windows requires special handling here, since Windows‚Äôs MKDIR will error if the directory already exists, isn‚Äôt configurable in that regard, and also doesn‚Äôt support / as path separator. CMD /E:ON /C makes sure command extensions are on (default since 2000/XP) so we can create the entire path at once. if not exist target/bundle/schichler-dev/NUL makes sure target/bundle/schichler-dev doesn‚Äôt exist as a directory already, by checking for the special file NUL within it. See https://stackoverflow.com/a/4165472.2. Build a Docker image and tag (-t) it as schichler-dev(:latest).Use the Docker file (-f) located at schichler-dev/Dockerfile¬≥ and use .‚Å¥ as context root. Run the Docker image tagged schichler-dev with its internal file system read-only (--read-only)‚Åµ, while mounting (--mount) ${workspaceFolder}/target/bundle/schichler-dev‚Å∂ mutably inside the container as /mnt/target. Remove (--rm) the container instance afterwards. ¬≥ You don‚Äôt need to specify this for a Dockerfile in the context root.‚Å¥ The folder opened in Code is the working directory for the command.‚Åµ This isn‚Äôt strictly necessary, but Docker may be able to start the container a little faster if it has a matching optimisation.‚Å∂ Full paths are required here.üíÅ‚Äç‚ôÇÔ∏è Code handily expands ${workspaceFolder} to what we need. Show the suggestions (default: Ctrl + Space) within the &quot;command&quot; parameter‚Äôs value (but only before the first such expansion, it seems) for a list of other values that can be interpolated.DockerfileEnd your (Unix) Dockerfile with:CMD rm -fr /mnt/target/* \\ &amp;amp;&amp;amp; cp -vr --no-target-directory {EX:bundle} /mnt/targetThis in my case: Removes (rm), recursively (-r), all files and directories (*) inside the mounted host directory. Copies (cp), recursively (-r), the contents of (--no-target-directory) my build directory inside the container (bundle) into the mounted host directory visible at /mnt/target inside the container.üíÅ‚Äç‚ôÇÔ∏è Instead of writing --no-target-directory, you could append /* to the source directory to use shell expansion. I don‚Äôt know whether this makes a practical difference. Running the TaskYou can now run the build task by pressing Ctrl + Shift + B and then Enter.Code should show the output of the command in a new task terminal window." } ]
