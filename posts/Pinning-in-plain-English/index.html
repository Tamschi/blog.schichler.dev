<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"> <script defer="" data-domain="blog.schichler.dev" src="https://a.schichler.dev/js/script.js"></script><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Pinning in plain English" /><meta property="og:locale" content="en" /><meta name="description" content="Mostly Rust, sometimes mainly carbohydrates." /><meta property="og:description" content="Mostly Rust, sometimes mainly carbohydrates." /><link rel="canonical" href="https://blog.schichler.dev/posts/Pinning-in-plain-English/" /><meta property="og:url" content="https://blog.schichler.dev/posts/Pinning-in-plain-English/" /><meta property="og:site_name" content="Abstraction Haven" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-24T17:10:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Pinning in plain English" /><meta name="twitter:site" content="@tammeschichler" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Mostly Rust, sometimes mainly carbohydrates.","url":"https://blog.schichler.dev/posts/Pinning-in-plain-English/","@type":"BlogPosting","headline":"Pinning in plain English","dateModified":"2022-01-08T02:01:25+01:00","datePublished":"2021-11-24T17:10:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.schichler.dev/posts/Pinning-in-plain-English/"},"@context":"https://schema.org"}</script><title>Pinning in plain English | Abstraction Haven</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Abstraction Haven"><meta name="application-name" content="Abstraction Haven"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="/assets/un-cdn/jsdelivr/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Abstraction Haven</a></div><div class="site-subtitle font-italic">Mostly Rust, sometimes mainly carbohydrates.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://ko-fi.com/tamme/" aria-label="ko-fi" target="_blank" rel="noopener" title="https://ko-fi.com/tamme/" > <i class="fas fa-coffee"></i> </a> <a href="https://tamschi.itch.io/" aria-label="itch.io" target="_blank" rel="noopener" title="https://tamschi.itch.io/" > <i class="fab fa-itch-io"></i> </a> <a href="https://github.com/Tamschi" aria-label="github" target="_blank" rel="noopener" title="https://github.com/Tamschi" > <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tamme','schichler.dev'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="xmpp:tamme@schichler.dev" aria-label="xmpp" > <i class="fas fa-comment-dots"></i> </a> <a href="https://nerdculture.de/@Tamschi" aria-label="mastodon" target="_blank" rel="noopener" title="https://nerdculture.de/@Tamschi" > <i class="fab fa-mastodon"></i> </a> <a href="https://twitter.com/tammeschichler" aria-label="twitter" target="_blank" rel="noopener" title="https://twitter.com/tammeschichler" > <i class="fab fa-twitter"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Pinning in plain English</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1298 650'%3E%3C/svg%3E" data-src="/assets/img/posts/2021-11-24-Pinning in plain English/bell pepper chirality.png" class="preview-img bg" alt="A tasty-looking orange bell pepper is sitting on a wooden cutting board in the left half of the image. The right half of the image is an exact copy of the left half, except horizontally flipped, giving the impression of a mirror plane at the centre." width="1298" height="650" data-proofer-ignore><h1 data-toc-skip>Pinning in plain English</h1><div class="post-meta text-muted"><div style="float: left; clear: left;"> By <em> <a href="https://schichler.dev/">Tamme Schichler</a> </em></div><div style="float: right; clear: right;"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/pinning/'>Pinning</a></div><div class="d-flex" style="float: left; clear: left;"><div> <span> Posted <em class="timeago" date="2021-11-24 17:10:00 +0100" data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 24, 2021, 5:10 PM +0100" >Nov 24, 2021</em> </span> <span> Updated <em class="timeago" date="2022-01-08 02:01:25 +0100 " data-toggle="tooltip" data-placement="bottom" title="Sat, Jan 8, 2022, 2:01 AM +0100" >Jan 8, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3223 words"> <em>17 min</em> read</span></div></div><div class="post-tags" style="float: right; clear: right;"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/patterns/" class="post-tag no-text-decoration" >patterns</a> <a href="/tags/api/" class="post-tag no-text-decoration" >api</a> <a href="/tags/guide/" class="post-tag no-text-decoration" >guide</a></div><div style="clear: both;"></div></div><div class="post-content"><blockquote><p>A mirrored bell pepper is still clearly the same fruit, but the mirror image, if physically placed outside the mirror, would largely only be compatible with a fundamentally different biology, as many of its more complex molecules are chiral.</p><p>It was fresh and refreshing.</p><hr /></blockquote><p>Pinning in Rust is a powerful and very convenient pattern that is, in my eyes, not supported well enough in the wider ecosystem.</p><p>A common sentiment is that it‚Äôs hard to understand and that <a href="https://doc.rust-lang.org/stable/core/pin/index.html">the pin module documentation</a> is confusing. (Personally, I think it works well as reference to answer questions about edge cases, but it‚Äôs a dense read and not necessarily a good intro text.)</p><p>This post is my attempt to make the feature more approachable, to hopefully inspire more developers to make their crates pinning-aware where that would be helpful.</p><hr /><h4 id="license-and-translations">License and Translations<a href="#license-and-translations" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>See past the end of this post. In short, this post as a whole is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/">CC BY-NC-SA 2.0</a> except for code citations explicitly marked as such. Code snippets and blocks that are <em>not</em> marked as citations are also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>.</p><p>Community translations: <a href="https://zjp-cn.github.io/translation/Pinning-in-plain-English.html">Chinese</a></p><hr /><p>Alright, on to the actual content!</p><p>Note that I‚Äôve added links to (mostly) the Rust documentation in various places.<br /> These are ‚Äúfurther reading‚Äù, so I recommend reading this post entirely before looking into them. They‚Äôll (hopefully) be much easier to understand that way around.</p><h2 id="the-problem">The Problem<a href="#the-problem" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>In Rust, any instance is considered trivially movable</strong> as long as its size is known at compile-time, which means that anyone who owns or has an <code class="language-plaintext highlighter-rouge">&amp;mut</code> (a plain exclusive reference) to an instance can copy its unstructured data (i.e. its directly contained bytes) to a different memory address, and can then expect nothing to break when they reuse the old location otherwise or use the moved instance.</p><p>Unlike in C# or JavaScript, this matters:<br /> References, pointers and addresses can be fairly readily converted between each other, and <strong>addresses (and to some extent pointers) are plain numbers that can be used in offset calculations</strong>. This makes it possible to, for example, create very efficient generic collections, as they can always store instances ‚Äúby-value‚Äù in the same allocation. If they‚Äôve run out of space to add a new item, they implicitly reallocate their storage, possibly moving their contents to a new location in memory.</p><p>However, unlike in C++ (<a href="https://en.cppreference.com/w/cpp/language/copy_constructor">1</a>, <a href="https://en.cppreference.com/w/cpp/language/move_constructor">2</a>, <a href="https://en.cppreference.com/w/cpp/language/copy_assignment">3</a>, <a href="https://en.cppreference.com/w/cpp/language/move_assignment">4</a>), <strong>there is no built-in mechanism to update pointers and addresses not known directly</strong> to the owner of an instance, <strong>or to prevent moves completely for a specific type</strong>: You can‚Äôt overload or delete the plain assignment operator <code class="language-plaintext highlighter-rouge">=</code>, and there is no concept of a <a href="https://en.cppreference.com/w/cpp/language/move_constructor">move</a> or <a href="https://en.cppreference.com/w/cpp/language/copy_constructor">copy constructor</a> that could be called when an instance is moved implicitly.</p><p>Rust-style references (<code class="language-plaintext highlighter-rouge">&amp;</code> or <code class="language-plaintext highlighter-rouge">&amp;mut</code>) are lightweight pointers with some aliasing restrictions that are always valid¬π and can‚Äôt be automatically updated from elsewhere, which in turn <strong>rules out reallocation of their target <em>entirely</em> during these borrows</strong> (but code with access to the exclusive <code class="language-plaintext highlighter-rouge">&amp;mut T</code> can still <a href="https://doc.rust-lang.org/stable/core/mem/fn.swap.html"><code class="language-plaintext highlighter-rouge">swap</code></a> instances freely).</p><p>(¬π more specifically: References are always guaranteed to be dereferenceable, which allows the compiler to load and cache their pointed-to values early in many cases. C++ makes the same dereferenceability guarantee, but allows mutable aliasing by default.)</p><p>All this together makes it tricky to write a memory-safe API that relies on the known location of an instance between calls into it, as <strong>taking continuous possession of it through ownership or a borrow would be inflexible</strong> and often inconvenient, and <strong>using an indirect handle would be too inefficient</strong> for many low-level components.</p><h2 id="pinning-tldr-simplified">Pinning TL;DR (simplified)<a href="#pinning-tldr-simplified" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Instead, <strong>Rust opts to explicitly change the visible type of a reference (and with that the API) to prevent accidental moves outside of <code class="language-plaintext highlighter-rouge">unsafe</code> code</strong>.</p><p>While there are some exceptions to this, the <em>default</em> assertion of pinning is that ‚ÄúIf a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> is accessible, then that instance of <code class="language-plaintext highlighter-rouge">T</code> will be available at that address until dropped.‚Äù</p><p>It‚Äôs possible to weaken this somewhat but, aside from when <code class="language-plaintext highlighter-rouge">T: Unpin</code>, only by using <code class="language-plaintext highlighter-rouge">unsafe</code> in some way.</p><p>Whenever a type implements <a href="https://doc.rust-lang.org/stable/core/marker/trait.Unpin.html"><code class="language-plaintext highlighter-rouge">Unpin</code></a>, pinning its instances <a href="https://doc.rust-lang.org/stable/core/pin/struct.Pin.html#impl-DerefMut">is meaningless</a> however.</p><p><strong>For simplicity, types of pinned values (in this post: <code class="language-plaintext highlighter-rouge">T</code>) are implied to be <code class="language-plaintext highlighter-rouge">!Unpin</code> for the rest of this post, unless otherwise noted.</strong> This means some sentences won‚Äôt be true if you, for example, try to pin an <code class="language-plaintext highlighter-rouge">f64</code> or a <code class="language-plaintext highlighter-rouge">struct</code> where all of its members are <code class="language-plaintext highlighter-rouge">Unpin</code>. Please keep this in mind while reading on.</p><h2 id="pin-vs-pinned">‚Äúpin‚Äù vs. ‚Äúpinned‚Äù<a href="#pin-vs-pinned" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Whenever pinning happens in Rust, there are two components involved:</p><ul><li><p>A ‚Äúpin‚Äù type that asserts ‚Äúthe value can‚Äôt be moved (by <em>safe</em> Rust)‚Äù.</p><p>This is often called a ‚Äúpinning pointer‚Äù.</p><p>Pins are very often <code class="language-plaintext highlighter-rouge">Unpin</code>, but this isn‚Äôt relevant to their function.<br /> Instead, this rule is enforced only through API constraints of the pin.</p><li><p>A <em>pinned value</em>, which can‚Äôt be moved by the consumer of an API.</p><p>This is always a specific value, not all members of a type in general, as ‚Äúpinned‚Äù is <em>not</em> an inherent property of any type.</p></ul><h2 id="pins-are-often-compounds">Pins are often compounds<a href="#pins-are-often-compounds" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>For example, look at the signature of <a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#method.pin"><code class="language-plaintext highlighter-rouge">Box::pin</code></a>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// Citation.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pin</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span> <span class="err">‚Ä¶</span> <span class="p">}</span>
</pre></table></code></div></div><p>This function pins the value <code class="language-plaintext highlighter-rouge">x</code> of type <code class="language-plaintext highlighter-rouge">T</code> behind a pinning smart pointer of type <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;_&gt;&gt;</code>.</p><p>Think of <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;_&gt;&gt;</code> as ‚Äúpinning <code class="language-plaintext highlighter-rouge">Box</code>‚Äù, and not as ‚Äú<code class="language-plaintext highlighter-rouge">Box</code> inside a <code class="language-plaintext highlighter-rouge">Pin</code>‚Äù. <code class="language-plaintext highlighter-rouge">Pin</code> is not a container that the <code class="language-plaintext highlighter-rouge">Box</code> can be <em>safely</em> taken out of (<a href="https://doc.rust-lang.org/stable/core/pin/struct.Pin.html#method.into_inner">unless <code class="language-plaintext highlighter-rouge">T: Unpin</code></a>).</p><p>Side note: A plain <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;_&gt;&gt;</code> is pinn<strong>ing</strong> but not pinn<strong>ed</strong>.<br /> In fact, <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;_&gt;&gt;</code> is always <code class="language-plaintext highlighter-rouge">Unpin</code> (because <code class="language-plaintext highlighter-rouge">Box&lt;_&gt;</code> is always <code class="language-plaintext highlighter-rouge">Unpin</code>) and as such can not be meaningfully pinned by itself.</p><p>This, including <code class="language-plaintext highlighter-rouge">Unpin</code> on the pin, is the same for all standard smart pointers and Rust references:</p><div class="table-wrapper"><table><thead><tr><th>Rust<th>English<tbody><tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;_&gt;&gt;</code><td>‚Äúpinning <code class="language-plaintext highlighter-rouge">Box</code>‚Äù<tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;Rc&lt;_&gt;&gt;</code><td>‚Äúpinning <code class="language-plaintext highlighter-rouge">Rc</code>‚Äù<tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;Arc&lt;_&gt;&gt;</code><td>‚Äúpinning <code class="language-plaintext highlighter-rouge">Arc</code>‚Äù<tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;&amp;_&gt;</code><td>‚Äúpinning (shared) reference‚Äù<tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut _&gt;</code><td>‚Äúpinning (exclusive) reference‚Äù</table></div><p>I often shorten ‚Äúpinning <code class="language-plaintext highlighter-rouge">Box</code>‚Äù to ‚Äú<code class="language-plaintext highlighter-rouge">Pin</code>-<code class="language-plaintext highlighter-rouge">Box</code>‚Äù for myself when reading silently, and you should be understood when saying it out loud like that too.</p><h2 id="unpin-is-an-auto-trait"><code class="language-plaintext highlighter-rouge">Unpin</code> is an auto trait<a href="#unpin-is-an-auto-trait" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Very few types in Rust are actually <code class="language-plaintext highlighter-rouge">!Unpin</code>. As <a href="https://doc.rust-lang.org/stable/core/marker/trait.Unpin.html"><code class="language-plaintext highlighter-rouge">Unpin</code></a> is an <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/auto-traits.html"><code class="language-plaintext highlighter-rouge">auto trait</code></a>, it is implemented for all composed types (structs, enums and unions) whose members are <code class="language-plaintext highlighter-rouge">Unpin</code> already. It‚Äôs auto-implemented for nearly all built-in types and <strong>implemented explicitly also for <a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html">pointers</a></strong>! This means that pointer wrappers like <a href="https://doc.rust-lang.org/stable/core/ptr/struct.NonNull.html"><code class="language-plaintext highlighter-rouge">NonNull</code></a> are <em>also</em> <code class="language-plaintext highlighter-rouge">Unpin</code>!</p><p>In fact, the only type that is explicitly <code class="language-plaintext highlighter-rouge">!Unpin</code> as of stable Rust 1.56, including in custom crates, is <a href="https://doc.rust-lang.org/stable/core/marker/struct.PhantomPinned.html"><code class="language-plaintext highlighter-rouge">core::marker::PhantomPinned</code></a>, a marker you can use as member type to make your custom type <code class="language-plaintext highlighter-rouge">!Unpin</code>.</p><p>You can see the full list of (non-)implementors here: <a href="https://doc.rust-lang.org/stable/core/marker/trait.Unpin.html#implementors"><code class="language-plaintext highlighter-rouge">Unpin</code>#implementors</a></p><h2 id="values-mostly-dont-start-out-pinned">Values (mostly) don‚Äôt start out pinned<a href="#values-mostly-dont-start-out-pinned" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Even for <code class="language-plaintext highlighter-rouge">T</code> where <code class="language-plaintext highlighter-rouge">T</code> is not <code class="language-plaintext highlighter-rouge">Unpin</code>, a plain instance of <code class="language-plaintext highlighter-rouge">T</code> on the stack or accessible through a plain <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is not yet pinned. This also means it could be discarded without running its destructor, by calling <a href="https://doc.rust-lang.org/stable/core/mem/fn.forget.html"><code class="language-plaintext highlighter-rouge">mem::forget</code></a> with it as parameter for example.</p><p>An instance of <code class="language-plaintext highlighter-rouge">T</code> only becomes pinned when passed to a function like <code class="language-plaintext highlighter-rouge">Box::pin</code> that makes <a href="https://doc.rust-lang.org/stable/core/pin/index.html#drop-guarantee">these guarantees</a> (and ideally exposes <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> somehow, as necessary).</p><h2 id="function-of-pin_">Function of <code class="language-plaintext highlighter-rouge">Pin&lt;_&gt;</code><a href="#function-of-pin_" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The only differences between <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code> are that:</p><ul><li><p><code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code> never exposes <code class="language-plaintext highlighter-rouge">&amp;mut T</code> or a plain <code class="language-plaintext highlighter-rouge">T</code>,</p><p>so moving the value elsewhere is impossible.</p><li><p><code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code> exposes <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>.</p><p>This is called ‚Äúpin projection‚Äù (towards the stored value).</p><p>Getting access to these pinning references lets you call methods on the value that require <code class="language-plaintext highlighter-rouge">self: Pin&lt;&amp;Self&gt;</code> or <code class="language-plaintext highlighter-rouge">self: Pin&lt;&amp;mut Self&gt;</code>, and also associated functions with similar argument types.</p></ul><p>The plain <code class="language-plaintext highlighter-rouge">&amp;T</code> value reference is accessible like before, and can also be found as such by dereferencing <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code>, regardless of whether <code class="language-plaintext highlighter-rouge">T</code> is <code class="language-plaintext highlighter-rouge">Unpin</code>.</p><p><strong>All</strong> smart pointers and references that are <a href="https://doc.rust-lang.org/stable/core/ops/trait.Deref.html"><code class="language-plaintext highlighter-rouge">Deref&lt;Target = T&gt;</code></a> (and optionally, for mutable access, <a href="https://doc.rust-lang.org/stable/core/ops/trait.DerefMut.html"><code class="language-plaintext highlighter-rouge">DerefMut</code></a>) function <em>exactly</em> like this when pinning.</p><p>In order to keep the rest of the post easy to read:</p><p><strong>Definitions</strong> (valid in this post only):</p><div class="table-wrapper"><table><thead><tr><th>Shorthand<th>implied constraint<th>English<tbody><tr><td><code class="language-plaintext highlighter-rouge">T</code><td><strong>not</strong> <code class="language-plaintext highlighter-rouge">T: Unpin</code><td>‚Äú[arbitrary] type‚Äù / ‚Äú[arbitrary] value‚Äù<tr><td>a pinned <code class="language-plaintext highlighter-rouge">T</code><td><strong>not</strong> <code class="language-plaintext highlighter-rouge">T: Unpin</code><td>‚Äúa pinned value‚Äù<tr><td><code class="language-plaintext highlighter-rouge">P</code><td><code class="language-plaintext highlighter-rouge">P: Deref&lt;Target = T&gt;</code>,<br />optionally <code class="language-plaintext highlighter-rouge">P: DerefMut</code><td>‚Äúpointer‚Äù<tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code><td><code class="language-plaintext highlighter-rouge">P: Deref&lt;Target = T&gt;</code>,<br />optionally <code class="language-plaintext highlighter-rouge">P: DerefMut</code><td>‚Äúpinning pointer‚Äù</table></div><h2 id="pinning-is-a-compile-time-only-concept">Pinning is a compile-time-only concept<a href="#pinning-is-a-compile-time-only-concept" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code> is a <a href="https://doc.rust-lang.org/stable/reference/type-layout.html#the-transparent-representation"><code class="language-plaintext highlighter-rouge">#[repr(transparent)]</code></a> wrapper around its single member, a private field with type <code class="language-plaintext highlighter-rouge">P</code>.</p><p>In other words:</p><p><strong><code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code> (for example) has the exact same runtime representation as <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>.</strong></p><p>Since <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> in turn has the same runtime representation as its derived <code class="language-plaintext highlighter-rouge">&amp;T</code>, dereferencing <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code> to arrive at <code class="language-plaintext highlighter-rouge">&amp;T</code> is an identity function that returns the exact same value it started out from, which means (but only with optimisations!) no runtime operation is necessary at all.</p><p>Converting a pointer or container into its pinning version is an equally free action.</p><p>This is possible because moves in Rust are already pretty explicit once references are involved: The underlying assignment maybe be hidden inside another method, but there is no system that will move heap instances around without being told to do so (unlike for example in C#, where pinning is a runtime operation <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.gchandletype?view=net-6.0">integrated into the GC API</a>.)</p><p>The only exception to this, where a <code class="language-plaintext highlighter-rouge">&amp;</code>-referenced instance‚Äôs copy can appear with a new address implicitly, are types that are <a href="https://doc.rust-lang.org/stable/core/marker/trait.Copy.html"><code class="language-plaintext highlighter-rouge">Copy</code></a>. This trait isn‚Äôt <a href="https://doc.rust-lang.org/unstable-book/language-features/auto-traits.html"><code class="language-plaintext highlighter-rouge">auto</code></a>, which means it must be derived explicitly for each type for which implicit trivial copies should be available.</p><p>(Side-note: Don‚Äôt implement <code class="language-plaintext highlighter-rouge">Copy</code> on types where identity matters at all. Deriving <a href="https://doc.rust-lang.org/stable/core/clone/trait.Clone.html"><code class="language-plaintext highlighter-rouge">Clone</code></a> is usually enough.<br /> <code class="language-plaintext highlighter-rouge">Copy</code> is largely convenience for immutable instances that you want to pass by value a lot, so for example <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html"><code class="language-plaintext highlighter-rouge">Cell</code></a> does not implement it even if the underlying type does.)</p><h2 id="pinning-is-a-matter-of-perspective">Pinning is a matter of perspective<a href="#pinning-is-a-matter-of-perspective" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>A value becomes pinned by making it impossible for safe Rust to move the instance or free its memory without dropping it first. (A pin giving safe Rust access to <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> or <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code> asserts this formally, especially towards <code class="language-plaintext highlighter-rouge">T</code>‚Äôs unrelated implementation.)</p><p>However, as the type of the pinned instance itself does not change, it can remain visible ‚Äúunpinned‚Äù inside the module that implements a pin in the first place.</p><p><em><code class="language-plaintext highlighter-rouge">Pin&lt;_&gt;</code> hides the normal mutable API only through encapsulation, but can‚Äôt erase it entirely.</em></p><p>This is especially true for pins with <a href="https://doc.rust-lang.org/core/cell/index.html">interior mutability</a> or composed of non-pinning fields, since they will normally share much of their implementation between the non-pinning and pinning API.</p><p>Safe code inside such modules will (currently) often handle <code class="language-plaintext highlighter-rouge">&amp;mut T</code> while a derived <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> could have been presented outwards before, and extra care must be taken to avoid unsound moves in that case.<br /> This may change in the future as more pinning pointers and collections become available and if Rust makes it easier to add methods to custom types wrapped in <code class="language-plaintext highlighter-rouge">Pin&lt;_&gt;</code>.</p><h2 id="collections-can-pin">Collections can pin<a href="#collections-can-pin" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This is most obvious with <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> or <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code> where the <code class="language-plaintext highlighter-rouge">Box</code> acts as 1-item collection of <code class="language-plaintext highlighter-rouge">T</code>. The same can be said about these types with ‚Äú<code class="language-plaintext highlighter-rouge">Arc</code>‚Äù and ‚Äú<code class="language-plaintext highlighter-rouge">Rc</code>‚Äù instead of ‚Äú<code class="language-plaintext highlighter-rouge">Box</code>‚Äù.</p><p>As such, <strong>it makes sense to also pay attention to <code class="language-plaintext highlighter-rouge">C</code> where <code class="language-plaintext highlighter-rouge">C</code> is a collection of items of type <code class="language-plaintext highlighter-rouge">T</code></strong>.</p><p>It‚Äôs likewise possible to use <code class="language-plaintext highlighter-rouge">Pin</code> to create a new type <code class="language-plaintext highlighter-rouge">Pin&lt;C&gt;</code> that behaves similarly to how a pinning smart pointer would, by giving out neither <code class="language-plaintext highlighter-rouge">&amp;mut T</code> or <code class="language-plaintext highlighter-rouge">T</code>.</p><p><strong>Definitions</strong> (valid in this post only):</p><div class="table-wrapper"><table><thead><tr><th>Shorthand<th>implied constraint<th>English<tbody><tr><td><code class="language-plaintext highlighter-rouge">C</code><td>owns instances of type <code class="language-plaintext highlighter-rouge">T</code><td>‚Äúcollection‚Äù<tr><td><code class="language-plaintext highlighter-rouge">Pin&lt;C&gt;</code><td>owns instances of type <code class="language-plaintext highlighter-rouge">T</code><td>‚Äúpinning collection‚Äù</table></div><p>(The standard library doesn‚Äôt have many utilities for this, as general collections are much more diverse than smart pointers. If you decide to write a pinning-aware collection, you will have to implement much of the API yourself and, as of Rust 1.56, may have to provide extension methods through traits to make calling it seamless.)</p><p>A collection <code class="language-plaintext highlighter-rouge">C</code> ‚Äúcan pin‚Äù if it allows some projection from its pinned form (<code class="language-plaintext highlighter-rouge">&amp;Pin&lt;C&gt;</code> or <code class="language-plaintext highlighter-rouge">&amp;mut Pin&lt;C&gt;</code>) to <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> and optionally to <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>.</p><p>A collection may also be <em>inherently</em> pinning, in which case it will act like <code class="language-plaintext highlighter-rouge">Pin&lt;C&gt;</code> without <code class="language-plaintext highlighter-rouge">Pin</code> appearing in the type. We won‚Äôt look at this kind of collection directly here.</p><h2 id="pinp-vs-pinc-vs-t"><code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code> vs. <code class="language-plaintext highlighter-rouge">Pin&lt;C&gt;</code> vs. <code class="language-plaintext highlighter-rouge">T</code><a href="#pinp-vs-pinc-vs-t" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>How plain (non-pinning) pointers and collections behave should be clear enough, so I‚Äôll only compare how their and <code class="language-plaintext highlighter-rouge">T</code>‚Äôs API <em>tend to</em> differ when they are pinning or pinned:</p><div class="table-wrapper"><table><thead><tr><th>¬†<th><code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code><th><code class="language-plaintext highlighter-rouge">Pin&lt;C&gt;</code><th><code class="language-plaintext highlighter-rouge">T</code> behind <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> or <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code><tbody><tr><td>English<td>‚Äúpinning pointer‚Äù<td>‚Äúpinning collection‚Äù<td>‚Äúpinned value‚Äù<tr><td><code class="language-plaintext highlighter-rouge">: Unpin</code><td>nearly always<td>very often<td>rarely in practice, as pinning with <code class="language-plaintext highlighter-rouge">T: Unpin</code> is meaningless.<tr><td>APIs accessible<br />vs. without pinning<td>Access to <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code><br />and optionally <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code><td>varies,<br />but often similar to <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code><td>Functions that require <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> or <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code><tr><td>APIs inaccessible<br />after pinning<td>Access to <code class="language-plaintext highlighter-rouge">&amp;mut T</code>,<br />unwrapping <code class="language-plaintext highlighter-rouge">T</code><td>varies, but usually:<br />Access to <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, removing <code class="language-plaintext highlighter-rouge">T</code>,<br />anything that would reallocate <code class="language-plaintext highlighter-rouge">T</code><td>Functions that require <code class="language-plaintext highlighter-rouge">&amp;mut T</code><tr><td>Unchanged APIs<br />(examples)<td>Access to <code class="language-plaintext highlighter-rouge">&amp;T</code><td>Access to <code class="language-plaintext highlighter-rouge">&amp;T</code>,<br />dropping <code class="language-plaintext highlighter-rouge">T</code> in place<td>Functions that require <code class="language-plaintext highlighter-rouge">&amp;T</code><tr><td><code class="language-plaintext highlighter-rouge">: Clone</code><td>usually<td>possibly<br /><code class="language-plaintext highlighter-rouge">where T: Clone</code>¬π<td>varies</table></div><p>¬π If implemented that way, then <code class="language-plaintext highlighter-rouge">pub fn clone_unpinning(this: &amp;Pin&lt;Self&gt;) -&gt; Self { ‚Ä¶ }</code> can also be implemented. However, if <code class="language-plaintext highlighter-rouge">T: Clone</code>, then it‚Äôs likely that <code class="language-plaintext highlighter-rouge">T</code> is also <code class="language-plaintext highlighter-rouge">Unpin</code>, which makes pinning pretty much useless.<br /> See the end of this post for a more useful implementation that can clone meaningfully pinned instances also.</p><h2 id="which-functions-require-pint">Which functions require <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code>?<a href="#which-functions-require-pint" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>How <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code> are used varies, but there are three broad categories most cases fall into:</p><h3 id="avoiding-reference-counting">Avoiding reference-counting<a href="#avoiding-reference-counting" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>If smart pointers to an instance are copied often but accessed rarely, and references cannot be used because their lifetime can‚Äôt be constrained statically, then it makes sense to shift the runtime cost from cloning the pointers into a validity check on access instead. The smart pointers are replaced by copiable handles, in this case.</p><p>How do the handles know when their target has disappeared? Pinning a <code class="language-plaintext highlighter-rouge">T</code> asserts that <code class="language-plaintext highlighter-rouge">&lt;T as Drop&gt;::drop</code> will run <em>for that particular instance</em>, so there will be an opportunity to notify a longer-lived registry.</p><p>This also enables use cases where the handles cannot be dropped explicitly, like if they are stored directly by an arena allocator like <a href="https://crates.io/crates/bumpalo"><code class="language-plaintext highlighter-rouge">bumpalo</code></a>. You can see an example of this pattern in my crate <a href="https://docs.rs/lignin/0.1/lignin/"><code class="language-plaintext highlighter-rouge">lignin</code></a>, which supports (V)DOM callbacks this way.</p><h3 id="embedding-externally-managed-data">Embedding externally-managed data<a href="#embedding-externally-managed-data" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>My crate <a href="https://lib.rs/crates/tiptoe"><code class="language-plaintext highlighter-rouge">tiptoe</code></a> stores its smart pointers‚Äô reference counts directly inside the hosted value instances. Pinning allows them to still expose an exclusive reference as <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>.</p><p>You can read more about intrusive reference-counting and the heap-only pattern it enables in this earlier post: <a href="https://blog.schichler.dev/intrusive-smart-pointers-heap-only-types-ckvzj2thw0caoz2s1gpmi1xm8">Intrusive Smart Pointers + Heap Only Types = üíû</a></p><h3 id="persisting-self-references">Persisting self-references<a href="#persisting-self-references" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Consider the following <a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html"><code class="language-plaintext highlighter-rouge">async</code></a> block:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">async</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"Hello, future!"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
	<span class="nf">yield_once</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
	<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This code creates an opaquely-typed <a href="https://doc.rust-lang.org/stable/core/future/trait.Future.html"><code class="language-plaintext highlighter-rouge">Future</code></a> instance that will, at least formally, contain a reference to another of its fields after it is <a href="https://doc.rust-lang.org/stable/core/future/trait.Future.html#the-poll-method">polled</a> for the first time.</p><p>The instance won‚Äôt be externally borrowed anymore at that time, but moving it would break the private reference <code class="language-plaintext highlighter-rouge">b</code> to <code class="language-plaintext highlighter-rouge">a</code>, so <code class="language-plaintext highlighter-rouge">Future::poll(‚Ä¶)</code> requires <code class="language-plaintext highlighter-rouge">self: Pin&lt;&amp;mut Self&gt;</code> as receiver.</p><p>This ensures that instances of <code class="language-plaintext highlighter-rouge">impl Future</code> will only enter such a state when they are already guaranteed not to be moved again. If an executor does need to move <code class="language-plaintext highlighter-rouge">Future</code>s, it can require <code class="language-plaintext highlighter-rouge">Future + Unpin</code> instead, <a href="https://doc.rust-lang.org/stable/core/pin/struct.Pin.html#method.new">which allows converting <code class="language-plaintext highlighter-rouge">&amp;mut _</code> to <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut _&gt;</code> on the fly</a>.</p><p>Side note: Pinning is a huge deal for safe <code class="language-plaintext highlighter-rouge">async</code> performance! <em>As even instances of eventually self-referential <code class="language-plaintext highlighter-rouge">impl Future</code>s start out unpinned, they are directly composable</em> without workarounds like lifting their state onto the heap on demand. This results in less fragmentation, less unusual control flow and smaller code size (before inlining, at least) in the generated state machines, all of which makes it much easier to evaluate them quickly. (Or rather: It raises the ceiling for what an async runtime can reasonably achieve, as it won‚Äôt be held back by generated code it has no control over. While a simple async runtime is fairly easy to write in Rust, great ones are schedulers that operate very ‚Äúclose to the metal‚Äù and as such are often strongly affected by hardware quirks. Their development is quite interesting to follow.)</p><h2 id="weakening-non-moveability">Weakening non-moveability<a href="#weakening-non-moveability" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>For the final section of this post, let‚Äôs take a step back and look at the initial pinning guarantee again.</p><p>While pinned instances can‚Äôt be moved safely by other <em>unrelated</em> code, it‚Äôs still often possible to provide functions like the following:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cd">/// Swaps two pinned instances, making adjustments as necessary.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">swap</span><span class="p">(</span>
	<span class="n">a</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span>
	<span class="n">b</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span> <span class="err">‚Ä¶</span> <span class="p">}</span>
</pre></table></code></div></div><p>As <code class="language-plaintext highlighter-rouge">swap</code> has access to <code class="language-plaintext highlighter-rouge">Self</code>‚Äôs private fields (and can rely on internal implementation details regarding how <code class="language-plaintext highlighter-rouge">Self</code> makes use of pinning <em>exactly</em>), it‚Äôs able to patch any self-referential or global instance registry pointers as necessary during the exchange.</p><p>It‚Äôs also possible to similarly recreate the rest of C++‚Äôs address-aware value movement infrastructure, as pointed out by Miguel Young in April in <a href="https://mcyoung.xyz/2021/04/26/move-ctors/#towards-move-constructors-copy-constructors">Move Constructors in Rust: Is it possible?</a> and implemented in the <a href="https://docs.rs/moveit/0.3.0/moveit/"><code class="language-plaintext highlighter-rouge">moveit</code></a> crate.</p><p>In addition to a Rust program more nicely interfacing with C++ this way, pinning collections can also use <code class="language-plaintext highlighter-rouge">moveit</code>‚Äôs <a href="https://docs.rs/moveit/0.3.0/moveit/trait.MoveNew.html"><code class="language-plaintext highlighter-rouge">MoveNew</code></a> and <a href="https://docs.rs/moveit/0.3.0/moveit/trait.CopyNew.html"><code class="language-plaintext highlighter-rouge">CopyNew</code></a> traits to port part of their non-pinning API to their pinning interface in a more Rust-like fashion:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_pin</span><span class="p">(</span>
		<span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
	<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;</span>
	<span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">MoveNew</span> <span class="p">{</span>
		<span class="nd">todo!</span><span class="p">(</span><span class="s">"Potentially reallocate existing items."</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_pinned</span><span class="p">(</span>
		<span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
	<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;</span>
	<span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">MoveNew</span> <span class="p">{</span>
		<span class="nd">todo!</span><span class="p">(</span><span class="s">"Potentially reallocate existing items, move new item."</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Careful: This also enables `Clone` for `Pin&lt;C&lt;T&gt;&gt;`!</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CopyNew</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
		<span class="nd">todo!</span><span class="p">(</span><span class="s">"Clone items in an address-aware way."</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Collections with stable backing storage can often accept new values regardless of whether they are currently pinning, but a pinning <a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html"><code class="language-plaintext highlighter-rouge">Vec</code></a>-like for example sometimes has to reallocate and as such must allow its values to patch pointers to expand arbitrarily.</p><p>The <code class="language-plaintext highlighter-rouge">CopyNew</code> trait can be implemented more broadly than the standard <a href="https://doc.rust-lang.org/stable/core/clone/trait.Clone.html"><code class="language-plaintext highlighter-rouge">Clone</code></a>, which can‚Äôt be used where internal pointers or certain types of back-reference may exist (e.g. non-owning ‚Äúmulticast‚Äù-like references to the instance in question).</p><hr /><h2 id="thanks">Thanks<a href="#thanks" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>To <a href="https://hashnode.com/@TheBerkin">Robin Pederson</a> and <a href="https://hashnode.com/@telios">telios</a> for proof-reading and various suggestions on how to improve clarity, and to <a href="https://github.com/jimkoen">Milou</a> for criticism and suggestions from a C++ perspective.</p><h2 id="license-and-translations-in-detail">License and Translations (in detail)<a href="#license-and-translations-in-detail" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This post as a whole with exception of citations is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/">CC BY-NC-SA 2.0</a>. All code samples (that is: code blocks and snippets formatted <code class="language-plaintext highlighter-rouge">like this</code>), except for citations, are additionally licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>, so that you can freely use them in your projects under any license or no license.</p><p>Citations from official Rust projects retain their original <code class="language-plaintext highlighter-rouge">MIT OR Apache-2.0</code> license and are used as permitted at <a href="https://www.rust-lang.org/policies/licenses">https://www.rust-lang.org/policies/licenses</a>. Sorry about the complexity here, unfortunately my country barely recognises fair use.</p><p>If you translate this post, please let me know so that I can link it <a href="#license-and-translations">above</a>. I should be able to post a German translation myself before long.</p><p>(I suggest using the same license structure for code snippets in translations as here, though this is not something I can enforce. If a translation uses a different license, you can likely still take the code you need from the original here under CC0.)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/pinning/'>Pinning</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/patterns/" class="post-tag no-text-decoration" >patterns</a> <a href="/tags/api/" class="post-tag no-text-decoration" >api</a> <a href="/tags/guide/" class="post-tag no-text-decoration" >guide</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper">This post is <a href="https://creativecommonsusa.org/wp-content/uploads/2018/01/Copyright-and-Open-Licensing-Primer.pdf">not licensed</a> for any purpose, unless otherwise noted.<br> It is provided AS IS without any guarantee of correctness beyond those required for legal reasons.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Pinning in plain English - Abstraction Haven&url=https://blog.schichler.dev/posts/Pinning-in-plain-English/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Pinning in plain English - Abstraction Haven&u=https://blog.schichler.dev/posts/Pinning-in-plain-English/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Pinning in plain English - Abstraction Haven&url=https://blog.schichler.dev/posts/Pinning-in-plain-English/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Asteracea/">Asteracea (as of right now) üåº</a><li><a href="/posts/Moving/">Moving</a><li><a href="/posts/Some-thoughts-on-Bubble/">Some thoughts on Bubble</a><li><a href="/posts/Cheese-olive-dish/">Cheese-olive dish</a><li><a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/">Intrusive Smart Pointers + Heap Only Types = üíû</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/"><div class="card-body"> <em class="timeago small" date="2020-10-31 16:10:00 +0100" >Oct 31, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Semantic FFI Bindings in Rust - Reactivating the Borrow Checker</h3><div class="text-muted small"><p> In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks ...</p></div></div></a></div><div class="card"> <a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/"><div class="card-body"> <em class="timeago small" date="2021-11-14 18:44:00 +0100" >Nov 14, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Intrusive Smart Pointers + Heap Only Types = üíû</h3><div class="text-muted small"><p> In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomati...</p></div></div></a></div><div class="card"> <a href="/posts/Asteracea/"><div class="card-body"> <em class="timeago small" date="2022-05-14 15:25:00 +0200" >May 14, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Asteracea (as of right now) üåº</h3><div class="text-muted small"><p> This is a relatively high-level summary post of design decisions I made so far while implementing Asteracea and its related packages like the lignin group of crates. I‚Äôm making this post partially ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/" class="btn btn-outline-primary" prompt="Older"><p>Intrusive Smart Pointers + Heap Only Types = üíû</p></a> <a href="/posts/Cheese-olive-dish/" class="btn btn-outline-primary" prompt="Newer"><p>Cheese-olive dish</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> ¬© 2024 <a href="https://schichler.dev/">Tamme Schichler</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are not licensed for redistribution by the author. (Feel free to save a copy for personal use, though. You likely don't even need permission for that.)">Most rights reserved.</span> <br> <a href="https://impressum.schichler.dev/">Impressum/Imprint, Datenschutz</a></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="/assets/un-cdn/jsdelivr/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/un-cdn/jsdelivr/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/un-cdn/jsdelivr/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
