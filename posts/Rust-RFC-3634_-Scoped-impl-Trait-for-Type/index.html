<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"> <script defer="" data-domain="blog.schichler.dev" src="https://a.schichler.dev/js/script.js"></script><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Rust RFC 3634: Scoped impl Trait for Type" /><meta property="og:locale" content="en" /><meta name="description" content="I just posted my first Rust RFC. Hopefully it‚Äôs received well even though it‚Äôs on a relatively tough topic üòÖ" /><meta property="og:description" content="I just posted my first Rust RFC. Hopefully it‚Äôs received well even though it‚Äôs on a relatively tough topic üòÖ" /><link rel="canonical" href="https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/" /><meta property="og:url" content="https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/" /><meta property="og:site_name" content="Abstraction Haven" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-12T18:20:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Rust RFC 3634: Scoped impl Trait for Type" /><meta name="twitter:site" content="@tammeschichler" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"I just posted my first Rust RFC. Hopefully it‚Äôs received well even though it‚Äôs on a relatively tough topic üòÖ","url":"https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/","@type":"BlogPosting","headline":"Rust RFC 3634: Scoped impl Trait for Type","dateModified":"2024-05-12T18:20:00+02:00","datePublished":"2024-05-12T18:20:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/"},"@context":"https://schema.org"}</script><title>Rust RFC 3634: Scoped <code>impl Trait for Type</code> | Abstraction Haven</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Abstraction Haven"><meta name="application-name" content="Abstraction Haven"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="/assets/un-cdn/jsdelivr/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Abstraction Haven</a></div><div class="site-subtitle font-italic">Mostly Rust, sometimes mainly carbohydrates.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://ko-fi.com/tamme/" aria-label="ko-fi" target="_blank" rel="noopener" title="https://ko-fi.com/tamme/" > <i class="fas fa-coffee"></i> </a> <a href="https://tamschi.itch.io/" aria-label="itch.io" target="_blank" rel="noopener" title="https://tamschi.itch.io/" > <i class="fab fa-itch-io"></i> </a> <a href="https://github.com/Tamschi" aria-label="github" target="_blank" rel="noopener" title="https://github.com/Tamschi" > <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tamme','schichler.dev'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="xmpp:tamme@schichler.dev" aria-label="xmpp" > <i class="fas fa-comment-dots"></i> </a> <a href="https://nerdculture.de/@Tamschi" aria-label="mastodon" target="_blank" rel="noopener" title="https://nerdculture.de/@Tamschi" > <i class="fab fa-mastodon"></i> </a> <a href="https://twitter.com/tammeschichler" aria-label="twitter" target="_blank" rel="noopener" title="https://twitter.com/tammeschichler" > <i class="fab fa-twitter"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Rust RFC 3634: Scoped <code>impl Trait for Type</code></span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Rust RFC 3634: Scoped <code>impl Trait for Type</code></h1><div class="post-meta text-muted"><div style="float: left; clear: left;"> By <em> <a href="https://schichler.dev/">Tamme Schichler</a> </em></div><div style="float: right; clear: right;"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/language-design/'>Language Design</a></div><div class="d-flex" style="float: left; clear: left;"><div> <span> Posted <em class="timeago" date="2024-05-12 18:20:00 +0200" data-toggle="tooltip" data-placement="bottom" title="Sun, May 12, 2024, 6:20 PM +0200" >May 12</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="22068 words"> <em>122 min</em> read</span></div></div><div class="post-tags" style="float: right; clear: right;"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rust/" class="post-tag no-text-decoration" >Rust</a> <a href="/tags/traits/" class="post-tag no-text-decoration" >traits</a> <a href="/tags/composition/" class="post-tag no-text-decoration" >composition</a> <a href="/tags/rfc/" class="post-tag no-text-decoration" >RFC</a></div><div style="clear: both;"></div></div><div class="post-content"><p>I just posted my first Rust RFC. Hopefully it‚Äôs received well even though it‚Äôs on a relatively tough topic üòÖ</p><p>For posterity, you can find the full text I initially submitted below.<br /> Non-grammar blockquotes are less-formal comments I added as further explanations.</p><p>I may edit this post eventually to include the correct Rust Issue link (if the RFC is merged), <sub>or to fix embarrassing typos,</sub> but for the most up-to-date version please see the ‚ÄòRFC PR‚Äô linked just below this.</p><p>The rendered GitHub version may be a bit easier to navigate, too, as subheadings appear in the navigation there.<br /> You can show the table of contents using the button at the very right of the sticky header on GitHub.</p><p><strong>Thanks</strong></p><ul><li>to <a href="https://github.com/teliosdev">@teliosdev</a> for some very early syntax feedback that helped put me on track,<li>to <a href="https://github.com/cofinite">@cofinite</a> for pointing out how scoped implementations allow syntax traits to be used as extension traits,<li>to <a href="https://github.com/thefakeplace">@thefakeplace</a> and to SkiFire13 in the <a href="https://internals.rust-lang.org/t/pre-rfc-scoped-impl-trait-for-type/19923">draft discussion</a> for suggestions on how to make this RFC more approachable and easier to understand.</ul><p><br /></p><hr /><ul><li>Feature Name: <code class="language-plaintext highlighter-rouge">scoped_impl_trait_for_type</code><li>Start Date: 2024-05-12<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3634">rust-lang/rfcs#3634</a><li>Rust Issue: (to be added if merged)</ul><h1 id="summary">Summary</h1><p>This proposal adds scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> items into the core language, as coherent but orphan-rule-free alternative to implementing traits globally. It also extends the syntax of <code class="language-plaintext highlighter-rouge">use</code>-declarations to allow importing these scoped implementations into other item scopes (including other crates), and differentiates type identity of most generics by which scoped trait implementations are available to each discretised generic type parameter (also adding syntax to specify differences to these captured <em>implementation environments</em> directly on generic type arguments).</p><p>This (along with some details specified below) enables any crate to</p><ul><li>locally, in item scopes, implement nearly any trait for any expressible type,<li>publish these trivially composable implementations to other crates,<li>import and use such implementations safely and seamlessly and<li>completely ignore this feature when it‚Äôs not needed*.</ul><p>* aside from one hopefully very obscure <code class="language-plaintext highlighter-rouge">TypeId</code> edge case that‚Äôs easy to accurately lint for.</p><p>This document uses ‚Äúscoped implementation‚Äù and ‚Äúscoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>‚Äù interchangeably. As such, the former should always be interpreted to mean the latter below.</p><h1 id="motivation">Motivation</h1><p>While orphan rules regarding trait implementations are necessary to allow crates to add features freely without fear of breaking dependent crates, they limit the composability of third party types and traits, especially in the context of derive macros.</p><p>For example, while many crates support <code class="language-plaintext highlighter-rouge">serde::{Deserialize, Serialize}</code> directly, implementations of the similarly-derived <code class="language-plaintext highlighter-rouge">bevy_reflect::{FromReflect, Reflect}</code> traits are less common. Sometimes, a <code class="language-plaintext highlighter-rouge">Debug</code>, <code class="language-plaintext highlighter-rouge">Clone</code> or (maybe only contextually sensible) <code class="language-plaintext highlighter-rouge">Default</code> implementation for a field is missing to derive those traits. While crates like Serde often do provide ways to supply custom implementations for fields, this usually has to be restated on each such field. Additionally, the syntax for doing so tends to differ between derive macro crates.</p><p>Wrapper types, commonly used as workaround, add clutter to call sites or field types, and introduce mental overhead for developers as they have to manage distinct types without associated state transitions in order to work around the issues laid out in this section. They also require a distinct implementation for each combination of traits and lack discoverability through tools like rust-analyzer.</p><p>Another pain point are sometimes missing <code class="language-plaintext highlighter-rouge">Into&lt;&gt;</code>-conversions when propagating errors with <code class="language-plaintext highlighter-rouge">?</code>, even though one external residual (payload) type may (sometimes <em>contextually</em>) be cleanly convertible into another. As-is, this usually requires a custom intermediary type, or explicit conversion using <code class="language-plaintext highlighter-rouge">.map_err(|e| ‚Ä¶)</code> (or an equivalent function/extension trait). If an appropriate <code class="language-plaintext highlighter-rouge">From&lt;&gt;</code>-conversion can be provided <em>in scope</em>, then just <code class="language-plaintext highlighter-rouge">?</code> can be used.</p><p>This RFC aims to address these pain points by creating a new path of least resistance that is easy to use and very easy to teach, intuitive to existing Rust-developers, readable without prior specific knowledge, discoverable as needed, has opportunity for rich tooling support in e.g. rust-analyzer and helpful error messages, is quasi-perfectly composable including decent re-use of composition, improves maintainability and (slightly) robustness to major-version dependency changes compared to newtype wrappers, and does not restrict crate API evolution, compromise existing coherence rules or interfere with future developments like specialisation. Additionally, it allows the implementation of more expressive (but no less explicit) extension APIs using syntax traits like in the <code class="language-plaintext highlighter-rouge">PartialEq&lt;&gt;</code>-example below, without complications should these traits be later implemented in the type-defining crate.</p><p>For realistic examples of the difference this makes, please check the <a href="#rationale-and-alternatives">rationale-and-alternatives</a> section.</p><h1 id="guide-level-explanation">Guide-level explanation</h1><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> can be introduced in The Book alongside global trait implementations and mentioned in the standard library documentation examples.</p><p>For example, the following changes could be made:</p><h2 id="102-traits-defining-shared-behavior"><strong>10.2.</strong> Traits: Defining Shared Behavior<a href="#102-traits-defining-shared-behavior" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The following sections are added after <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a>:</p><h3 id="scoped-implementation-of-a-trait-on-a-type">Scoped Implementation of a Trait on a Type<a href="#scoped-implementation-of-a-trait-on-a-type" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Independently of implementing a trait on a type or set of types <em>globally</em>, it‚Äôs possible to do so only for the current scope, by adding the <code class="language-plaintext highlighter-rouge">use</code> keyword:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With the exception of very few traits related to language features, you can implement any visible trait on any visible type this way, even if both are defined in other crates.</p><p>In other words: The <em>orphan rule</em> does not apply to scoped implementations. Instead, item shadowing is used to determine which implementation to use.</p><p><em>Scoped implementations are intended mainly as compatibility feature</em>, to let third party crates provide glue code for other crate combinations. To change the behaviour of an instance or a set of instances from their default, consider using <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">the newtype pattern</a> instead.</p><h3 id="publishing-and-importing-scoped-implementations">Publishing and Importing Scoped Implementations<a href="#publishing-and-importing-scoped-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>You can also publish a scoped implementation further by adding a visibility before <code class="language-plaintext highlighter-rouge">use</code> ‚Ä¶:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">unsafe</span> <span class="k">impl</span> <span class="n">UnsafeTrait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>‚Ä¶ and import it into other scopes:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">other_module</span><span class="p">::{</span>
    <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">,</span>
    <span class="k">impl</span> <span class="n">UnsafeTrait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Note that the scoped implementation of <code class="language-plaintext highlighter-rouge">UnsafeTrait</code> is imported without the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword. <strong>It is the implementing crate‚Äôs responsibility to ensure the exported <code class="language-plaintext highlighter-rouge">unsafe</code> implementation is sound everywhere it is visible!</strong></p><p>Generic parameters, bounds and <code class="language-plaintext highlighter-rouge">where</code>-clauses can be used as normal in each of these locations, though you usually have to brace <code class="language-plaintext highlighter-rouge">impl&lt;/*...*/&gt; Trait for Type where /*...*/</code> individually in <code class="language-plaintext highlighter-rouge">use</code>-declarations.</p><p>You can import a subset of a generic implementation, by narrowing bounds or replacing type parameters with concrete types in the <code class="language-plaintext highlighter-rouge">use</code>-declaration.</p><p>Global implementations can be imported from the root namespace, for example to shadow a scoped implementation:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="p">::{</span><span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">};</span>
</pre></table></code></div></div><h3 id="scoped-implementations-and-generics">Scoped implementations and generics<a href="#scoped-implementations-and-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Scoped implementations are resolved on most generics‚Äô type arguments where those are specified, and become part of the (now less generic) host type‚Äôs identity:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait_fn</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Trait</span><span class="o">&gt;</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">type_fn</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">T</span><span class="p">::</span><span class="nf">trait_fn</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">nested</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Trait</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>

    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">trait_fn</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"nested"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">Type</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">nested</span><span class="p">::</span><span class="n">Alias</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">Alias</span><span class="p">::</span><span class="nf">type_fn</span><span class="p">();</span> <span class="c1">// "nested"</span>

    <span class="c1">// Type::&lt;()&gt;::type_fn();</span>
    <span class="c1">//             ^^^^^^^ error[E0599]: the function or associated item `type_fn` exists for struct `Type&lt;()&gt;`, but its trait bounds were not satisfied</span>

    <span class="c1">// let t: Type&lt;()&gt; = Alias::default();</span>
    <span class="c1">//                   ^^^^^^^^^ error[E0308]: mismatched types</span>

    <span class="k">let</span> <span class="n">t</span><span class="p">:</span> <span class="n">Type</span><span class="o">&lt;</span><span class="p">()</span> <span class="k">as</span> <span class="n">Trait</span> <span class="n">in</span> <span class="n">nested</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Alias</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This works equally not just for type aliases but also fields, <code class="language-plaintext highlighter-rouge">let</code>-bindings and also where generic type parameters are inferred automatically from expressions (for example to call a constructor).</p><p>Note that some utility types, like references, tuples, <code class="language-plaintext highlighter-rouge">Option</code>, <code class="language-plaintext highlighter-rouge">Result</code> and closure traits, do not bind implementations eagerly but only when used to specify another generic. You can find a list of these types in the reference. (‚Üê i.e. ‚Äúinsert link here‚Äù.)</p><h2 id="192-advanced-traits"><strong>19.2.</strong> Advanced Traits<a href="#192-advanced-traits" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The section <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a> is updated to mention scoped implementations, to make them more discoverable when someone arrives from an existing community platform answer regarding orphan rule workarounds. It should also mention that newtypes are preferred over scoped implementations when use of the type is semantically different, to let the type checker distinguish it from others.</p><p>A new section is added:</p><h3 id="using-scoped-implementations-to-implement-external-traits-on-external-types">Using Scoped Implementations to Implement External Traits on External Types<a href="#using-scoped-implementations-to-implement-external-traits-on-external-types" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Since scoped implementations allow crates to reusably implement external traits on external types, they can be used to provide API extensions that make use of syntactic sugar. For example:</p><p>Filename: fruit-comparer/src/lib.rs</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">apples</span><span class="p">::</span><span class="n">Apple</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">oranges</span><span class="p">::</span><span class="n">Orange</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Orange</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Apple</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Orange</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">todo!</span><span class="p">(</span><span class="s">"Figure out how to compare apples and oranges."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Orange</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Orange</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">todo!</span><span class="p">(</span><span class="s">"Figure out how to compare oranges and apples."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Filename: src/main.rs</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">apples</span><span class="p">::</span><span class="n">Apple</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">oranges</span><span class="p">::</span><span class="n">Orange</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">fruit_comparer</span><span class="p">::{</span>
    <span class="k">impl</span> <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Orange</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Apple</span><span class="p">,</span>
    <span class="k">impl</span> <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Orange</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">apple</span> <span class="o">=</span> <span class="nn">Apple</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">orange</span> <span class="o">=</span> <span class="nn">Orange</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Compiles:</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="n">apple</span> <span class="o">==</span> <span class="n">orange</span><span class="p">);</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="n">orange</span> <span class="o">==</span> <span class="n">apple</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If the type whose API was extended this way later gains the same trait inherently, that is not a problem as the consuming code continues to use <code class="language-plaintext highlighter-rouge">fruit_comparer</code>‚Äôs scoped implementation. However, a warning (<a href="#global-trait-implementation-available">global-trait-implementation-available</a>) is shown by default to alert the maintainers of each crate of the covering global implementation.</p><p>Be careful about literal coercion when using generic traits this way! For example, if a scoped implementation of <code class="language-plaintext highlighter-rouge">Index&lt;isize&gt;</code> is used and a global <code class="language-plaintext highlighter-rouge">Index&lt;usize&gt;</code> implementation is added later on the same type, the compiler will <em>not</em> automatically decide which to use for integer literal indices between these two.</p><h2 id="rustdoc-documentation-changes">Rustdoc documentation changes<a href="#rustdoc-documentation-changes" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="use-and-impl-keywords"><code class="language-plaintext highlighter-rouge">use</code> and <code class="language-plaintext highlighter-rouge">impl</code> keywords<a href="#use-and-impl-keywords" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The documentation pages <a href="https://doc.rust-lang.org/stable/std/keyword.use.html">for the <code class="language-plaintext highlighter-rouge">use</code> keyword</a> and <a href="https://doc.rust-lang.org/stable/std/keyword.impl.html">for the <code class="language-plaintext highlighter-rouge">impl</code> keyword</a> are adjusted to (very) briefly demonstrate the respective scoped use of <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>.</p><h3 id="typeid"><code class="language-plaintext highlighter-rouge">TypeId</code><a href="#typeid" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The page for <a href="https://doc.rust-lang.org/stable/std/any/struct.TypeId.html"><code class="language-plaintext highlighter-rouge">TypeId</code></a> gains two sections with the following information:</p><div class="language-markdown highlighter-rouge"><div class="code-header"> <span label-text="Markdown"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="gh"># `TypeId` and scoped implementations</span>

To make sure that that are no mix-ups between, for example, <span class="sb">`HashSet&lt;T&gt;`</span> and
<span class="sb">`HashSet&lt;T as Hash in module&gt;`</span>, any such difference implies distinct <span class="sb">`TypeId`</span>s between
such discretised generics (and that the types are not mutually assignable).

This also affects trait-bounded generic type parameters: If <span class="sb">`T`</span> is bounded on <span class="sb">`Hash`</span>, then
<span class="sb">`TypeId::of::&lt;T&gt;()`</span> results in distinct <span class="sb">`TypeId`</span>s in that context depending on the
captured implementation.

However, note that <span class="sb">`TypeId::of::&lt;T&gt;()`</span> and <span class="sb">`TypeId::of::&lt;T as Hash in module&gt;()`</span> are
always equivalent for one definition of <span class="sb">`T`</span>, as <span class="sb">`TypeId::of`</span>'s implementation does <span class="gs">**not**</span>
have a <span class="sb">`T: Hash`</span> bound!

For convenience (so that their values are easily interchangeable across crates), the
following types ignore scoped implementations <span class="ge">*on*</span> their generic arguments in terms of
<span class="ge">*their own*</span> type identity: [‚Ä¶]

Despite this, differences in <span class="ge">*type arguments'*</span> discrete identities (for example from
scoped implementations captured <span class="ge">*in*</span> them) distinguish the type identity of <span class="ge">*all*</span>
discretised generics they appear in.

<span class="gh"># `TypeId::of::&lt;Self&gt;()` may change for values of generics</span>

To make type-erased collections sound and unsurprising by default, it's sound to transmute
between instances of an external generic type that differ only in their captured scoped
implementations, <span class="gs">**iff and only iff**</span> no inconsistency is ever observed by bounds
(including across separate function calls).

However, this poses a problem: <span class="sb">`TypeId::of::&lt;Self&gt;()`</span> (just like the written-out form of
any type that doesn't ignore scoped implementations) takes <span class="ge">*all*</span> differences in captured
implementation environments into account, not just those relevant to trait bounds.

As such, prefer <span class="sb">`TypeId::of::&lt;T&gt;()`</span> whenever possible in order to make only the
distinctions you require. You can use tuples to combine multiple type parameters without
over-distinguishing: <span class="sb">`TypeId::of::&lt;(S, T)&gt;()`</span>
</pre></table></code></div></div><blockquote><p>These rules and the reasons for them are explained in detail in the <a href="#reference-level-explanation">reference-level-explanation</a> below, as well as in <a href="#logical-consistency">logical-consistency</a> as part of <a href="#rationale-and-alternatives">rationale-and-alternatives</a>. It may be a good idea to link to similar longer explanations from the standard library docs above, even if just as ‚ÄúSee also:‚Äù-style references for further reading.</p></blockquote><blockquote><p>The <code class="language-plaintext highlighter-rouge">[‚Ä¶]</code>-placeholder stands for a list of links to each implementation-invariant generic‚Äôs documentation.</p></blockquote><p>See also <a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters</a> for a way to narrowly alert users of this when relevant, and to scan for the potential impact of these changes ahead of time.</p><h3 id="implementation-invariant-generics">Implementation-invariant generics<a href="#implementation-invariant-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The pages for <a href="#implementation-invariant-generics">implementation-invariant-generics</a> gain a section similar to the following:</p><div class="language-markdown highlighter-rouge"><div class="code-header"> <span label-text="Markdown"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="gh"># Implementation-invariant generic</span>

This type does not by itself capture scoped implementation environments when discretised.
See [<span class="sb">`TypeId`</span> and scoped implementations] for more information.
</pre></table></code></div></div><p>where <code class="language-plaintext highlighter-rouge">[`TypeId` and scoped implementations]</code> is a link to the section added to the <code class="language-plaintext highlighter-rouge">TypeId</code> page above.</p><h3 id="memtransmute"><code class="language-plaintext highlighter-rouge">mem::transmute</code><a href="#memtransmute" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The page for <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code class="language-plaintext highlighter-rouge">transmute</code></a> gains a section with the following information:</p><div class="language-markdown highlighter-rouge"><div class="code-header"> <span label-text="Markdown"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="gh"># `transmute` and scoped implementations</span>

It is sound to transmute between discretised generic types that differ only in their
captured scoped implementation environments, <span class="gs">**but only iff**</span> such differences are
<span class="gs">**never**</span> observed by bounds on their implementation, including functions that imply such
by being implemented for discrete instances of the generic.
</pre></table></code></div></div><blockquote><p>As far as I can tell, this is only practically relevant for certain kinds of type-erasing collections, like type-erasing hash maps and B-trees, of which I couldn‚Äôt find any examples on crates.io.</p><p>Any straightforward implementations of such collections should also at worst exhibit only unexpected behaviour when consumed in the presence of scoped implementations, rather than unsoundness.</p></blockquote><h2 id="changes-to-the-rustonomicon">Changes to The Rustonomicon<a href="#changes-to-the-rustonomicon" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The page on <a href="https://doc.rust-lang.org/stable/nomicon/transmutes.html">Transmutes</a> gains the following warning in addition to the existing ones:</p><div class="language-markdown highlighter-rouge"><div class="code-header"> <span label-text="Markdown"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="p">-</span> It is unsound to change [captured scoped implementations] via transmute for any external
  type if this change ever causes a contradiction observable by the transmuted value's
  implementation.

  This can happen due to bounds on called functions and/or because a called function is
  implemented for a specific type discretised from the generic.
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">[captured scoped implementations]</code> should link to documentation introducing scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>.</p><h1 id="reference-level-explanation">Reference-level explanation</h1><h2 id="grammar-changes">Grammar changes<a href="#grammar-changes" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The core Rust language grammar is extended as follows:</p><ul><li><p><a href="https://doc.rust-lang.org/reference/items/implementations.html?highlight=TraitImpl#implementations"><em>TraitImpl</em></a>‚Äôs definition is prepended with (<em>Visibility</em><sup>?</sup> <code class="language-plaintext highlighter-rouge">use</code>)<sup>?</sup> and refactored for partial reuse to arrive at</p><blockquote><p><em>TraitImpl</em>¬†:<br /> ‚ÄÉ <strong>(<em>Visibility</em><sup>?</sup> <code class="language-plaintext highlighter-rouge">use</code>)<sup>?</sup></strong> <code class="language-plaintext highlighter-rouge">unsafe</code><sup>?</sup> <strong><em>TraitCoverage</em></strong><br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">{</code><br /> ‚ÄÉ‚ÄÉ <em>InnerAttribute</em><sup>*</sup><br /> ‚ÄÉ‚ÄÉ <em>AssociatedItem</em><sup>*</sup><br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">}</code></p><p><strong><em>TraitCoverage</em></strong>¬†:<br /> ‚ÄÉ <strong><em>TraitCoverageNoWhereClause</em></strong><br /> ‚ÄÉ <em>WhereClause</em><sup>?</sup></p><p><strong><em>TraitCoverageNoWhereClause</em></strong>¬†:<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">impl</code> <em>GenericParams</em><sup>?</sup> <code class="language-plaintext highlighter-rouge">!</code><sup>?</sup> <em>TypePath</em> <code class="language-plaintext highlighter-rouge">for</code> <em>Type</em></p></blockquote><p>where a trait implementation with that <code class="language-plaintext highlighter-rouge">use</code>-prefix provides the implementation <em>only</em> as item in the containing item scope.</p><p>(This can be distinguished from <code class="language-plaintext highlighter-rouge">use</code>-declarations with a lookahead up to and including <code class="language-plaintext highlighter-rouge">impl</code> or <code class="language-plaintext highlighter-rouge">unsafe</code>, meaning at most four shallowly tested token trees with I believe no groups. No other lookaheads are introduced into the grammar by this RFC.)</p><p><strong>The scoped implementation defined by this item is implicitly always in scope for its own definition.</strong> This means that it‚Äôs not possible to refer to any shadowed implementation inside of it (including generic parameters and where clauses), except by re-importing specific scoped implementations inside nested associated functions. Calls to generic functions cannot be used as backdoor either (see <a href="#type-parameters-capture-their-implementation-environment">type-parameters-capture-their-implementation-environment</a>).</p><li><p><a href="https://doc.rust-lang.org/reference/items/use-declarations.html?highlight=UseTree#use-declarations"><em>UseTree</em></a>‚Äôs definition is extended for importing scoped implementations by inserting the extracted <em>TraitCoverage</em> and <em>TraitCoverageNoWhereClause</em> rules as follows:</p><blockquote><p><em>UseTree</em>¬†:<br /> ‚ÄÉ (<em>SimplePath</em><sup>?</sup> <code class="language-plaintext highlighter-rouge">::</code>)<sup>?</sup> <code class="language-plaintext highlighter-rouge">*</code><br /> ‚ÄÇ | (<em>SimplePath</em><sup>?</sup> <code class="language-plaintext highlighter-rouge">::</code>)<sup>?</sup> <code class="language-plaintext highlighter-rouge">{</code><br /> ‚ÄÉ (<br /> ‚ÄÉ‚ÄÉ (<strong>(</strong>‚Äç<em>UseTree</em> <strong>| <em>TraitCoverageNoWhereClause</em>)</strong> (<code class="language-plaintext highlighter-rouge">,</code> <strong>(</strong>‚Äç<em>UseTree</em> <strong>| <em>TraitCoverageNoWhereClause</em>)</strong>)* <strong>(</strong><code class="language-plaintext highlighter-rouge">,</code> <strong><em>TraitCoverage</em><sup>?</sup>)</strong><sup>?</sup>)<sup>?</sup><br /> ‚ÄÉ‚ÄÇ <strong>| <em>TraitCoverage</em></strong><br /> ‚ÄÉ )<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">}</code><br /> ‚ÄÇ | <em>SimplePath</em> (<code class="language-plaintext highlighter-rouge">as</code> (IDENTIFIER | <code class="language-plaintext highlighter-rouge">_</code>))<sup>?</sup></p></blockquote><p>Allowing a trailing <em>TraitCoverage</em> with <em>WhereClause</em> in a braced list is intended for ergonomics, but rustfmt should brace it individually by default, then append a trailing comma where applicable as usual. A ‚Äò<code class="language-plaintext highlighter-rouge">,</code>‚Äô in the <em>WhereClause</em> here is not truly ambiguous because <em>WhereClauseItem</em>s contain ‚Äò<code class="language-plaintext highlighter-rouge">:</code>‚Äô, but allowing that ahead of others would likely be visually confusing and tricky to implement (requiring an arbitrarily long look-ahead). Alternatively to allowing a trailing <em>TraitCoverage</em> in mixed lists, an error similar to <a href="https://doc.rust-lang.org/error_codes/E0178.html">E0178</a> could be emitted.</p><blockquote><p>Allowing unbraced imports like <code class="language-plaintext highlighter-rouge">use some_crate::impl&lt;A, B&gt; Trait&lt;A&gt; for Type&lt;B&gt; where A: Debug, B: Debug;</code> would break the source code‚Äôs visual hierarchy quite badly, so I won‚Äôt suggest it here, but it is possible without ambiguity too. If that is added for convenience, then I‚Äôm strongly in favour of rustfmt bracing the <em>TraitCoverage</em> by default and rust-analyzer suggesting it only braced.</p></blockquote><p>Here, <em>TraitCoverage</em> imports the specified scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> for binding and conflict checks as if defined in the scope containing the <code class="language-plaintext highlighter-rouge">use</code>-declaration. The resulting visibility is taken from <em>UseDeclaration</em>, like with <em>SimplePath</em>-imported items.</p><p><em>TraitCoverage</em> must be fully covered by the scoped implementation visible in the source module. Otherwise, a compile-error occurs explaining the uncovered case (similarly to the current error(s) for missing trait implementations).</p><p><strong><em>TraitCoverage</em> may subset the source module‚Äôs implementation</strong> by having narrower bounds or using concrete types in place of one or more generic type parameters. This causes only the specified subset of the scoped implementation to be imported.</p><p>Note that scoped implementations of <code class="language-plaintext highlighter-rouge">unsafe</code> traits are imported without <code class="language-plaintext highlighter-rouge">unsafe</code>. It is the exporting crate‚Äôs responsibility to ensure a scoped implementation is sound everywhere it is visible.</p><p>Other elements of the coverage must match the source module‚Äôs implementation exactly, unless specified otherwise.</p><li><p><a href="https://doc.rust-lang.org/reference/items/generics.html?highlight=TypeParam#generic-parameters"><em>TypeParam</em></a>, <a href="https://doc.rust-lang.org/reference/paths.html?highlight=GenericArg#paths-in-expressions"><em>GenericArg</em></a> and <a href="https://doc.rust-lang.org/reference/paths.html?highlight=GenericArgsBinding#paths-in-expressions"><em>GenericArgsBinding</em></a> are extended to accept <em>implementation environments</em> inline:</p><blockquote><p><em>TypeParam</em>¬†:<br /> ‚ÄÉ IDENTIFIER ( <code class="language-plaintext highlighter-rouge">:</code> <em>TypeParamBounds</em><sup>?</sup> )<sup>?</sup> ( <code class="language-plaintext highlighter-rouge">=</code> <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong> )<sup>?</sup></p><p><em>GenericArg</em>¬†:<br /> ‚ÄÉ <em>Lifetime</em> | <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong> | <em>GenericArgsConst</em> | <em>GenericArgsBinding</em></p><p><em>GenericArgsBinding</em>¬†:<br /> ‚ÄÉ IDENTIFIER <code class="language-plaintext highlighter-rouge">=</code> <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong></p><p><strong><em>ImplEnvironment</em>¬†:</strong><br /> <strong>‚ÄÉ <code class="language-plaintext highlighter-rouge">as</code> ( <em>ImplEnvironmentEntry</em> ( <code class="language-plaintext highlighter-rouge">+</code> <em>ImplEnvironmentEntry</em> )* <code class="language-plaintext highlighter-rouge">+</code><sup>?</sup> )<sup>?</sup></strong></p><p><strong><em>ImplEnvironmentEntry</em>¬†:</strong><br /> <strong>‚ÄÉ (</strong><br /> <strong>‚ÄÉ‚ÄÉ <em>ForLifetimes</em><sup>?</sup> <em>TypePath</em></strong><br /> <strong>‚ÄÉ‚ÄÇ | ( <em>ForLifetimes</em><sup>?</sup> <em>TypePath</em> )</strong><br /> <strong>‚ÄÉ )</strong><br /> <strong>‚ÄÉ <code class="language-plaintext highlighter-rouge">in</code> ( <code class="language-plaintext highlighter-rouge">::</code> | <em>SimplePath</em> )</strong></p></blockquote><p>When detecting conflicting implementations, the <em>ImplEnvironment</em> is treated as creating a distinct scope nested in its surrounding scope. Each resulting <em>implementation environment</em> must be conflict-free, but between them they <em>can</em> contain conflicting implementations.</p><p>Even when an <em>ImplEnvironment</em> is added as above, the resulting <em>implementation environment</em> still captures scoped implementations from the surrounding scope for all traits that were not specified inline! A global implementation can be used explicitly by sourcing it from <code class="language-plaintext highlighter-rouge">::</code> instead of a module.</p><p>For stability reasons (against relaxation of bounds) and because they matter for type identity, explicit inline <em>implementation environments</em> should be allowed where no matching bound is present, but should produce an <a href="#unused-scoped-implementation">unused-scoped-implementation</a> warning iff neither published nor used in the same crate (including for type identity distinction).</p><blockquote><p>Whether inline <em>implementation environments</em> would inherit from each other is intentionally left unspecified, as identical types can‚Äôt be nested without indirection, which ensures such a situation isn‚Äôt relevant.</p></blockquote><li><p>Further type specification syntax is extended as follows:</p><blockquote><p><em>ParenthesizedType</em>¬†:<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">(</code> <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong> <code class="language-plaintext highlighter-rouge">)</code></p><p><em>TupleType</em>¬†:<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">)</code><br /> ‚ÄÇ | <code class="language-plaintext highlighter-rouge">(</code> ( <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong> <code class="language-plaintext highlighter-rouge">,</code> )<sup>+</sup> <strong>(</strong> <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup> )</strong><sup>?</sup> <code class="language-plaintext highlighter-rouge">)</code></p><p><em>ArrayType</em>¬†:<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">[</code> <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong> <code class="language-plaintext highlighter-rouge">;</code> <em>Expression</em> <code class="language-plaintext highlighter-rouge">]</code></p><p><em>SliceType</em>¬†:<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">[</code> <em>Type</em> <strong><em>ImplEnvironment</em><sup>?</sup></strong> <code class="language-plaintext highlighter-rouge">]</code></p></blockquote><blockquote><p>Closure types are not extended with <em>ImplEnvironment</em> because <em>implementation environments</em> annotated on their parameters would never be effective.</p><p>Extending <em>ParenthesizedType</em> this way is necessary to specify <em>implementation environments</em> for pointer types‚Äô generic type parameters, e.g. <code class="language-plaintext highlighter-rouge">&amp;(Type as Trait in module)</code>.</p></blockquote><li><p><a href="https://doc.rust-lang.org/reference/paths.html?highlight=QualifiedPathType#qualified-paths"><em>QualifiedPathType</em></a> is also extended for this purpose, but can additionally act as <em>implementation environment</em> scope that also affects the <em>implementation environment</em> of nested types, using a clause starting with <code class="language-plaintext highlighter-rouge">where</code>:</p><blockquote><p><em>QualifiedPathType</em>¬†:<br /> ‚ÄÉ <code class="language-plaintext highlighter-rouge">&lt;</code> <em>Type</em> ( <code class="language-plaintext highlighter-rouge">as</code> <em>TypePath</em> <strong>(<code class="language-plaintext highlighter-rouge">in</code> (<code class="language-plaintext highlighter-rouge">::</code> | <em>SimplePath</em> ) )<sup>?</sup></strong> )<sup>?</sup> <strong>( <code class="language-plaintext highlighter-rouge">where</code> ( <em>Type</em> <em>ImplEnvironment</em> <code class="language-plaintext highlighter-rouge">,</code> )* ( <em>Type</em> <em>ImplEnvironment</em> )<sup>?</sup> )<sup>?</sup></strong> <code class="language-plaintext highlighter-rouge">&gt;</code></p></blockquote><p>The form <code class="language-plaintext highlighter-rouge">&lt;Type as Trait in module&gt;</code> is syntactic sugar for <code class="language-plaintext highlighter-rouge">&lt;(Type as Trait in module) as Trait&gt;</code>, to avoid repetition of potentially long traits.</p><p>Implementations imported after <code class="language-plaintext highlighter-rouge">where</code> must be valid, but don‚Äôt necessarily have to be relevant.</p><blockquote><p>I am <strong>not</strong> confident that <code class="language-plaintext highlighter-rouge">where</code> is the right keyword here, but it seems like this best option among the already-existing ones. <code class="language-plaintext highlighter-rouge">use</code>-syntax feels far too verbose here. Maybe the above but with <code class="language-plaintext highlighter-rouge">using</code> or <code class="language-plaintext highlighter-rouge">with</code> in place of <code class="language-plaintext highlighter-rouge">where</code>?</p></blockquote></ul><h2 id="no-scoped-impl-trait-for-type-of-auto-traits-copy-and-drop">No scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> of auto traits, <code class="language-plaintext highlighter-rouge">Copy</code> and <code class="language-plaintext highlighter-rouge">Drop</code><a href="#no-scoped-impl-trait-for-type-of-auto-traits-copy-and-drop" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Implementations of auto traits state guarantees about private implementation details of the covered type(s), which an external implementation can almost never do soundly.</p><p><code class="language-plaintext highlighter-rouge">Copy</code> is not an auto trait, but implementing it on a smart pointer like <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> would immediately be unsound. As such, this trait must be excluded from all external implementations.</p><p>Shadowing <code class="language-plaintext highlighter-rouge">Drop</code> for types that are <code class="language-plaintext highlighter-rouge">!Unpin</code> is similarly unsound without cooperation of the original crate (in addition to likely causing memory leaks in this and more cases).</p><h2 id="no-scoped-impl-trait-for-type">No scoped <code class="language-plaintext highlighter-rouge">impl !Trait for Type</code><a href="#no-scoped-impl-trait-for-type" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Any negative scoped implementation like for example</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="k">impl</span> <span class="o">!</span><span class="nb">Sync</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
</pre></table></code></div></div><p>is syntactically valid, but rejected by the compiler with a specific error. (See <a href="#negative-scoped-implementation">negative-scoped-implementation</a>.)</p><p>This also applies to <code class="language-plaintext highlighter-rouge">impl Trait</code>s in <code class="language-plaintext highlighter-rouge">use</code>-declarations (even though the items they would import cannot be defined anyway. Having a specific error saying that this <em>isn‚Äôt possible</em> would be much clearer than one saying that the imported item doesn‚Äôt exist).</p><h2 id="no-external-scoped-implementations-of-sealed-traits">No external scoped implementations of sealed traits<a href="#no-external-scoped-implementations-of-sealed-traits" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Consider this library crate:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">mod</span> <span class="n">private</span> <span class="p">{</span>
    <span class="c1">// Implemented only on traits that are also `Sealed`.</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Sealing</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">private</span><span class="p">::</span><span class="n">Sealing</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Sealed</span><span class="p">:</span> <span class="n">Sealing</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">assumed</span> <span class="p">{</span>
        <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Sealed</span><span class="o">&gt;</span> <span class="n">Generic</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">assuming</span> <span class="p">{</span>
        <span class="c1">// ‚ù∂</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In this crate, any code at ‚ù∂ is currently allowed to make safety-critical assumptions about code at ‚ù∑ and other implementations of <code class="language-plaintext highlighter-rouge">assumed</code>.</p><p>To ensure this stays sound, scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> where <code class="language-plaintext highlighter-rouge">Trait</code> is external requires that all supertraits of <code class="language-plaintext highlighter-rouge">Trait</code> are visible to the crate defining the scoped implementation or are defined not in <code class="language-plaintext highlighter-rouge">Trait</code>‚Äôs definition crate (meaning they must still be exported from a crate somewhere in the dependency tree).</p><p>See also <a href="#scoped-implementation-of-external-sealed-trait">scoped-implementation-of-external-sealed-trait</a>.</p><h2 id="type-parameters-capture-their-implementation-environment">Type parameters capture their <em>implementation environment</em><a href="#type-parameters-capture-their-implementation-environment" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>When a type parameter is specified, either explicitly or inferred from an expression, it captures a view of <em>all</em> implementations that are applicable to its type there. This is called the type parameter‚Äôs <em>implementation environment</em>.</p><p>(For trait objects, associated types are treated as type parameters for the purposes of this proposal.)</p><p>When implementations are resolved on the host type, bounds on the type parameter can only be satisfied according to this captured view. This means that implementations on generic type parameters are ‚Äòbaked‚Äô into discretised generics and can be used even in other modules or crates where this discretised type is accessible (possibly because a value of this type is accessible). Conversely, additional or changed implementations on a generic type parameter in an already-discretised type <em>cannot</em> be provided anywhere other than where the type parameter is specified.</p><p>When a generic type parameter is used to discretise another generic, the captured environment is the one captured in the former but overlaid with modifications applicable to that generic type parameter‚Äôs opaque type.</p><p>Note that type parameter defaults too capture their <em>implementation environment</em> where they are specified, so at the initial definition site of the generic. This environment is used whenever the type parameter default is used.</p><p>In order to avoid too much friction, <a href="#implementation-invariant-generics">implementation-invariant-generics</a> are exempt from acting as host for <em>implementation environments</em> on their own.</p><h2 id="type-identity-of-discrete-types">Type identity of discrete types<a href="#type-identity-of-discrete-types" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The type identity and <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;‚Ä¶&gt;()</code> of discrete types, including discretised generics, are not affected by scoped implementations <em>on</em> them.</p><h2 id="type-identity-of-generic-types">Type identity of generic types<a href="#type-identity-of-generic-types" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="implementation-aware-generics">Implementation-aware generics<a href="#implementation-aware-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Generics that are not <a href="#implementation-invariant-generics">implementation-invariant-generics</a> are implementation-aware generics.</p><p>The type identity of implementation-aware generic types is derived from the types specified for their type parameters as well as the <em>full</em> <em>implementation environment</em> of each of their type parameters and their associated types:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">identical</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">fn</span> <span class="n">nested_convertible</span><span class="o">&lt;</span><span class="n">U</span><span class="p">:</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">mod1</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::{</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Trait</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span> <span class="c1">// Private implementation, but indirectly published through `Alias1`.</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias1</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">mod2</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::{</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Trait</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>
    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span> <span class="c1">// Public implementation.</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias2</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">mod3</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::{</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Trait</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">mod2</span><span class="p">::{</span><span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">};</span> <span class="c1">// Reused implementation.</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias3</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">mod4</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::{</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Trait</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>
    <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span> <span class="c1">// Irrelevant top-level implementation.</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias4</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">mod5</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::{</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>
    <span class="c1">// No implementation.</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias5</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">mod1</span><span class="p">::</span><span class="n">Alias1</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">mod2</span><span class="p">::</span><span class="n">Alias2</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">mod3</span><span class="p">::</span><span class="n">Alias3</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">mod4</span><span class="p">::</span><span class="n">Alias4</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">mod5</span><span class="p">::</span><span class="n">Alias5</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="n">TypeId</span><span class="p">;</span>

    <span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="n">Conv</span><span class="p">;</span>

    <span class="c1">// Distinct implementations produce distinct types.</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias1</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias2</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias1</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias3</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Types with identical captured implementation environments are still the same type.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias2</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias3</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Top-level implementations are not part of type identity.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias4</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias5</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// If the type is distinct, then values aren't assignable.</span>
    <span class="c1">// Alias1::identical(Alias2::default());</span>
    <span class="c1">//                   ^^^^^^^^^^^^^^^^^ error[E0308]: mismatched types</span>

    <span class="c1">// Fulfilled using the global reflexive `impl&lt;T&gt; Into&lt;T&gt; for T` on `Type`,</span>
    <span class="c1">// as from its perspective, the binding is stripped due to being top-level.</span>
    <span class="nn">Alias1</span><span class="p">::</span><span class="nf">nested_convertible</span><span class="p">(</span><span class="nn">Alias2</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>

    <span class="c1">// The reflexive `impl&lt;T&gt; Into&lt;T&gt; for T` does not apply between the aliases here,</span>
    <span class="c1">// as the distinct capture in the type parameter affects its inherent identity.</span>
    <span class="c1">// (It's unfortunately not possible to generically implement this conversion without specialisation.)</span>
    <span class="c1">// Alias1::default().conv::&lt;Alias2&gt;();</span>
    <span class="c1">//                   ^^^^ error[E0277]: the trait bound `Generic&lt;Type as Trait in mod2&gt;: From&lt;Generic&lt;Type as Trait in mod1&gt;&gt;&gt;` is not satisfied</span>

    <span class="c1">// Identical types are interchangeable.</span>
    <span class="nn">Alias2</span><span class="p">::</span><span class="nf">identical</span><span class="p">(</span><span class="nn">Alias3</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>
    <span class="nn">Alias4</span><span class="p">::</span><span class="nf">identical</span><span class="p">(</span><span class="nn">Alias5</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As mentioned in <a href="#type-identity-of-discrete-types">type-identity-of-discrete-types</a>, implementations on the generic type <em>itself</em> do <em>not</em> affect its type identity, as can be seen with <code class="language-plaintext highlighter-rouge">Alias4</code> above.</p><p>The <code class="language-plaintext highlighter-rouge">TypeId</code> of these generics varies alongside their identity. Note that due to the transmutation permission defined in <a href="#layout-compatibility">layout-compatibility</a>, consumer code is effectively allowed to change the <code class="language-plaintext highlighter-rouge">TypeId</code> of instances of generics between calls to generic implementations in most cases. Due to this, implementations of generics that manage types at runtime should usually rely on the <a href="#typeid-of-generic-type-parameters-opaque-types">typeid-of-generic-type-parameters-opaque-types</a> or <code class="language-plaintext highlighter-rouge">(‚Ä¶,)</code>-tuple-types combining them instead of on <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;Self&gt;()</code>. (see also <a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters</a>)</p><p>(For a practical example, see <a href="#of-generic-collections">logical-consistency</a>.)</p><h3 id="implementation-invariant-generics-1">Implementation-invariant generics<a href="#implementation-invariant-generics-1" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The following generics that never rely on the consistency of trait implementations on their type parameters are implementation-invariant:</p><ul><li><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code> (references),<li><code class="language-plaintext highlighter-rouge">*const T</code>, <code class="language-plaintext highlighter-rouge">*mut T</code> (pointers),<li><code class="language-plaintext highlighter-rouge">[T; N]</code>, <code class="language-plaintext highlighter-rouge">[T]</code> (arrays and slices),<li><code class="language-plaintext highlighter-rouge">(T,)</code>, <code class="language-plaintext highlighter-rouge">(T, U, ..)</code> (tuples),<li><em>superficially</em>* <code class="language-plaintext highlighter-rouge">fn(T) -&gt; U</code> and similar (function pointers),<li><em>superficially</em>* <code class="language-plaintext highlighter-rouge">Fn(T) -&gt; U</code>, <code class="language-plaintext highlighter-rouge">FnMut(T) -&gt; U</code>, <code class="language-plaintext highlighter-rouge">FnOnce(T) -&gt; U</code>, <code class="language-plaintext highlighter-rouge">Future&lt;Output = T&gt;</code>, <code class="language-plaintext highlighter-rouge">Iterator&lt;Item = T&gt;</code>, <code class="language-plaintext highlighter-rouge">std::ops::Coroutine</code> and similar (closures),<li><code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>, <code class="language-plaintext highlighter-rouge">NonNull&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code>**.</ul><p>Implementation-invariant generics never capture <em>implementation environments</em> on their own. Instead, their effective <em>implementation environments</em> follow that of their host, acting as if they were captured in the same scope.</p><p>The type identity of implementation-invariant generics seen on their own does not depend on the <em>implementation environment</em>. This also means that the <code class="language-plaintext highlighter-rouge">TypeId</code> of <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> does not take into account differences of implementations <em>on</em> <code class="language-plaintext highlighter-rouge">T</code>. However, differences of implementations <em>in</em> <code class="language-plaintext highlighter-rouge">T</code> can still distinguish the types, in cases where the type identity (and possibly <code class="language-plaintext highlighter-rouge">TypeId</code>) of <code class="language-plaintext highlighter-rouge">T</code> <em>itself</em> are different. An example for this are generic type parameters‚Äô effective types that can have bounds-relevant implementations observably baked into them.</p><p>Hosts are:</p><ul><li>Type aliases (see <a href="#type-aliases-are-opaque-to-scoped-implementations">type-aliases-are-opaque-to-scoped-implementations</a>),<li><a href="#implementation-aware-generics">implementation-aware-generics</a>,<li>types written as <em>QualifiedPathType</em> (see <a href="#grammar-changes">grammar-changes</a> to <em>QualifiedPathType</em>) and<li>the <em>function operand</em> of <a href="https://doc.rust-lang.org/reference/expressions/call-expr.html#call-expressions">call expressions</a> (see <a href="#call-expressions-function-operand-captures-its-implementation-environment">call-expressions-function-operand-captures-its-implementation-environment</a>).</ul><p>* superficially: The underlying instance may well use a captured implementation internally, but this isn‚Äôt surfaced in signatures. For example, a closure defined where <code class="language-plaintext highlighter-rouge">usize: PartialOrd in reverse + Ord in reverse</code> is just <code class="language-plaintext highlighter-rouge">FnOnce(usize)</code> but will use <code class="language-plaintext highlighter-rouge">usize: PartialOrd in reverse + Ord in reverse</code> privately when called.</p><p>** but see <a href="#which-structs-should-be-implementation-invariant">which-structs-should-be-implementation-invariant</a>.</p><p>See also <a href="#why-specific-implementation-invariant-generics">why-specific-implementation-invariant-generics</a>.</p><h2 id="call-expressions-function-operand-captures-its-implementation-environment">Call expressions‚Äô <em>function operand</em> captures its <em>implementation environment</em><a href="#call-expressions-function-operand-captures-its-implementation-environment" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Call expressions capture the <em>implementation environment</em> in their <em>function operand</em>, acting as host for <a href="#implementation-invariant-generics">implementation-invariant-generics</a>. This enables call expressions such as</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nn">Option</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Type</span> <span class="k">as</span> <span class="n">Debug</span> <span class="n">in</span> <span class="n">module</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">fmt</span><span class="p">(</span><span class="err">‚Ä¶</span><span class="p">)</span>
</pre></table></code></div></div><p>where <code class="language-plaintext highlighter-rouge">fmt</code> receives the specified scoped implementation by observing it through the <code class="language-plaintext highlighter-rouge">T: Debug</code> bound on its implementing <code class="language-plaintext highlighter-rouge">impl</code> block.</p><p>If no observing bound exists, code of this form should produce a warning spanning the <code class="language-plaintext highlighter-rouge">Trait in module</code> tokens. (see <a href="#unused-scoped-implementation">unused-scoped-implementation</a>)</p><h2 id="type-aliases-are-opaque-to-scoped-implementations">Type aliases are opaque to scoped implementations<a href="#type-aliases-are-opaque-to-scoped-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>As scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> is a fully lexically-scoped feature, the <em>implementation environment</em> present in a scope does not affect types hidden behind a type alias, except for the top-level type directly:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
        <span class="s">"global"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">m1</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Type</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="p">[</span><span class="n">Type</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">m2</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Type</span><span class="p">,</span> <span class="n">Trait</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="s">"scoped"</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Trait</span><span class="o">&gt;</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="k">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.method</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">m1</span><span class="p">::</span><span class="n">Alias</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">m2</span><span class="p">::{</span>
        <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">,</span>
        <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">[</span><span class="n">Type</span><span class="p">;</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">};</span>

    <span class="nd">assert_eq!</span><span class="p">([</span><span class="n">Type</span><span class="p">]</span><span class="nf">.method</span><span class="p">(),</span> <span class="s">"scoped"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">Alias</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span><span class="nf">.method</span><span class="p">(),</span> <span class="s">"global"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Scoped implementations may still be observed through bounded generic type parameters on the type alias itself. (see <a href="#binding-choice-by-implementations-bounds">binding-choice-by-implementations-bounds</a>)</p><h2 id="typeid-of-generic-type-parameters-opaque-types"><code class="language-plaintext highlighter-rouge">TypeId</code> of generic type parameters‚Äô opaque types<a href="#typeid-of-generic-type-parameters-opaque-types" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>In addition to the type identity of the specified type, the <code class="language-plaintext highlighter-rouge">TypeId</code> of opaque generic type parameter types varies according to the captured <em>implementation environment</em>, but <em>only according to implementations that are relevant to their bounds (including implicit bounds)</em>, so that the following program runs without panic:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="n">TypeId</span><span class="p">;</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>
<span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">mod</span> <span class="n">nested</span> <span class="p">{</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">use</span> <span class="k">impl</span> <span class="k">super</span><span class="p">::</span><span class="n">Trait</span> <span class="k">for</span> <span class="k">super</span><span class="p">::</span><span class="n">Type</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// `A` and `B` are distinct due to different captured implementation environments.</span>
<span class="k">type</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">type</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span> <span class="k">as</span> <span class="n">Trait</span> <span class="n">in</span> <span class="n">nested</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">no_bound</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span><span class="p">());</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">yes_bound</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Trait</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Trait</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span><span class="p">());</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">no_bound</span><span class="p">(</span><span class="nn">A</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span> <span class="nn">B</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>
    <span class="nf">yes_bound</span><span class="p">(</span><span class="nn">A</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span> <span class="nn">B</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In particular:</p><ul><li>If no bound-relevant scoped implementations are captured in a type parameter, then the <code class="language-plaintext highlighter-rouge">TypeId</code> of the opaque type of that type parameter is identical to that of the discrete type specified for that type parameter.<li>Distinct sets of bound-relevant captured scoped implementations lead to distinct <code class="language-plaintext highlighter-rouge">TypeId</code>s of the opaque type of a type parameter.<li>If the set of bound-relevant captured scoped implementations in two generic type parameters is the same, and the wrapped discrete type is identical, then the <code class="language-plaintext highlighter-rouge">TypeId</code> of the opaque types of these generic type parameters is identical.<li>If a generic type parameter is distinguishable this way, it remains distinguishable in called implementations even if those have fewer bounds - the relevant distinction is ‚Äòbaked‚Äô into the generic type parameter‚Äôs opaque type.</ul><p>These rules (and the transmutation permission in <a href="#layout-compatibility">layout-compatibility</a>) allow the following collection to remain sound with minimal perhaps unexpected behaviour:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">any</span><span class="p">::</span><span class="n">TypeId</span><span class="p">,</span>
    <span class="nn">collections</span><span class="p">::{</span>
        <span class="nn">hash_map</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">RandomState</span><span class="p">},</span>
        <span class="n">HashSet</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nn">hash</span><span class="p">::{</span><span class="n">BuildHasher</span><span class="p">,</span> <span class="n">Hash</span><span class="p">},</span>
    <span class="nn">mem</span><span class="p">::</span><span class="k">drop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">use</span> <span class="nn">ondrop</span><span class="p">::</span><span class="n">OnDrop</span><span class="p">;</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ErasedHashSet</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="nv">'a</span> <span class="o">+</span> <span class="n">BuildHasher</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">=</span> <span class="n">RandomState</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TypeId</span><span class="p">,</span> <span class="o">*</span><span class="k">mut</span> <span class="p">(),</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">droppers</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">OnDrop</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnOnce</span><span class="p">()</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ErasedHashSet</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">RandomState</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">BuildHasher</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="n">ErasedHashSet</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_hasher</span><span class="p">(</span><span class="n">hasher</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">storage</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">with_hasher</span><span class="p">(</span><span class="n">hasher</span><span class="p">),</span>
            <span class="n">droppers</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// This is the important part.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">insert</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="c1">// &lt;-- Bounds.</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">type_id</span> <span class="o">=</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// &lt;-- `TypeId` depends on implementations of bounds.</span>
        <span class="k">let</span> <span class="n">storage</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="p">()</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.storage</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_id</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">storage</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pointer</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">with_hasher</span><span class="p">(</span>
                <span class="k">self</span><span class="py">.storage</span><span class="nf">.hasher</span><span class="p">()</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="p">)));</span>
            <span class="k">self</span><span class="py">.droppers</span><span class="nf">.push</span><span class="p">(</span><span class="nn">OnDrop</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
                <span class="c1">// SAFETY: Only called once when the `ErasedHashSet` is dropped.</span>
                <span class="c1">//         The type is still correct since the pointer wasn't `.cast()` yet and</span>
                <span class="c1">//         both `S` and `T` are bounded on `'a`, so they are still alive at this point.</span>
                <span class="k">drop</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="n">pointer</span><span class="p">));</span>
            <span class="p">})));</span>
            <span class="k">self</span><span class="py">.storage</span>
                <span class="nf">.insert</span><span class="p">(</span><span class="n">type_id</span><span class="p">,</span> <span class="n">pointer</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">())</span>
                <span class="nf">.expect</span><span class="p">(</span><span class="s">"always succeeds"</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">storage</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// SAFETY: Created with (close to) identical type above.</span>
            <span class="c1">//         Different `Hash` and `Eq` implementations are baked into `T`'s identity because of the bounds, so they result in distinct `TypeId`s above.</span>
            <span class="c1">//         It's allowed to transmute between types that differ in identity only by bound-irrelevant captured implementations.</span>
            <span class="c1">//         The borrowed reference isn't returned.</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="n">storage</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span><span class="p">())</span>
        <span class="p">};</span>
        <span class="n">storage</span><span class="nf">.insert</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In particular, this code will ignore any scoped implementations on <code class="language-plaintext highlighter-rouge">T</code> that are not <code class="language-plaintext highlighter-rouge">Hash</code>, <code class="language-plaintext highlighter-rouge">Eq</code> or (implicitly) <code class="language-plaintext highlighter-rouge">PartialEq</code>, while any combination of distinct discrete type and <em>implementation environments</em> with distinct <code class="language-plaintext highlighter-rouge">Hash</code>, <code class="language-plaintext highlighter-rouge">Eq</code> or <code class="language-plaintext highlighter-rouge">PartialEq</code> implementations is cleanly separated.</p><p>See also <a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters</a> for how to lint for an implementation of this collection that uses <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;HashSet&lt;T, S&gt;&gt;()</code> as key, which <em>also</em> remains sound and deterministic but distinguishes too aggressively by irrelevant scoped implementations in consumer code, leading to unexpected behaviour.</p><p>(For an example of <code class="language-plaintext highlighter-rouge">TypeId</code> behaviour, see <a href="#of-type-erased-collections">logical-consistency</a>.)</p><h2 id="layout-compatibility">Layout-compatibility<a href="#layout-compatibility" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Types whose identities are only distinct because of a difference in <em>implementation environments</em> remain layout-compatible as if one was a <code class="language-plaintext highlighter-rouge">#[repr(transparent)]</code> newtype of the other.</p><p>It is sound to transmute an instance between these types <strong>if</strong> no inconsistency is observed on that instance by the bounds of any external-to-the-<code class="language-plaintext highlighter-rouge">transmute</code> implementation or combination of implementations, including scoped implementations and implementations on discrete variants of the generic. As a consequence, the <code class="language-plaintext highlighter-rouge">Self</code>-observed <code class="language-plaintext highlighter-rouge">TypeId</code> of instances of generic types <strong>may</strong> change in some cases.</p><p>For example, given a library</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">Type</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>then in another crate</p><ul><li>if <code class="language-plaintext highlighter-rouge">Debug</code> is used on an instance of <code class="language-plaintext highlighter-rouge">Type&lt;T&gt;</code>, then this instance may <em>not</em> be transmuted to one where <code class="language-plaintext highlighter-rouge">T: Debug</code> uses a different implementation and have <code class="language-plaintext highlighter-rouge">Debug</code> used on it again afterwards, and<li>if <code class="language-plaintext highlighter-rouge">Type&lt;usize&gt;::method()</code> is used on an instance of <code class="language-plaintext highlighter-rouge">Type&lt;usize&gt;</code>, then that instance may not be transmuted (and used) to or from any other variant, including ones that only differ by captured <em>implementation environment</em>, because <code class="language-plaintext highlighter-rouge">method</code> has observed the <em>exact</em> type parameter through its constraints.</ul><p>(In short: Don‚Äôt use external-to-your-code implementations with the instance in any combination that wouldn‚Äôt have been possible without transmuting the instance, pretending implementations can only observe the type identity according to their bounds.)</p><p>See <a href="#typeid-of-generic-type-parameters-opaque-types">typeid-of-generic-type-parameters-opaque-types</a> for details on what this partial transmutation permission is for, and <a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters</a> for a future incompatibility lint that could be used to warn implementations where this is relevant.</p><h2 id="no-interceptionno-proxies">No interception/no proxies<a href="#no-interceptionno-proxies" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>That each scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type { /*...*/ }</code> is in scope for itself makes the use of the implementation it shadows in the consumer scope <em>inexpressible</em>. There can be no scoped implementation constrained to always shadow another.</p><p>This is intentional, as it makes the following code trivial to reason about:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="k">use</span> <span class="nn">a</span><span class="p">::{</span><span class="k">impl</span> <span class="n">TheTrait</span> <span class="k">for</span> <span class="n">TheType</span><span class="p">};</span> <span class="c1">// &lt;-- Clearly unused, no hidden interdependencies.</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">b</span><span class="p">::{</span><span class="k">impl</span> <span class="n">TheTrait</span> <span class="k">for</span> <span class="n">TheType</span><span class="p">};</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>(The main importance here is to not allow non-obvious dependencies of imports. Implementations can still access associated items of a <em>specific</em> other implementation by bringing it into a nested scope or binding to its associated items elsewhere. See also <a href="#independent-trait-implementations-on-discrete-types-may-still-call-shadowed-implementations">independent-trait-implementations-on-discrete-types-may-still-call-shadowed-implementations</a>.)</p><h2 id="binding-choice-by-implementations-bounds">Binding choice by implementations‚Äô bounds<a href="#binding-choice-by-implementations-bounds" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Implementations bind to other implementations as follows:</p><div class="table-wrapper"><table><thead><tr><th><code class="language-plaintext highlighter-rouge">where</code>-clause¬π on <code class="language-plaintext highlighter-rouge">impl</code>?<th>binding-site of used trait<th>monomorphised by used trait?<tbody><tr><td>Yes.<td>Bound at each binding-site of <code class="language-plaintext highlighter-rouge">impl</code>.<td>Yes, like-with or as-part-of type parameter distinction.<tr><td>No.<td>Bound once at definition-site of <code class="language-plaintext highlighter-rouge">impl</code>.<td>No.</table></div><p>¬π Or equivalent generic type parameter bound, where applicable. For all purposes, this RFC treats them as semantically interchangeable.</p><p>A convenient way to think about this is that <em><code class="language-plaintext highlighter-rouge">impl</code>-implementations with bounds are blanket implementations over <code class="language-plaintext highlighter-rouge">Self</code> in different implementation environments</em>.</p><p>Note that <code class="language-plaintext highlighter-rouge">Self</code>-bounds on associated functions do <strong>not</strong> cause additional monomorphic variants to be emitted, as these continue to only filter the surrounding implementation.</p><p>Consider the following code with attention to the where clauses:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>

<span class="c1">// ‚ù∂</span>

<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">function</span><span class="p">();</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"global"</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>

<span class="k">trait</span> <span class="n">Monomorphic</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">monomorphic</span><span class="p">();</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Monomorphic</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">monomorphic</span><span class="p">()</span> <span class="p">{</span> <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">MonomorphicSubtrait</span><span class="p">:</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">monomorphic_subtrait</span><span class="p">()</span> <span class="p">{</span> <span class="k">Self</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">MonomorphicSubtrait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="k">trait</span> <span class="n">Bounded</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">bounded</span><span class="p">();</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Bounded</span> <span class="k">for</span> <span class="n">Type</span> <span class="k">where</span> <span class="n">Type</span><span class="p">:</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">bounded</span><span class="p">()</span> <span class="p">{</span> <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">BoundedSubtrait</span><span class="p">:</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">bounded_subtrait</span><span class="p">()</span> <span class="p">{</span> <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">BoundedSubtrait</span> <span class="k">for</span> <span class="n">Type</span> <span class="k">where</span> <span class="n">Type</span><span class="p">:</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">trait</span> <span class="n">FnBoundedMonomorphic</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">where_trait</span><span class="p">()</span> <span class="k">where</span> <span class="k">Self</span><span class="p">:</span> <span class="n">Trait</span> <span class="p">{</span> <span class="k">Self</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">where_monomorphic_subtrait</span><span class="p">()</span> <span class="k">where</span> <span class="k">Self</span><span class="p">:</span> <span class="n">MonomorphicSubtrait</span> <span class="p">{</span> <span class="k">Self</span><span class="p">::</span><span class="nf">monomorphic_subtrait</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">FnBoundedMonomorphic</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="k">trait</span> <span class="n">NestedMonomorphic</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">nested_monomorphic</span><span class="p">();</span> <span class="p">}</span>

<span class="k">trait</span> <span class="n">BoundedOnOther</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">bounded_on_other</span><span class="p">();</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">BoundedOnOther</span> <span class="k">for</span> <span class="p">()</span> <span class="k">where</span> <span class="n">Type</span><span class="p">:</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">bounded_on_other</span><span class="p">()</span> <span class="p">{</span> <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">monomorphic</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">monomorphic_subtrait</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">bounded</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">bounded_subtrait</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">where_trait</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">where_monomorphic_subtrait</span><span class="p">();</span> <span class="c1">// "global"</span>
<span class="nn">Type</span><span class="p">::</span><span class="nf">nested_monomorphic</span><span class="p">();</span> <span class="c1">// "scoped"</span>
<span class="p">()::</span><span class="nf">bounded_on_other</span><span class="p">();</span> <span class="c1">// "global"</span>

<span class="p">{</span>
    <span class="c1">// ‚ù∑</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"scoped"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// use impl FnBoundedMonomorphic for Type {}</span>
    <span class="c1">// error: the trait bound `Type: MonomorphicSubtrait` is not satisfied</span>

    <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="c1">// "scoped"</span>
    <span class="nn">Type</span><span class="p">::</span><span class="nf">monomorphic</span><span class="p">();</span> <span class="c1">// "global"</span>
    <span class="c1">// Type::monomorphic_subtrait(); // error; shadowed by scoped implementation</span>
    <span class="nn">Type</span><span class="p">::</span><span class="nf">bounded</span><span class="p">();</span> <span class="c1">// "scoped"</span>
    <span class="nn">Type</span><span class="p">::</span><span class="nf">bounded_subtrait</span><span class="p">();</span> <span class="c1">// "scoped"</span>
    <span class="nn">Type</span><span class="p">::</span><span class="nf">where_trait</span><span class="p">();</span> <span class="c1">// "global"</span>
    <span class="nn">Type</span><span class="p">::</span><span class="nf">where_monomorphic_subtrait</span><span class="p">();</span> <span class="c1">// "global"</span>
    <span class="nn">Type</span><span class="p">::</span><span class="nf">nested_monomorphic</span><span class="p">();</span> <span class="c1">// "scoped"</span>
    <span class="p">()::</span><span class="nf">bounded_on_other</span><span class="p">();</span> <span class="c1">// "global"</span>

    <span class="p">{</span>
        <span class="c1">// ‚ù∏</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">MonomorphicSubtrait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">FnBoundedMonomorphic</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

        <span class="k">impl</span> <span class="n">NestedMonomorphic</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">nested_monomorphic</span><span class="p">()</span> <span class="p">{</span> <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="nn">Type</span><span class="p">::</span><span class="nf">function</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">monomorphic</span><span class="p">();</span> <span class="c1">// "global"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">monomorphic_subtrait</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">bounded</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">bounded_subtrait</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">where_trait</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">where_monomorphic_subtrait</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="nn">Type</span><span class="p">::</span><span class="nf">nested_monomorphic</span><span class="p">();</span> <span class="c1">// "scoped"</span>
        <span class="p">()::</span><span class="nf">bounded_on_other</span><span class="p">();</span> <span class="c1">// "global"</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The numbers ‚ù∂, ‚ù∑ and ‚ù∏ mark relevant item scopes.</p><p>Generic item functions outside <code class="language-plaintext highlighter-rouge">impl</code> blocks bind and behave the same way as generic <code class="language-plaintext highlighter-rouge">impl</code>s with regard to scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>.</p><h3 id="trait--function"><code class="language-plaintext highlighter-rouge">Trait</code> / <code class="language-plaintext highlighter-rouge">::function</code><a href="#trait--function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>This is a plain monomorphic implementation with no dependencies. As there is a scoped implementation at ‚ù∑, that one is used in scopes ‚ù∑ and ‚ù∏.</p><h3 id="monomorphic--monomorphic"><code class="language-plaintext highlighter-rouge">Monomorphic</code> / <code class="language-plaintext highlighter-rouge">::monomorphic</code><a href="#monomorphic--monomorphic" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Another plain monomorphic implementations.</p><p>As there is no bound, an implementation of <code class="language-plaintext highlighter-rouge">Trait</code> is bound locally in ‚ù∂ to resolve the <code class="language-plaintext highlighter-rouge">Type::function()</code>-call.</p><p>This means that even though a different <code class="language-plaintext highlighter-rouge">use impl Trait for Type ‚Ä¶</code> is applied in ‚ù∑, the global implementation remains in use when this <code class="language-plaintext highlighter-rouge">Monomorphic</code> implementation is called into from there and ‚ù∏.</p><p>Note that the use of <code class="language-plaintext highlighter-rouge">Self</code> vs. <code class="language-plaintext highlighter-rouge">Type</code> in the non-default function body does not matter at all!</p><h3 id="monomorphicsubtrait--monomorphic_subtrait"><code class="language-plaintext highlighter-rouge">MonomorphicSubtrait</code> / <code class="language-plaintext highlighter-rouge">::monomorphic_subtrait</code><a href="#monomorphicsubtrait--monomorphic_subtrait" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Due to the supertrait, there is an implied bound <code class="language-plaintext highlighter-rouge">Self: Trait</code> <em>on the trait definition, but not on the implementation</em>.</p><p>This means that the implementation remains monomorphic, and as such depends on the specific (global) implementation of <code class="language-plaintext highlighter-rouge">Trait</code> in scope at the <code class="language-plaintext highlighter-rouge">impl MonomorphicSubtrait ‚Ä¶</code> in ‚ù∂.</p><p>As this <code class="language-plaintext highlighter-rouge">Trait</code> implementation is shadowed in ‚ù∑, the <code class="language-plaintext highlighter-rouge">MonomorphicSubtrait</code> implementation is shadowed for consistency of calls to generics bounded on both traits.</p><p>In ‚ù∏ there is a scoped implementation of <code class="language-plaintext highlighter-rouge">MonomorphicSubtrait</code>. As the default implementation is monomorphised for this implementation, it binds to the scoped implementation of <code class="language-plaintext highlighter-rouge">Trait</code> that is in scope here.</p><h3 id="bounded--bounded"><code class="language-plaintext highlighter-rouge">Bounded</code> / <code class="language-plaintext highlighter-rouge">::bounded</code><a href="#bounded--bounded" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The <code class="language-plaintext highlighter-rouge">Type: Trait</code> bound (can be written as <code class="language-plaintext highlighter-rouge">Self: Trait</code> ‚Äì they are equivalent.) selects the <code class="language-plaintext highlighter-rouge">Bounded</code>-binding-site‚Äôs <code class="language-plaintext highlighter-rouge">Type: Trait</code> implementation to be used, rather than the <code class="language-plaintext highlighter-rouge">impl Bounded for ‚Ä¶</code>-site‚Äôs.</p><p>In ‚ù∂, this resolves to the global implementation as expected.</p><p>For the scopes ‚ù∑ and ‚ù∏ together, <code class="language-plaintext highlighter-rouge">Bounded</code> gains one additional monomorphisation, as here another <code class="language-plaintext highlighter-rouge">Type: Trait</code> is in scope.</p><h3 id="boundedsubtrait--bounded_subtrait"><code class="language-plaintext highlighter-rouge">BoundedSubtrait</code> / <code class="language-plaintext highlighter-rouge">::bounded_subtrait</code><a href="#boundedsubtrait--bounded_subtrait" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>As with <code class="language-plaintext highlighter-rouge">MonomorphicSubtrait</code>, the monomorphisation of <code class="language-plaintext highlighter-rouge">impl BoundedSubtrait for Type ‚Ä¶</code> that is used in ‚ù∂ is shadowed in ‚ù∑.</p><p>However, due to the <code class="language-plaintext highlighter-rouge">where Type: Trait</code> bound <em>on the implementation</em>, that implementation is polymorphic over <code class="language-plaintext highlighter-rouge">Trait for Type</code> implementations. This means a second monomorphisation is available in ‚ù∑ and its nested scope ‚ù∏.</p><h3 id="fnboundedmonomorphic"><code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code><a href="#fnboundedmonomorphic" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code>‚Äôs implementations are monomorphic from the get-go just like <code class="language-plaintext highlighter-rouge">Monomorphic</code>‚Äôs.</p><p>Due to the narrower bounds on functions, their availability can vary between receivers but always matches that of the global <em>implementation environment</em>:</p><h4 id="where_trait"><code class="language-plaintext highlighter-rouge">::where_trait</code><a href="#where_trait" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Available everywhere since <code class="language-plaintext highlighter-rouge">Type: Trait</code> is in scope for both implementations of <code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code>.</p><p>In ‚ù∂, this resolves to the global implementation.</p><p>In ‚ù∑, this <em>still</em> calls the global <code class="language-plaintext highlighter-rouge">&lt;Type as Trait in ::&gt;::function()</code> implementation since the global <code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code> implementation is <em>not</em> polymorphic over <code class="language-plaintext highlighter-rouge">Type: Trait</code>.</p><p>In ‚ù∏, <code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code> is monomorphically reimplemented for <code class="language-plaintext highlighter-rouge">Type</code>, which means it ‚Äúpicks up‚Äù the scoped <code class="language-plaintext highlighter-rouge">Type: Trait</code> implementation that‚Äôs in scope there from ‚ù∑.</p><h4 id="where_monomorphic_subtrait"><code class="language-plaintext highlighter-rouge">::where_monomorphic_subtrait</code><a href="#where_monomorphic_subtrait" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>In ‚ù∂, this resolves to the global implementation.</p><p>In ‚ù∑, this <em>still</em> calls the global <code class="language-plaintext highlighter-rouge">&lt;Type as MonomorphicSubtrait in ::&gt;::monomorphic_subtrait()</code> implementation since the global <code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code> implementation is <em>not</em> polymorphic over <code class="language-plaintext highlighter-rouge">Type: Trait</code>.</p><p>Note that <code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code> <em>cannot</em> be reimplemented in ‚ù∑ since the bound <code class="language-plaintext highlighter-rouge">Type: MonomorphicSubtrait</code> on its associated function isn‚Äôt available in that scope, which would cause a difference in the availability of associated functions (which would cause a mismatch when casting to <code class="language-plaintext highlighter-rouge">dyn FnBoundedMonomorphic</code>).</p><blockquote><p>It may be better to allow <code class="language-plaintext highlighter-rouge">use impl FnBoundedMonomorphic for Type {}</code> without <code class="language-plaintext highlighter-rouge">where_monomorphic_subtrait</code> in ‚ù∑ and disallow incompatible unsizing instead. I‚Äôm not sure about the best approach here.</p></blockquote><p>In ‚ù∏, <code class="language-plaintext highlighter-rouge">FnBoundedMonomorphic</code> is monomorphically reimplemented for <code class="language-plaintext highlighter-rouge">Type</code>, which means it ‚Äúpicks up‚Äù the scoped <code class="language-plaintext highlighter-rouge">Type: Trait</code> implementation that‚Äôs in scope there from ‚ù∑.</p><h3 id="nestedmonomorphic--nested_monomorphic"><code class="language-plaintext highlighter-rouge">NestedMonomorphic</code> / <code class="language-plaintext highlighter-rouge">::nested_monomorphic</code><a href="#nestedmonomorphic--nested_monomorphic" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The global implementation of <code class="language-plaintext highlighter-rouge">NestedMonomorphic</code> in ‚ù∏ the binds to the scoped implementation of <code class="language-plaintext highlighter-rouge">Trait</code> on <code class="language-plaintext highlighter-rouge">Type</code> from ‚ù∑ internally. This allows outside code to call into that function indirectly without exposing the scoped implementation itself.</p><h3 id="boundedonother--bounded_on_other"><code class="language-plaintext highlighter-rouge">BoundedOnOther</code> / <code class="language-plaintext highlighter-rouge">::bounded_on_other</code><a href="#boundedonother--bounded_on_other" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>As this discrete implementation‚Äôs bound isn‚Äôt over the <code class="language-plaintext highlighter-rouge">Self</code> type (and does not involved generics), it continues to act only as assertion and remains monomorphic.</p><h2 id="binding-and-generics">Binding and generics<a href="#binding-and-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">where</code>-clauses without generics or <code class="language-plaintext highlighter-rouge">Self</code> type, like <code class="language-plaintext highlighter-rouge">where (): Debug</code>, <strong>do not</strong> affect binding of implementations within an <code class="language-plaintext highlighter-rouge">impl</code> or <code class="language-plaintext highlighter-rouge">fn</code>, as the non-type-parameter-type <code class="language-plaintext highlighter-rouge">()</code> is unable to receive an <em>implementation environment</em> from the discretisation site.</p><p>However, <code class="language-plaintext highlighter-rouge">where (): From&lt;T&gt;</code> <strong>does</strong> take scoped implementations into account because the blanket <code class="language-plaintext highlighter-rouge">impl&lt;T, U&gt; From&lt;T&gt; for U where T: Into&lt;U&gt; {}</code> is sensitive to <code class="language-plaintext highlighter-rouge">T: Into&lt;()&gt;</code> which is part of the <em>implementation environment</em> captured in <code class="language-plaintext highlighter-rouge">T</code>!</p><p>This sensitivity even extends to scoped <code class="language-plaintext highlighter-rouge">use impl From&lt;T&gt; for ()</code> at the discretisation site, as the inverse blanket implementation of <code class="language-plaintext highlighter-rouge">Into</code> creates a scoped implementation of <code class="language-plaintext highlighter-rouge">Into</code> wherever a scoped implementation of <code class="language-plaintext highlighter-rouge">From</code> exists.<br /> This way, existing symmetries are fully preserved in all contexts.</p><h2 id="implicit-shadowing-of-subtrait-implementations">Implicit shadowing of subtrait implementations<a href="#implicit-shadowing-of-subtrait-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Take this code for example:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::{</span><span class="n">Deref</span><span class="p">,</span> <span class="n">DerefMut</span><span class="p">};</span>

<span class="k">struct</span> <span class="nf">Type1</span><span class="p">(</span><span class="n">Type2</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Type2</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">Type1</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">Type2</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DerefMut</span> <span class="k">for</span> <span class="n">Type1</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">function1</span><span class="p">(</span><span class="n">_x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Deref</span> <span class="o">+</span> <span class="n">DerefMut</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">function2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">DerefMut</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.deref</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">Type1</span> <span class="p">{</span>
        <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="p">();</span>

        <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// function1(Type1(Type2)); // &lt;-- Clearly impossible.</span>
    <span class="c1">// function2(Type1(Type2)); // &lt;-- Unexpected behaviour if allowed.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Clearly, <code class="language-plaintext highlighter-rouge">function1</code> cannot be used here, as its generic bounds would have to bind to incompatible implementations.</p><p>But what about <code class="language-plaintext highlighter-rouge">function2</code>? Here, the bound is implicit but <code class="language-plaintext highlighter-rouge">Deref::deref</code> could still be accessed if the function could be called. For type compatibility, this would have to be the shadowed global implementation, which is most likely unintended decoherence.</p><p>As such, <strong>shadowing a trait implementation also shadows all respective subtrait implementations</strong>. Note that the subtrait <em>may</em> still be immediately available (again), if it is implemented with a generic target and all bounds can be satisfied in the relevant scope:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait1</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">trait</span> <span class="n">Trait2</span><span class="p">:</span> <span class="n">Trait1</span> <span class="p">{</span> <span class="c1">// &lt;-- Subtrait of Trait1.</span>
    <span class="k">fn</span> <span class="nf">uses_trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.trait1</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Trait1</span><span class="o">&gt;</span> <span class="n">Trait2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{}</span> <span class="c1">// &lt;-- Blanket implementation with bounds satisfiable in scope.</span>

<span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Trait1</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"global"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait1</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">print!</span><span class="p">(</span><span class="s">"scoped"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Type</span><span class="nf">.uses_trait1</span><span class="p">();</span> <span class="c1">// Works, prints "scoped".</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If a subtrait implementation is brought into scope, it must be either an implementation with a generic target, or an implementation on a discrete type making use of the identical supertrait implementations in that scope. (This rule is automatically fulfilled by scoped implementation definitions, so it‚Äôs only relevant for which scoped implementations can be imported via <code class="language-plaintext highlighter-rouge">use</code>-declaration.)</p><h2 id="independent-trait-implementations-on-discrete-types-may-still-call-shadowed-implementations">Independent trait implementations on discrete types may still call shadowed implementations<a href="#independent-trait-implementations-on-discrete-types-may-still-call-shadowed-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Going back to the previous example, but now implementing <code class="language-plaintext highlighter-rouge">Trait2</code> independently without <code class="language-plaintext highlighter-rouge">Trait1</code> in its supertraits:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait1</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">trait</span> <span class="n">Trait2</span> <span class="p">{</span> <span class="c1">// &lt;-- Not a subtrait of `Trait1`.</span>
    <span class="k">fn</span> <span class="nf">uses_trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Trait2</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span> <span class="c1">// &lt;-- Implementation on discrete type.</span>
    <span class="k">fn</span> <span class="nf">uses_trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.trait1</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Trait1</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"global"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait1</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">trait1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">print!</span><span class="p">(</span><span class="s">"scoped"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Type</span><span class="nf">.uses_trait1</span><span class="p">();</span> <span class="c1">// Works, prints "global".</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In this case, the implementation of <code class="language-plaintext highlighter-rouge">Trait2</code> is <em>not</em> shadowed at all. Additionally, since <code class="language-plaintext highlighter-rouge">self.trait1();</code> here binds <code class="language-plaintext highlighter-rouge">Trait</code> on <code class="language-plaintext highlighter-rouge">Type</code> directly, rather than on a bounded generic type parameter, it uses whichever <code class="language-plaintext highlighter-rouge">impl Trait1 for Type</code> is in scope <em>where it is written</em>.</p><h2 id="resolution-on-generic-type-parameters">Resolution on generic type parameters<a href="#resolution-on-generic-type-parameters" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s (including <code class="language-plaintext highlighter-rouge">use</code>-declarations) can be applied to outer generic type parameters <em>at least</em> (see <a href="#unresolved-questions">unresolved-questions</a>) via scoped blanket <code class="language-plaintext highlighter-rouge">use impl&lt;T: Bound&gt; Trait for T</code>.</p><p>However, a blanket implementation can only be bound on a generic type parameter iff its bounds are fully covered by the generic type parameter‚Äôs bounds and other available trait implementations on the generic type parameter, in the same way as this applies for global implementations.</p><h2 id="method-resolution-to-scoped-implementation-without-trait-in-scope">Method resolution to scoped implementation without trait in scope<a href="#method-resolution-to-scoped-implementation-without-trait-in-scope" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax">Method calls</a> can bind to scoped implementations even when the declaring trait is not separately imported. For example:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Type2</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">nested</span> <span class="p">{</span>
    <span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">use</span> <span class="k">impl</span> <span class="nn">nested</span><span class="p">::</span><span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
<span class="k">impl</span> <span class="nn">nested</span><span class="p">::</span><span class="n">Trait</span> <span class="k">for</span> <span class="n">Type2</span> <span class="p">{}</span>

<span class="n">Type</span><span class="nf">.method</span><span class="p">();</span> <span class="c1">// Compiles.</span>
<span class="n">Type2</span><span class="nf">.method</span><span class="p">();</span> <span class="c1">// error[E0599]: no method named `method` found for struct `Type2` in the current scope</span>
</pre></table></code></div></div><p>This also equally (importantly) applies to scoped implementations imported from elsewhere.</p><h2 id="scoped-implementations-do-not-implicitly-bring-the-trait-into-scope">Scoped implementations do not implicitly bring the trait into scope<a href="#scoped-implementations-do-not-implicitly-bring-the-trait-into-scope" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This so that no method calls on other types become ambiguous:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Type2</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">nested</span> <span class="p">{</span>
    <span class="k">trait</span> <span class="n">Trait</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">trait</span> <span class="n">Trait2</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">nested</span><span class="p">::</span><span class="n">Trait2</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Trait2</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
<span class="k">impl</span> <span class="n">Trait2</span> <span class="k">for</span> <span class="n">Type2</span> <span class="p">{}</span>

<span class="k">use</span> <span class="k">impl</span> <span class="nn">nested</span><span class="p">::</span><span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
<span class="k">impl</span> <span class="nn">nested</span><span class="p">::</span><span class="n">Trait</span> <span class="k">for</span> <span class="n">Type2</span> <span class="p">{}</span>

<span class="n">Type</span><span class="nf">.method</span><span class="p">();</span> <span class="c1">// Compiles, binds to scoped implementation of `Trait`.</span>
<span class="n">Type2</span><span class="nf">.method</span><span class="p">();</span> <span class="c1">// Compiles, binds to global implementation of `Trait2`.</span>
</pre></table></code></div></div><p>(If <code class="language-plaintext highlighter-rouge">Trait</code> was not yet globally implemented for <code class="language-plaintext highlighter-rouge">Type2</code>, and <code class="language-plaintext highlighter-rouge">Trait</code> and <code class="language-plaintext highlighter-rouge">Type2</code> were defined in other crates, then bringing <code class="language-plaintext highlighter-rouge">Trait</code> into scope here could introduce instability towards that implementation later being added in one of those crates.)</p><h2 id="shadowing-with-different-bounds">Shadowing with different bounds<a href="#shadowing-with-different-bounds" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Scoped implementations may have different bounds compared to an implementation they (partially) shadow. The compiler will attempt to satisfy those bounds, but if they are not satisfied, then the other implementation is not shadowed for that set of generic type parameters and no additional warning or error is raised.</p><p>(Warnings for e.g. unused scoped implementations and scoped implementations that only shadow a covering global implementation are still applied as normal. It‚Äôs just that partial shadowing with different bounds is likely a common use-case in macros.)</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Type2</span><span class="p">;</span>

<span class="k">trait</span> <span class="n">Trait1</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"1"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Trait1</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{}</span> <span class="c1">// &lt;--</span>

<span class="k">trait</span> <span class="n">Trait2</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">trait2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"2"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Trait2</span> <span class="k">for</span> <span class="n">Type2</span> <span class="p">{}</span> <span class="c1">// &lt;--</span>

<span class="k">trait</span> <span class="n">Say</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">say</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Trait1</span><span class="o">&gt;</span> <span class="n">Say</span> <span class="k">for</span> <span class="n">T</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Trait1</span><span class="p">,</span> <span class="c1">// &lt;--</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">say</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">T</span><span class="p">::</span><span class="nf">trait1</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Say</span> <span class="k">for</span> <span class="n">T</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="n">Trait2</span> <span class="c1">// &lt;--</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">say</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">T</span><span class="p">::</span><span class="nf">trait2</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">Type1</span><span class="p">::</span><span class="nf">say</span><span class="p">();</span> <span class="c1">// 1</span>
    <span class="nn">Type2</span><span class="p">::</span><span class="nf">say</span><span class="p">();</span> <span class="c1">// 2</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="no-priority-over-type-associated-methods">No priority over type-associated methods<a href="#no-priority-over-type-associated-methods" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> has <em>the same</em> method resolution priority as an equivalent global implementation would have if it was visible for method-binding in that scope. This means that directly type-associated functions still bind with higher priority than those available through scoped implementations.</p><h2 id="coercion-to-trait-objects">Coercion to trait objects<a href="#coercion-to-trait-objects" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Due to the coercion into a trait object in the following code, the scoped implementation becomes attached to the value through the pointer meta data. This means it can then be called from other scopes:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Display</span><span class="p">,</span> <span class="n">Formatter</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">dyn</span> <span class="n">Display</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"scoped"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">&amp;</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">function</span><span class="p">());</span> <span class="c1">// "scoped"</span>
</pre></table></code></div></div><p>This behaves exactly as a global implementation would.</p><p>Note that the <a href="https://doc.rust-lang.org/stable/core/ptr/struct.DynMetadata.html"><code class="language-plaintext highlighter-rouge">DynMetadata&lt;dyn Display&gt;</code></a>s of the reference returned above and one that uses the global implementation would compare as distinct even if both are ‚Äú<code class="language-plaintext highlighter-rouge">&amp;()</code>‚Äù.</p><h2 id="interaction-with-return-position-impl-trait">Interaction with return-position <code class="language-plaintext highlighter-rouge">impl Trait</code><a href="#interaction-with-return-position-impl-trait" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Consider the following functions:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>

    <span class="p">()</span> <span class="c1">// Binds on trailing `()`-expression.</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">function2</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>

    <span class="p">{}</span> <span class="c1">// Binds on trailing `{}`-block used as expression.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In this case, the returned opaque types use the respective inner scoped implementation, as it binds on the <code class="language-plaintext highlighter-rouge">()</code> expression.</p><p>The following functions do not compile, as the implicitly returned <code class="language-plaintext highlighter-rouge">()</code> is not stated <em>inside</em> the scope where the implementation is available:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
                 <span class="o">^^^^^^^^^^</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="o">---------------------</span>

    <span class="c1">// Cannot bind on implicit `()` returned by function body without trailing *Expression*.</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">function2</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
                  <span class="o">^^^^^^^^^^</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="o">---------------------</span>

    <span class="k">return</span><span class="p">;</span> <span class="c1">// Cannot bind on `return` without expression.</span>
    <span class="o">-------</span>
<span class="p">}</span>
</pre></table></code></div></div><p>(The errors should ideally also point at the scoped implementations here with a secondary highlight, and suggest stating the return value explicitly.)</p><p>The binding must be consistent:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="c1">// error: Inconsistent implementation of opaque return type.</span>
    <span class="k">if</span> <span class="k">true</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="p">();</span>
        <span class="o">----------</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="p">();</span>
        <span class="o">^^^^^^^^^^</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This function <em>does</em> compile, as the outer scoped <code class="language-plaintext highlighter-rouge">impl Trait for ()</code> is bound on the <code class="language-plaintext highlighter-rouge">if</code>-<code class="language-plaintext highlighter-rouge">else</code>-expression as a whole.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="k">true</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span> <span class="c1">// warning: unused scoped implementation</span>
        <span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span> <span class="c1">// warning: unused scoped implementation</span>
        <span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This compiles because the end of the function is not reachable:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">function</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="p">();</span> <span class="c1">// Explicit `return` is required to bind in the inner scope.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="static-interception-of-dynamic-calls">Static interception of dynamic calls<a href="#static-interception-of-dynamic-calls" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>As a consequence of binding outside of generic contexts, it <em>is</em> possible to statically wrap <em>specific</em> trait implementations on <em>concrete</em> types. This includes the inherent implementations on trait objects:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Display</span><span class="p">,</span> <span class="n">Formatter</span><span class="p">};</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="k">dyn</span> <span class="n">Display</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="c1">// Restore binding to inherent global implementation within this function.</span>
            <span class="k">use</span> <span class="p">::{</span><span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="k">dyn</span> <span class="n">Display</span><span class="p">};</span>

            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Hello! "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">d</span><span class="nf">.fmt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">" See you!"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">question</span> <span class="o">=</span> <span class="s">"What's up?"</span><span class="p">;</span> <span class="c1">// &amp;str</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{question}"</span><span class="p">);</span> <span class="c1">// "What's up?"</span>

    <span class="k">let</span> <span class="n">question</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Display</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">question</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{question}"</span><span class="p">);</span> <span class="c1">// Binds to the scoped implementation; "Hello! What's up? See you!"</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="warnings">Warnings<a href="#warnings" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="unused-scoped-implementation">Unused scoped implementation<a href="#unused-scoped-implementation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Scoped implementations and <code class="language-plaintext highlighter-rouge">use</code>-declarations of such (including those written as <em>ImplEnvironmentEntry</em>) receive a warning if unused. This can also happen if a <code class="language-plaintext highlighter-rouge">use</code>-declaration only reapplies a scoped implementation that is inherited from a surrounding item scope.</p><p>(rust-analyzer should suggest removing any unused <code class="language-plaintext highlighter-rouge">use</code>-declarations as fix in either case.)</p><p>An important counter-example:</p><p>Filename: library/src/lib.rs</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>
<span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>Filename: main.rs</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="n">TypeId</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">library</span><span class="p">::{</span><span class="n">Alias</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>

<span class="nd">assert_ne!</span><span class="p">(</span><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Alias</span><span class="o">&gt;</span><span class="p">(),</span> <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span><span class="p">());</span>
</pre></table></code></div></div><p>Here, the scoped implementation <code class="language-plaintext highlighter-rouge">use impl Trait for Type {}</code> <strong>is</strong> accounted for as it is captured into the type identity of <code class="language-plaintext highlighter-rouge">Alias</code>.</p><p>Since <code class="language-plaintext highlighter-rouge">Alias</code> is exported, the compiler cannot determine within the library alone that the type identity is unobserved. If it can ensure that that is the case, a (different!) warning could in theory still be shown here.</p><h3 id="global-trait-implementation-available">Global trait implementation available<a href="#global-trait-implementation-available" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Scoped implementations and <code class="language-plaintext highlighter-rouge">use</code>-declarations of such receive a specific warning if only shadowing a global implementation that would fully cover them. This warning also informs about the origin of the global implementation, with a ‚Äúdefined here‚Äù marker if in the same workspace. This warning is not applied to scoped implementations that <em>at all</em> shadow another scoped implementation.</p><p>(Partial overlap with a shadowed scoped implementation should be enough to suppress this because setting the import up to be a precise subset could get complex fairly quickly. In theory just copying <code class="language-plaintext highlighter-rouge">where</code>-clauses is enough, but in practice the amount required could overall scale with the square of scoped implementation shadowing depth and some imports may even have to be duplicated.)</p><p>It would make sense to let the definitions and also alternatively specific global implementations of traits with high implementation stability requirements like <code class="language-plaintext highlighter-rouge">serde::{Deserialize, Serialize}</code> deactivate this warning too, so that the latter don‚Äôt cause it on the respective covered scoped implementations.</p><h3 id="self-referential-bound-of-scoped-implementation">Self-referential bound of scoped implementation<a href="#self-referential-bound-of-scoped-implementation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">}</span>
            <span class="o">---------</span>       <span class="o">^^^^^^</span>
</pre></table></code></div></div><p>A Rust developer may want to write the above to mean ‚Äòthis scoped implementation can only be used on types that already implement this trait‚Äô or ‚Äòthis scoped implementation uses functionality of the shadowed implementation‚Äô. However, since scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> uses item scope rules, any shadowed implementation is functionally absent in the entire scope. As such, this implementation, like the equivalent global implementation, cannot apply to any types at all.</p><p>The warning should explain that and why the bound is impossible to satisfy.</p><h3 id="private-supertrait-implementation-required-by-public-implementation">Private supertrait implementation required by public implementation<a href="#private-supertrait-implementation-required-by-public-implementation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Consider the following code:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>

<span class="k">use</span> <span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
</pre></table></code></div></div><p>Here, the public implementation relies strictly on the private implementation to also be available. This means it effectively cannot be imported in <code class="language-plaintext highlighter-rouge">use</code>-declarations outside this module.</p><p>See also the error <a href="#incompatible-or-missing-supertrait-implementation">incompatible-or-missing-supertrait-implementation</a>.</p><h3 id="public-implementation-of-private-traiton-private-type">Public implementation of private trait/on private type<a href="#public-implementation-of-private-traiton-private-type" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The code</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
             <span class="o">^^^^^</span>     <span class="o">^^^^</span>
</pre></table></code></div></div><p>should produce two distinct warnings similarly to those for private items in public signatures, as the limited visibilities of <code class="language-plaintext highlighter-rouge">Type</code> and <code class="language-plaintext highlighter-rouge">Trait</code> independently prevent the implementation from being imported in modules for which it is declared as visible.</p><h3 id="scoped-implementation-is-less-visible-than-itemfield-it-is-captured-in">Scoped implementation is less visible than item/field it is captured in<a href="#scoped-implementation-is-less-visible-than-itemfield-it-is-captured-in" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The code</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>

<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span> <span class="c1">// &lt;-- Visibility of the trait doesn't matter for *this* warning.</span>

<span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
<span class="o">-----------------------</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
                         <span class="o">^^^^</span>  <span class="o">^^^^</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;</span> <span class="p">{</span>
                               <span class="o">^^^^</span>  <span class="o">^^^^</span>              <span class="o">^^^^</span>  <span class="o">^^^^</span>
    <span class="n">value</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Struct</span> <span class="p">{</span>
  <span class="n">private</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// This is fine.</span>
  <span class="k">pub</span> <span class="n">public</span><span class="p">:</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;</span><span class="p">,</span>
                      <span class="o">^^^^</span>  <span class="o">^^^^</span>
<span class="p">}</span>
</pre></table></code></div></div><p>should produce eight warnings (or four/three warnings with multiple primary spans each, if possible). The warning should explain that the type can‚Äôt be referred to by fully specified name outside the crate/module and that the implementation may be callable from code outside the crate/module.</p><p>If the binding is specified via inline <em>implementation environment</em>, then the warning should show up on the <code class="language-plaintext highlighter-rouge">Trait in module</code> span instead.</p><p>Note that as with other private-in-public warnings, replacing</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
</pre></table></code></div></div><p>with</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">mod</span> <span class="n">nested</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Trait</span><span class="p">,</span> <span class="n">Type</span><span class="p">};</span>
    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">nested</span><span class="p">::{</span><span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">};</span>
</pre></table></code></div></div><p>in the code sample above should silence the warning.</p><p>In some cases, adding <code class="language-plaintext highlighter-rouge">as Trait in ::</code> to the generic type argument could be suggested as quick-fix, though generally it‚Äôs better to fix this warning by moving the scoped implementation into a nested scope or moving it into a module and importing it into nested scopes as needed.</p><blockquote><p>This warning can‚Äôt be suppressed for private traits because the presence of their scoped implementation on a generic type parameter still affects the <code class="language-plaintext highlighter-rouge">TypeId</code> of the capturing generic, which here is visible outside of the discretising module.</p></blockquote><h3 id="imported-implementation-is-less-visible-than-itemfield-it-is-captured-in">Imported implementation is less visible than item/field it is captured in<a href="#imported-implementation-is-less-visible-than-itemfield-it-is-captured-in" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>This occurs under the same circumstances as above, except that</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>
<span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
</pre></table></code></div></div><p>is replaced with</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">a_crate</span><span class="p">::{</span>
    <span class="n">Trait</span><span class="p">,</span>
    <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><p>(where here the implementation import is subsetting a blanket import, but that technicality isn‚Äôt relevant. What matters is that the implementation is from another crate).</p><p>If the imported implementation is captured in a public item‚Äôs signature, that can accidentally create a public dependency. As such this should be a warning too (unless something from that crate occurs explicitly in that public signature or item?).</p><h2 id="errors">Errors<a href="#errors" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="global-implementation-of-trait-where-global-implementation-of-supertrait-is-shadowed">Global implementation of trait where global implementation of supertrait is shadowed<a href="#global-implementation-of-trait-where-global-implementation-of-supertrait-is-shadowed" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>A trait cannot be implemented globally for a discrete type in a scope where the global implementation of any of its supertraits is shadowed on that type.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>

<span class="k">trait</span> <span class="n">Super</span> <span class="p">{}</span>
<span class="k">trait</span> <span class="nb">Sub</span><span class="p">:</span> <span class="n">Super</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Super</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Super</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
    <span class="o">-----------------------</span> <span class="c1">// &lt;-- Scoped implementation defined/imported here.</span>

    <span class="k">impl</span> <span class="nb">Sub</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
    <span class="o">^^^^^^^^^^^^^^^^^</span> <span class="c1">//&lt;-- error: global implementation of trait where global implementation of supertrait is shadowed</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="negative-scoped-implementation">Negative scoped implementation<a href="#negative-scoped-implementation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>This occurs on all negative scoped implementations. Negative scoped implementations can be parsed, but are rejected shortly after macros are applied.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="o">!</span><span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^</span> <span class="n">error</span><span class="p">:</span> <span class="n">negative</span> <span class="n">scoped</span> <span class="n">implementation</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="incompatible-or-missing-supertrait-implementation">Incompatible or missing supertrait implementation<a href="#incompatible-or-missing-supertrait-implementation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Implementations of traits on discrete types require a specific implementation of each of their supertraits, as they bind to them at their definition, so they cannot be used without those being in scope too (to avoid perceived and hard to reason-about inconsistencies).</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">trait</span> <span class="n">Super</span> <span class="p">{}</span>
<span class="k">trait</span> <span class="nb">Sub</span><span class="p">:</span> <span class="n">Super</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Super</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>

<span class="k">mod</span> <span class="n">nested</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Super</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="nb">Sub</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">nested</span><span class="p">::{</span><span class="k">impl</span> <span class="nb">Sub</span> <span class="k">for</span> <span class="n">Type</span><span class="p">};</span>
             <span class="o">^^^^^^^^^^^^^^^^^</span> <span class="n">error</span><span class="p">:</span> <span class="n">incompatible</span> <span class="n">supertrait</span> <span class="n">implementation</span>
</pre></table></code></div></div><p>Rustc should suggest to import the required scoped implementation, if possible.</p><p>See also the warning <a href="#private-supertrait-implementation-required-by-public-implementation">private-supertrait-implementation-required-by-public-implementation</a>. See also <a href="#implicit-import-of-supertrait-implementations-of-scoped-implementations-defined-on-discrete-types">implicit-import-of-supertrait-implementations-of-scoped-implementations-defined-on-discrete-types</a> for a potential way to improve the ergonomics here.</p><h3 id="scoped-implementation-of-external-sealed-trait">Scoped implementation of external sealed trait<a href="#scoped-implementation-of-external-sealed-trait" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Given crate <code class="language-plaintext highlighter-rouge">a</code>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">mod</span> <span class="n">private</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Sealing</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">private</span><span class="p">::</span><span class="n">Sealing</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Sealed</span><span class="p">:</span> <span class="n">Sealing</span> <span class="p">{}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{}</span> <span class="c1">// Ok.</span>
</pre></table></code></div></div><p>And crate <code class="language-plaintext highlighter-rouge">b</code>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">a</span><span class="p">::{</span>
    <span class="n">Sealed</span><span class="p">,</span>
    <span class="k">impl</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// Ok.</span>
<span class="p">};</span>

<span class="k">use</span> <span class="k">impl</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span> <span class="c1">// Error.</span>
         <span class="o">^^^^^^</span>
</pre></table></code></div></div><p>Crate <code class="language-plaintext highlighter-rouge">b</code> cannot define scoped implementations of the external sealed trait <code class="language-plaintext highlighter-rouge">Sealed</code>, but can still import them.</p><p>See <a href="#no-external-scoped-implementations-of-sealed-traits">no-external-scoped-implementations-of-sealed-traits</a> for why this is necessary.</p><h2 id="behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">Behaviour change/Warning: <code class="language-plaintext highlighter-rouge">TypeId</code> of implementation-aware generic discretised using generic type parameters<a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>As a result of the transmutation permission given in <a href="#layout-compatibility">layout-compatibility</a>, which is needed to let the <code class="language-plaintext highlighter-rouge">ErasedHashSet</code> example in <a href="#typeid-of-generic-type-parameters-opaque-types">typeid-of-generic-type-parameters-opaque-types</a> <em>remain sound</em>, monomorphisations of a function that observe distinct <code class="language-plaintext highlighter-rouge">TypeId</code>s for <a href="#implementation-aware-generics">implementation-aware-generics</a> they discretise using type parameters may be called on the same value instance.</p><p>Notably, this affects <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;Self&gt;()</code> in implementations with most generic targets, but not in unspecific blanket implementations on the type parameter itself.</p><p>This would have to become a future incompatibility lint ahead of time, and should also remain a warning after the feature is implemented since the behaviour of <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;Self&gt;()</code> in generics is likely to be unexpected.</p><p>In most cases, implementations should change this to <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;T&gt;()</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the type parameter used for discretisation, since that should show only the expected <code class="language-plaintext highlighter-rouge">TypeId</code> distinction.</p><p>Instead of <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;AStruct&lt;U, V, W&gt;&gt;()</code>, <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;(U, V, W)&gt;()</code> can be used, as tuples are <a href="#implementation-invariant-generics">implementation-invariant-generics</a>.</p><h1 id="drawbacks">Drawbacks</h1><p>Why should we <em>not</em> do this?</p><h2 id="first-party-implementation-assumptions-in-macros">First-party implementation assumptions in macros<a href="#first-party-implementation-assumptions-in-macros" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>If a macro outputs a call of the form <code class="language-plaintext highlighter-rouge">&lt;$crate::Type as $crate::Trait&gt;::method()</code>, it can currently make safety-critical assumptions about implementation details of the <code class="language-plaintext highlighter-rouge">method</code> that is called iff implemented in the same crate.</p><p>(This should also be considered relevant for library/proc-macro crate pairs where the macro crate is considered an implementation detail of the library even where the macro doesn‚Äôt require an <code class="language-plaintext highlighter-rouge">unsafe</code> token in its input, even though ‚Äúcrate privacy‚Äù currently isn‚Äôt formally representable towards Cargo.)</p><p>As such, <strong>newly allowing the global trait implementation to be shadowed here can introduce soundness holes</strong> iff <code class="language-plaintext highlighter-rouge">Trait</code> is not <code class="language-plaintext highlighter-rouge">unsafe</code> or exempt from scoped implementations.</p><p>(I couldn‚Äôt come up with a good example for this. There might be a slim chance that it‚Äôs not actually a practical issue in the ecosystem. Unfortunately, this seems to be very difficult to lint for.)</p><p>There are a few ways to mitigate this, but they all have significant drawbacks:</p><ul><li><p>Opt-in scoped-<code class="language-plaintext highlighter-rouge">impl Trait</code> transparency for macros</p><p>This would make scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s much less useful, as they couldn‚Äôt be used with for example some derive macros by default. It would also be necessary to teach the opt-in along with macros, which may not be realistic considering existing community-made macro primers.</p><p>Implementation is likely complicated because many procedural macros emit tokens only with <code class="language-plaintext highlighter-rouge">Span::call_site()</code> hygiene, so information on the distinct binding site origin may not be readily available.</p><p>This could be limited to existing kinds of macro definitions, so that future revised macro systems can be opted in by default. Future macros could use an <code class="language-plaintext highlighter-rouge">unsafe</code> trait instead to assume an implementation, or make use of scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> to enforce a specific implementation in their output.</p><p>Drawback: Whether globally implemented behaviour can be changed by the consumer would depend on the macro. It would be good to surface a transparency opt-in in the documentation here.</p><li><p>Opt-in scoped-<code class="language-plaintext highlighter-rouge">impl Trait</code> <em>priority</em> for macros</p><p>This would preserve practical usefulness of the proposed feature in most cases.</p><p>This would add significant complexity to the feature, as resolution of scoped implementations wouldn‚Äôt be exactly the same as for other items. (We should otherwise warn if a scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> outside a macro shadows binding a global implementation inside of it though, so at least the feature implementation complexity may be net zero in this regard.)</p><p>This could be limited to existing kinds of macro definitions, with the same implications as for opt-in transparency above.</p><p>Drawback: Whether globally implemented behaviour can be changed by the consumer would depend on the macro. It would be good to surface a priority opt-in in the documentation here.</p><li><p>Forbid scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> if <code class="language-plaintext highlighter-rouge">Trait</code> and <code class="language-plaintext highlighter-rouge">Type</code> are from the same crate</p><p>This would at best be a partial fix and would block some interesting uses of <a href="#using-scoped-implementations-to-implement-external-traits-on-external-types">using-scoped-implementations-to-implement-external-traits-on-external-types</a>.</p></ul><h2 id="unexpected-behaviour-of-typeidofself-in-implementations-on-generics-in-the-consumer-side-presence-of-scoped-implementations-and-transmute">Unexpected behaviour of <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;Self&gt;()</code> in implementations on generics in the consumer-side presence of scoped implementations and <code class="language-plaintext highlighter-rouge">transmute</code><a href="#unexpected-behaviour-of-typeidofself-in-implementations-on-generics-in-the-consumer-side-presence-of-scoped-implementations-and-transmute" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>As explained in <a href="#rustdoc-documentation-changes">rustdoc-documentation-changes</a>, <a href="#layout-compatibility">layout-compatibility</a> and <a href="#type-identity-of-generic-types">type-identity-of-generic-types</a>, an observed <code class="language-plaintext highlighter-rouge">TypeId</code> can change for an instance under specific circumstances that are previously-legal <code class="language-plaintext highlighter-rouge">transmute</code>s as e.g. for the <code class="language-plaintext highlighter-rouge">HashSet</code>s inside the type-erased value-keyed collection like the <code class="language-plaintext highlighter-rouge">ErasedHashSet</code> example in the <a href="#typeid-of-generic-type-parameters-opaque-types">typeid-of-generic-type-parameters-opaque-types</a> section.</p><p>This use case appears to be niche enough in Rust to not have an obvious example on crates.io, but see <a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters</a> for a lint that aims to mitigate issues in this regard and could be used to survey potential issues.</p><h2 id="more-use-declaration-clutter-potential-inconsistencies-between-files">More <code class="language-plaintext highlighter-rouge">use</code>-declaration clutter, potential inconsistencies between files<a href="#more-use-declaration-clutter-potential-inconsistencies-between-files" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>If many scoped implementations need to be imported, this could cause the list of <code class="language-plaintext highlighter-rouge">use</code>-declarations to become less readable. If there are multiple alternatives available, inconsistencies could sneak in between modules (especially if scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> is used in combination with <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialisation</a>).</p><p>This can largely be mitigated by centralising a crate‚Äôs scoped trait imports and implementations in one module, then wildcard-importing its items:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// lib.rs</span>
<span class="k">mod</span> <span class="n">scoped_impls</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">scoped_impls</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// scoped_impls.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">a</span><span class="p">::{</span><span class="n">TypeA</span><span class="p">,</span> <span class="n">TraitA</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">b</span><span class="p">::{</span><span class="n">TypeB</span><span class="p">,</span> <span class="n">TraitB</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">a_b_glue</span><span class="p">::{</span><span class="k">impl</span> <span class="n">TraitA</span> <span class="k">for</span> <span class="n">TypeB</span><span class="p">,</span> <span class="k">impl</span> <span class="n">TraitB</span> <span class="k">for</span> <span class="n">TypeA</span><span class="p">};</span>
<span class="c1">// ...</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">TypeA</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">TypeB</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// other .rs files</span>
<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">scoped_impls</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="type-inference-has-to-consider-both-scoped-and-global-implementations">Type inference has to consider both scoped and global implementations<a href="#type-inference-has-to-consider-both-scoped-and-global-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Complexity aside, this could cause compiler performance issues since caching would be less helpful.</p><p>Fortunately, at least checking whether scoped implementations exist at all for a given trait and item scope should be reasonably inexpensive, so this hopefully won‚Äôt noticeably slow down compilation of existing code.</p><p>That <em>implementation environment</em> binding on generic type parameters is centralised to the type discretisation site(s) may also help a little in this regard.</p><h2 id="cost-of-additional-monomorphised-implementation-instances">Cost of additional monomorphised implementation instances<a href="#cost-of-additional-monomorphised-implementation-instances" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The additional instantiations of implementations resulting from <a href="#binding-choice-by-implementations-bounds">binding-choice-by-implementations-bounds</a> could have a detrimental effect on compile times and .text size (depending on optimisations).</p><p>This isn‚Äôt unusual for anything involving <em>GenericParams</em>, but use of this feature could act as a multiplier to some extent. It‚Äôs likely a good idea to evaluate relatively fine-grained caching in this regard, if that isn‚Äôt in place already.</p><h2 id="split-type-identity-may-be-unexpected">Split type identity may be unexpected<a href="#split-type-identity-may-be-unexpected" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Consider crates like <code class="language-plaintext highlighter-rouge">inventory</code> or Bevy‚Äôs systems and queries.</p><p>There may be tricky to debug issues for their consumers if a <code class="language-plaintext highlighter-rouge">TypeId</code> doesn‚Äôt match between uses of generics with superficially the same type parameters, especially without prior knowledge of distinction by captured <em>implementation environments</em>.</p><p>A partial mitigation would be to have rustc include captured scoped implementations on generic type parameters when printing types, but that wouldn‚Äôt solve the issue entirely.</p><p>Note that with this RFC implemented, <code class="language-plaintext highlighter-rouge">TypeId</code> would still report the same value iff evaluated on generic type parameters with distinct but bound-irrelevant captured implementations directly, as long as only these top-level implementations differ and no nested captured <em>implementation environments</em> do.</p><h2 id="marking-a-generic-as-implementation-invariant-is-a-breaking-change">Marking a generic as implementation-invariant is a breaking change<a href="#marking-a-generic-as-implementation-invariant-is-a-breaking-change" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This concerns the split of <a href="#implementation-aware-generics">implementation-aware-generics</a> and <a href="#implementation-invariant-generics">implementation-invariant-generics</a>.</p><p>‚ÄúImplementation-aware‚Äù is the logic-safe default.</p><p>‚ÄúImplementation-invariant‚Äù has better ergonomics in some cases.</p><p>It would be great to make moving from the default here only a feature addition. To do this, a new coherence rule would likely have to be introduced to make implementations conflict if any type becoming implementation-invariant would make them conflict, and additionally to make such implementations shadow each other (to avoid all-too-unexpected silent behaviour changes).</p><p>However, even that would not mitigate the behaviour change of type-erasing collections that are keyed on such generics that become type-invariant later, so making this a breaking change is simpler and overall more flexible.</p><h1 id="rationale-and-alternatives">Rationale and alternatives</h1><h2 id="avoid-newtypes-pain-points">Avoid newtypes‚Äô pain points<a href="#avoid-newtypes-pain-points" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Alternative keywords: ergonomics and compatibility.</p><h3 id="recursively-dependent-derive">Recursively dependent <code class="language-plaintext highlighter-rouge">#[derive(‚Ä¶)]</code><a href="#recursively-dependent-derive" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Many derives, like <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Debug</code>, partial comparisons, <code class="language-plaintext highlighter-rouge">serde::{Deserialize, Serialize}</code> and <code class="language-plaintext highlighter-rouge">bevy_reflect::{FromReflect, Reflect}</code> require the trait to be implemented for each field type. Even with the more common third-party traits like Serde‚Äôs, there are many crates with useful data structures that do not implement these traits directly.</p><p>As such, glue code is necessary.</p><h4 id="current-pattern">Current pattern<a href="#current-pattern" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Some crates go out of their way to provide a compatibility mechanism for their derives, but this is neither the default nor has it (if available) any sort of consistency between crates, which means finding and interacting with these mechanisms requires studying the crate‚Äôs documentation in detail.</p><p>For derives that do not provide such a mechanism, often only newtypes like <code class="language-plaintext highlighter-rouge">NewSerdeCompatible</code> and <code class="language-plaintext highlighter-rouge">NewNeitherCompatible</code> below can be used. However, these do not automatically forward all traits (and forwarding implementations may be considerably more painful than the <code class="language-plaintext highlighter-rouge">derive</code>s), so additional glue code between glue crates may be necessary.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">bevy_reflect</span><span class="p">::</span><span class="n">Reflect</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="k">use</span> <span class="nn">bevy_compatible</span><span class="p">::</span><span class="n">BevyCompatible</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">neither_compatible</span><span class="p">::</span><span class="n">NeitherCompatible</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serde_compatible</span><span class="p">::</span><span class="n">SerdeCompatible</span><span class="p">;</span>

<span class="c1">// I could not actually find much information on how to implement the Bevy-glue.</span>
<span class="c1">// I assume it's possible to provide at least this API by creating a newtype and implementing the traits manually.</span>
<span class="k">use</span> <span class="nn">bevy_compatible_serde_glue</span><span class="p">::</span><span class="n">BevyCompatibleDef</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">neither_compatible_bevy_glue</span><span class="p">::</span><span class="n">NewNeitherCompatible</span><span class="p">;</span> <span class="c1">// Assumed to have `From`, `Into` conversions.</span>
<span class="k">use</span> <span class="nn">neither_compatible_serde_glue</span><span class="p">::</span><span class="n">NeitherCompatibleDef</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serde_compatible_bevy_glue</span><span class="p">::</span><span class="n">NewSerdeCompatible</span><span class="p">;</span> <span class="c1">// Assumed to have `From`, `Into` conversions.</span>

<span class="cd">/// A typical data transfer object as it may appear in a service API.</span>
<span class="nd">#[derive(Deserialize,</span> <span class="nd">Serialize,</span> <span class="nd">Reflect)]</span>
<span class="nd">#[non_exhaustive]</span> <span class="c1">// Just a reminder, since the fields aren't public anyway.</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DataBundle</span> <span class="p">{</span>
    <span class="c1">// Serde provides a way to use external implementations on fields (but it has to be specified for each field separately).</span>
    <span class="c1">// Bevy does not have such a mechanism so far, so newtypes are required.</span>
    <span class="c1">// The newtypes should be an implementation detail, so the fields are (for consistency all) private.</span>
    <span class="nd">#[serde(with</span> <span class="nd">=</span> <span class="s">"NewSerdeCompatibleDef"</span><span class="nd">)]</span>
    <span class="n">serde</span><span class="p">:</span> <span class="n">NewSerdeCompatible</span><span class="p">,</span>
    <span class="nd">#[serde(with</span> <span class="nd">=</span> <span class="s">"BevyCompatibleDef"</span><span class="nd">)]</span>
    <span class="n">bevy</span><span class="p">:</span> <span class="n">BevyCompatible</span><span class="p">,</span>
    <span class="nd">#[serde(with</span> <span class="nd">=</span> <span class="s">"NewNeitherCompatibleDef"</span><span class="nd">)]</span>
    <span class="n">neither</span><span class="p">:</span> <span class="n">NewNeitherCompatible</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Some of the newtypes don't implement `Default` (maybe it was added to the underlying types later and the glue crate doesn't want to bump the dependency),</span>
<span class="c1">// so this has to be implemented semi-manually instead of using the `derive`-macro.</span>
<span class="k">impl</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">DataBundle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nn">DataBundleParts</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// If the Bevy glue doesn't forward the Serde implementations, this is necessary.</span>
<span class="nd">#[derive(Deserialize,</span> <span class="nd">Serialize)]</span>
<span class="nd">#[serde(remote</span> <span class="nd">=</span> <span class="s">"NewSerdeCompatible"</span><span class="nd">)]</span>
<span class="nd">#[serde(transparent)]</span>
<span class="k">struct</span> <span class="nf">NewSerdeCompatibleDef</span><span class="p">(</span><span class="n">SerdeCompatible</span><span class="p">);</span>

<span class="c1">// Same as above, but here the implementation is redirected to another glue crate.</span>
<span class="nd">#[derive(Deserialize,</span> <span class="nd">Serialize)]</span>
<span class="nd">#[serde(remote</span> <span class="nd">=</span> <span class="s">"NewNeitherCompatible"</span><span class="nd">)]</span>
<span class="nd">#[serde(transparent)]</span>
<span class="k">struct</span> <span class="nf">NewNeitherCompatibleDef</span><span class="p">(</span><span class="nd">#[serde(with</span> <span class="nd">=</span> <span class="s">"NeitherCompatibleDef"</span><span class="nd">)]</span> <span class="n">NeitherCompatible</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">DataBundle</span> <span class="p">{</span>
    <span class="c1">// These conversions are associated functions for discoverability.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_parts</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="n">DataBundleParts</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">parts</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_parts</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DataBundleParts</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// Necessary to mutate multiple fields at once.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parts_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DataBundlePartsMut</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">DataBundlePartsMut</span> <span class="p">{</span>
            <span class="n">serde</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.serde</span><span class="na">.0</span><span class="p">,</span>
            <span class="n">bevy</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.bevy</span><span class="p">,</span>
            <span class="n">neither</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.neither</span><span class="na">.0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Accessors to the actual instances with the public types.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">serde</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">SerdeCompatible</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.serde</span><span class="na">.0</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">serde_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SerdeCompatible</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.serde</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="c1">// This also uses an accessor just for consistency.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">bevy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">BevyCompatible</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.bevy</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">bevy_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BevyCompatible</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.bevy</span>
    <span class="p">}</span>

    <span class="c1">// More accessors.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">neither</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">NeitherCompatible</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.neither</span><span class="na">.0</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">neither_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">NeitherCompatible</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.neither</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Conversions for convenience</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">DataBundleParts</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">DataBundle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">DataBundleParts</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">serde</span><span class="p">:</span> <span class="n">value</span><span class="py">.serde</span><span class="nf">.into</span><span class="p">(),</span>
            <span class="n">bevy</span><span class="p">:</span> <span class="n">value</span><span class="py">.bevy</span><span class="nf">.into</span><span class="p">(),</span>
            <span class="n">neither</span><span class="p">:</span> <span class="n">value</span><span class="py">.neither</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">DataBundle</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">DataBundleParts</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">DataBundle</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">serde</span><span class="p">:</span> <span class="n">value</span><span class="py">.serde</span><span class="nf">.into</span><span class="p">(),</span>
            <span class="n">bevy</span><span class="p">:</span> <span class="n">value</span><span class="py">.bevy</span><span class="p">,</span>
            <span class="n">neither</span><span class="p">:</span> <span class="n">value</span><span class="py">.neither</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Used to construct and destructure [`DataBundle`].</span>
<span class="nd">#[derive(Default)]</span> <span class="c1">// Assume that all the actual field types have useful defaults.</span>
<span class="nd">#[non_exhaustive]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DataBundleParts</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">serde</span><span class="p">:</span> <span class="n">SerdeCompatible</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">bevy</span><span class="p">:</span> <span class="n">BevyCompatible</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">neither</span><span class="p">:</span> <span class="n">NeitherCompatible</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// Return type of [`DataBundle::parts_mut`].</span>
<span class="nd">#[non_exhaustive]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DataBundlePartsMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">serde</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">SerdeCompatible</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">bevy</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">BevyCompatible</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">neither</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">NeitherCompatible</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If two traits that require newtype wrappers need to be added for the same type, the process can be even more painful than what‚Äôs shown above, involving <code class="language-plaintext highlighter-rouge">unsafe</code> reinterpret casts to borrow a wrapped value correctly as each newtype and forwarding-implementing each trait manually if no transparent derive is available.</p><h4 id="with-scoped-impl-trait-for-type">With scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code><a href="#with-scoped-impl-trait-for-type" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> eliminates these issues, in a standardised way that doesn‚Äôt require any special consideration from the trait or derive crates:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">bevy_reflect</span><span class="p">::</span><span class="n">Reflect</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="k">use</span> <span class="nn">bevy_compatible</span><span class="p">::</span><span class="n">BevyCompatible</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">neither_compatible</span><span class="p">::</span><span class="n">NeitherCompatible</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serde_compatible</span><span class="p">::</span><span class="n">SerdeCompatible</span><span class="p">;</span>

<span class="c1">// I could not actually find much information on how to implement Bevy-glue.</span>
<span class="c1">// It's about the same as manually implementing the traits for newtypes, though.</span>
<span class="c1">// Since many traits are required for `bevy_reflect`'s derives, those glue crates use the prelude pattern and provide one for each target type.</span>
<span class="k">use</span> <span class="nn">bevy_compatible_serde_glue</span><span class="p">::{</span>
    <span class="k">impl</span> <span class="n">Deserialize</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">BevyCompatible</span><span class="p">,</span>
    <span class="k">impl</span> <span class="n">Serialize</span> <span class="k">for</span> <span class="n">BevyCompatible</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">neither_compatible_bevy_glue</span><span class="p">::</span><span class="nn">preludes</span><span class="p">::</span><span class="nn">neither_compatible</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">neither_compatible_serde_glue</span><span class="p">::{</span>
    <span class="k">impl</span> <span class="n">Deserialize</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">NeitherCompatible</span><span class="p">,</span>
    <span class="k">impl</span> <span class="n">Serialize</span> <span class="k">for</span> <span class="n">NeitherCompatible</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">serde_compatible_bevy_glue</span><span class="p">::</span><span class="nn">preludes</span><span class="p">::</span><span class="nn">serde_compatible</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="cd">/// A typical data transfer object as it may appear in a service API.</span>
<span class="nd">#[derive(Default,</span> <span class="nd">Deserialize,</span> <span class="nd">Serialize,</span> <span class="nd">Reflect)]</span>
<span class="nd">#[non_exhaustive]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DataBundle</span> <span class="p">{</span>
    <span class="c1">// Everything just works.</span>
    <span class="k">pub</span> <span class="n">serde</span><span class="p">:</span> <span class="n">SerdeCompatible</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">bevy</span><span class="p">:</span> <span class="n">BevyCompatible</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">neither</span><span class="p">:</span> <span class="n">NeitherCompatible</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// `Default` was derived normally.</span>
<span class="c1">// No glue for the glue is necessary.</span>
<span class="c1">// No conversions are needed to construct or destructure.</span>
<span class="c1">// `&amp;mut`-splitting is provided seamlessly by Rust.</span>
<span class="c1">// No accessors are needed since the fields are public.</span>
</pre></table></code></div></div><p>Even in cases where the glue API cannot be removed, it‚Äôs still possible to switch to this simplified, easier to consume implementation and deprecate the original indirect API.</p><p>Note that the imported scoped implementations are <em>not</em> visible in the public API here, since they do not appear on generic type parameters in public items. There may still be situations in which defining a type alias is necessary to keep some scoped implementations away from generic type parameters. In some cases, it could be enough to add <code class="language-plaintext highlighter-rouge">as Trait in ::</code> to generic type arguments to restore their <em>implementation environment</em> to contain global implementations only.</p><blockquote><p>In some cases, where a field type is quoted in a derive macro directly, writing <code class="language-plaintext highlighter-rouge">(Type as Trait in module)</code> only there could <em>in theory</em> also work, but this would heavily depend on the macro‚Äôs implementation details. See also <a href="#should-it-be-an-error-to-specify-an-implementation-environment-in-places-where-its-guaranteed-to-be-unused">should-it-be-an-error-to-specify-an-implementation-environment-in-places-where-its-guaranteed-to-be-unused</a>.</p></blockquote><p>Unlike with external newtypes, there are no potential conflicts beyond overlapping imports and definitions in the same scope. These conflicts can <em>always</em> be resolved both without editing code elsewhere and without adding an additional implementation:</p><ul><li>either by narrowing a local blanket implementation,<li>by narrowing a blanket implementation import to a subset of the external implementation,<li>or at worst by moving a generic implementation into a submodule and importing it for discrete types.</ul><h3 id="error-handling-and-conversions">Error handling and conversions<a href="#error-handling-and-conversions" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>When implementing services, it‚Äôs a common pattern to combine a framework that dictates function signatures with one or more unrelated middlewares that have their own return and error types. The example below is a very abridged example of this.</p><p>Note that in either version, the glue code may be project-specific. Glue code is <em>very slightly</em> more concise when implemented with scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>, as intermediary <code class="language-plaintext highlighter-rouge">struct</code> definitions and the resulting field access can be avoided.</p><h4 id="current-pattern-1">Current pattern<a href="#current-pattern-1" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="c1">// crate `service`</span>

<span class="k">use</span> <span class="nn">framework</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="n">Returned</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">middleware_a</span><span class="p">::{</span><span class="n">fallible_a</span><span class="p">,</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">ErrorA</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">middleware_b</span><span class="p">::{</span><span class="n">fallible_b</span><span class="p">,</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">ErrorB</span><span class="p">};</span>

<span class="k">use</span> <span class="nn">framework_middleware_a_glue</span><span class="p">::{</span><span class="n">IntoReturnedExt</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">NewErrorA</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">framework_middleware_b_glue</span><span class="p">::{</span><span class="n">IntoReturnedExt</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">NewErrorB</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">a</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Returned</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A `try` block should work eventually, but it may be not much less verbose.</span>
    <span class="nf">Ok</span><span class="p">((||</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">NewErrorA</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="p">)</span>
    <span class="p">})()</span><span class="o">?</span>
    <span class="nf">.into_returned</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">b</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Returned</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// The same as above.</span>
    <span class="nf">Ok</span><span class="p">((||</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">NewErrorB</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="p">)</span>
    <span class="p">})()</span><span class="o">?</span>
    <span class="nf">.into_returned</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">mixed</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Returned</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Neither 'NewError' type provided by third-party crates can be used directly here.</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="k">move</span> <span class="p">||</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">NewError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">if</span> <span class="n">condition</span> <span class="p">{</span>
            <span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
            <span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="nf">.into_returned</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
            <span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="nf">.into_returned</span><span class="p">()</span>
        <span class="p">})</span>
    <span class="p">})()</span><span class="o">?</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Custom glue to connect all three errors:</span>
<span class="k">struct</span> <span class="nf">NewError</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">NewError</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Error</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">NewError</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">value</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">ErrorA</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">NewError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">ErrorA</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">intermediate</span><span class="p">:</span> <span class="n">NewErrorA</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">intermediate</span><span class="nf">.into</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">ErrorB</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">NewError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">ErrorB</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">intermediate</span><span class="p">:</span> <span class="n">NewErrorB</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">intermediate</span><span class="nf">.into</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">service</span><span class="p">::{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mixed</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">framework</span><span class="p">::</span><span class="nf">setup</span><span class="p">()</span>
        <span class="nf">.add_route</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="nf">.add_route</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="nf">.add_route</span><span class="p">(</span><span class="s">"mixed"</span><span class="p">,</span> <span class="n">mixed</span><span class="p">)</span>
        <span class="nf">.build</span><span class="p">()</span>
        <span class="nf">.run</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="with-scoped-impl-trait-for-type-1">With scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code><a href="#with-scoped-impl-trait-for-type-1" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="c1">// crate `service`</span>

<span class="c1">// More concise, since middleware errors are used only once in imports.</span>
<span class="k">use</span> <span class="nn">framework</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="n">Returned</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">middleware_a</span><span class="p">::</span><span class="n">fallible_a</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">middleware_b</span><span class="p">::</span><span class="n">fallible_b</span><span class="p">;</span>

<span class="c1">// Note: It is often better to import `impl Into` here over `impl From`,</span>
<span class="c1">//       since middleware types often don't appear in public signatures.</span>
<span class="c1">//</span>
<span class="c1">//       If the target type of the import must appear as type parameter in a public signature,</span>
<span class="c1">//       a module that is wildcard-imported into each function body can be used instead,</span>
<span class="c1">//       which would amount to 6 additional and 2 modified lines here.</span>
<span class="c1">//</span>
<span class="c1">//       This RFC includes a warning for unintentionally exposed scoped implementations.</span>
<span class="k">use</span> <span class="nn">framework_middleware_a_glue</span><span class="p">::{</span>
    <span class="k">impl</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Returned</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nn">middleware_a</span><span class="p">::</span><span class="n">Returned</span><span class="p">,</span>
    <span class="k">impl</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nn">middleware_a</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">framework_middleware_b_glue</span><span class="p">::{</span>
    <span class="k">impl</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Returned</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nn">middleware_b</span><span class="p">::</span><span class="n">Returned</span><span class="p">,</span>
    <span class="k">impl</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nn">middleware_b</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">a</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Returned</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// It just works.</span>
    <span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="nf">.into</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">b</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Returned</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Here too.</span>
    <span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="nf">.into</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">mixed</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Returned</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// This too just works, as conversions bind separately.</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="k">if</span> <span class="n">condition</span> <span class="p">{</span>
        <span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">fallible_a</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">fallible_b</span><span class="p">()</span><span class="o">?</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// No custom glue is necessary at all.</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// Unchanged. No change in the API of `service`, either.</span>

<span class="k">use</span> <span class="nn">service</span><span class="p">::{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mixed</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">framework</span><span class="p">::</span><span class="nf">setup</span><span class="p">()</span>
        <span class="nf">.add_route</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="nf">.add_route</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="nf">.add_route</span><span class="p">(</span><span class="s">"mixed"</span><span class="p">,</span> <span class="n">mixed</span><span class="p">)</span>
        <span class="nf">.build</span><span class="p">()</span>
        <span class="nf">.run</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Note that to export <em>discrete</em> scoped <code class="language-plaintext highlighter-rouge">impl Into</code> in addition to their scoped <code class="language-plaintext highlighter-rouge">impl From</code>, the glue crates can use the following pattern, which discretises the global implementation and as such binds to each scoped <code class="language-plaintext highlighter-rouge">impl From</code> in the respective exported scoped <code class="language-plaintext highlighter-rouge">impl Into</code>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">use</span> <span class="p">::{</span>
    <span class="k">impl</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="nn">framework</span><span class="p">::</span><span class="n">Returned</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nn">middleware_a</span><span class="p">::</span><span class="n">Returned</span><span class="p">,</span>
    <span class="k">impl</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="nn">framework</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nn">middleware_a</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="preserve-coherence">Preserve coherence<a href="#preserve-coherence" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="cross-crate-stability">Cross-crate stability<a href="#cross-crate-stability" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>With this RFC, scopes are a ‚Äòmini version‚Äô of the environment that global implementations exist in. As this environment is sealed within one scope, and not composed from multiple crates that may update independently, the <em>orphan rule</em> is not necessary.</p><p><em>All other</em> coherence rules and (for exported implementations) rules for what is and is not a breaking change apply <em>within each scope exactly like for global implementations</em>. In particular:</p><ul><li><p>Blanket implementations like</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// (Does not compile!)</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="n">Debug</span><span class="p">,</span> <span class="n">LowerHex</span><span class="p">,</span> <span class="n">Pointer</span><span class="p">};</span>
<span class="k">mod</span> <span class="n">debug_by_lower_hex</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">debug_by_lower_hex</span><span class="p">::{</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">LowerHex</span><span class="o">&gt;</span> <span class="n">Debug</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">T</span><span class="p">};</span> <span class="c1">// &lt;--</span>

<span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Pointer</span><span class="o">&gt;</span> <span class="n">Debug</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span> <span class="c1">// &lt;--</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>still conflict regardless of actual implementations of <code class="language-plaintext highlighter-rouge">LowerHex</code> and <code class="language-plaintext highlighter-rouge">Pointer</code> because they may overlap later and</p><li><p>because scoped implementation are <em>explicitly subset</em> where they are imported, <em>it is not a breaking change to widen an exported scoped implementation</em>.</p><p>(This is part of the reason why scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s are anonymous; names would make these imports more verbose rather than shorter, since the subsetting still needs to happen in every case.)</p></ul><h3 id="logical-consistency">Logical consistency<a href="#logical-consistency" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Binding external top-level implementations to types is equivalent to using their public API in different ways, so no instance-associated consistency is expected here. Rather, values that are used in the same scope behave consistently with regard to that scope‚Äôs visible implementations.</p><h4 id="of-generic-collections">of generic collections<a href="#of-generic-collections" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Generics are trickier, as their instances often do expect trait implementations on generic type parameters that are consistent between uses but not necessarily declared as bounded on the struct definition itself.</p><p>This problem is solved by making the <code class="language-plaintext highlighter-rouge">impl</code>s available to each type parameter part of the the type identity of the discretised host generic, including a difference in <code class="language-plaintext highlighter-rouge">TypeId</code> there as with existing monomorphisation.</p><p>(See <a href="#type-parameters-capture-their-implementation-environment">type-parameters-capture-their-implementation-environment</a> and <a href="#type-identity-of-generic-types">type-identity-of-generic-types</a> in the <a href="#reference-level-explanation">reference-level-explanation</a> above for more detailed information.)</p><p>Here is an example of how captured <em>implementation environments</em> safely flow across module boundaries, often seamlessly due to type inference:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">a</span> <span class="p">{</span>
    <span class="c1">// ‚ìê == ‚óØ</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>

    <span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">A</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">type</span> <span class="n">HashSetA</span> <span class="o">=</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">aliased</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSetA</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">discrete</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">b</span> <span class="p">{</span>
    <span class="c1">// ‚ìë</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
        <span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">,</span>
        <span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">},</span>
    <span class="p">};</span>

    <span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">B</span><span class="p">;</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">type</span> <span class="n">HashSetB</span> <span class="o">=</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// ‚ö†</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">aliased</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSetB</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">discrete</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// ‚ö†</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">c</span> <span class="p">{</span>
    <span class="c1">// ‚ìí == ‚óØ</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>

    <span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Hash)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">C</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">type</span> <span class="n">HashSetC</span> <span class="o">=</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">aliased</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSetC</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">discrete</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">d</span> <span class="p">{</span>
    <span class="c1">// ‚ìì</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
        <span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">,</span>
        <span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">},</span>
        <span class="nn">iter</span><span class="p">::</span><span class="n">once</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span>
        <span class="nn">a</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">A</span><span class="p">},</span>
        <span class="nn">b</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">B</span><span class="p">},</span>
        <span class="nn">c</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">C</span><span class="p">},</span>
    <span class="p">};</span>

    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">A</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">C</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">call_functions</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">a</span><span class="p">::</span><span class="nf">aliased</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span> <span class="c1">// ‚ìê == ‚óØ</span>
        <span class="nn">a</span><span class="p">::</span><span class="nf">discrete</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span> <span class="c1">// ‚ìê == ‚óØ</span>
        <span class="nn">a</span><span class="p">::</span><span class="nf">generic</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">A</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>

        <span class="nn">b</span><span class="p">::</span><span class="nf">aliased</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">B</span><span class="p">)));</span> <span class="c1">// ‚ìë</span>
        <span class="nn">b</span><span class="p">::</span><span class="nf">discrete</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">B</span><span class="p">)));</span> <span class="c1">// ‚ìë</span>
        <span class="nn">b</span><span class="p">::</span><span class="nf">generic</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">B</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>

        <span class="nn">c</span><span class="p">::</span><span class="nf">aliased</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">C</span><span class="p">)));</span> <span class="c1">// ‚ìí == ‚óØ</span>
        <span class="nn">c</span><span class="p">::</span><span class="nf">discrete</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">C</span><span class="p">)));</span> <span class="c1">// ‚ìí == ‚óØ</span>
        <span class="nn">c</span><span class="p">::</span><span class="nf">generic</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">C</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><p>Note that the lines annotated with <code class="language-plaintext highlighter-rouge">// ‚ö†</code> produce a warning due to the lower visibility of the scoped implementation in <code class="language-plaintext highlighter-rouge">b</code>.</p><p>Circles denote <em>implementation environments</em>:</p><div class="table-wrapper"><table><thead><tr><th>¬†<th>¬†<tbody><tr><td>‚óØ<td>indistinct from global<tr><td>‚ìê, ‚ìë, ‚ìí, ‚ìì<td>respectively as in module <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code><tr><td>‚äô<td>caller-side</table></div><p>The calls infer discrete <code class="language-plaintext highlighter-rouge">HashSet</code>s with different <code class="language-plaintext highlighter-rouge">Hash</code> implementations as follows:</p><div class="table-wrapper"><table><thead><tr><th>call in <code class="language-plaintext highlighter-rouge">call_functions</code><th><code class="language-plaintext highlighter-rouge">impl Hash</code> in<th>captured in/at<th>notes<tbody><tr><td><code class="language-plaintext highlighter-rouge">a::aliased</code><td>-<td><code class="language-plaintext highlighter-rouge">type</code> alias<td>The implementation cannot be ‚Äòinserted‚Äô into an already-specified type parameter, even if it is missing.<tr><td><code class="language-plaintext highlighter-rouge">a::discrete</code><td>-<td><code class="language-plaintext highlighter-rouge">fn</code> signature<td>See <code class="language-plaintext highlighter-rouge">a::aliased</code>.<tr><td><code class="language-plaintext highlighter-rouge">a::generic</code><td><code class="language-plaintext highlighter-rouge">d</code><td><code class="language-plaintext highlighter-rouge">once&lt;T&gt;</code>¬†call<td>¬†<tr><td><code class="language-plaintext highlighter-rouge">b::aliased</code><td><code class="language-plaintext highlighter-rouge">b</code><td><code class="language-plaintext highlighter-rouge">type</code> alias<td>¬†<tr><td><code class="language-plaintext highlighter-rouge">b::discrete</code><td><code class="language-plaintext highlighter-rouge">b</code><td><code class="language-plaintext highlighter-rouge">fn</code> signature<td>¬†<tr><td><code class="language-plaintext highlighter-rouge">b::generic</code><td><code class="language-plaintext highlighter-rouge">d</code><td><code class="language-plaintext highlighter-rouge">once&lt;T&gt;</code>¬†call<td><code class="language-plaintext highlighter-rouge">b</code>‚Äôs narrow implementation cannot bind to the opaque <code class="language-plaintext highlighter-rouge">T</code>.<tr><td><code class="language-plaintext highlighter-rouge">c::aliased</code><td><code class="language-plaintext highlighter-rouge">::</code><td><code class="language-plaintext highlighter-rouge">type</code> alias<td>Since the global implementation is visible in <code class="language-plaintext highlighter-rouge">c</code>.<tr><td><code class="language-plaintext highlighter-rouge">c::discrete</code><td><code class="language-plaintext highlighter-rouge">::</code><td><code class="language-plaintext highlighter-rouge">fn</code> signature<td>See <code class="language-plaintext highlighter-rouge">c::aliased</code>.<tr><td><code class="language-plaintext highlighter-rouge">c::generic</code><td><code class="language-plaintext highlighter-rouge">d</code><td><code class="language-plaintext highlighter-rouge">once&lt;T&gt;</code>¬†call<td>The narrow global implementation cannot bind to the opaque <code class="language-plaintext highlighter-rouge">T</code>.</table></div><h4 id="of-type-erased-collections">of type-erased collections<a href="#of-type-erased-collections" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Type-erased collections such as the <code class="language-plaintext highlighter-rouge">ErasedHashSet</code> shown in <a href="#typeid-of-generic-type-parameters-opaque-types">typeid-of-generic-type-parameters-opaque-types</a> require slightly looser behaviour, as they are expected to mix instances between environments where only irrelevant implementations differ (since they don‚Äôt prevent this mixing statically like <code class="language-plaintext highlighter-rouge">std::collections::HashSet</code>, as their generic type parameters are transient on their methods).</p><p>It is for this reason that the <code class="language-plaintext highlighter-rouge">TypeId</code> of generic type parameters disregards bounds-irrelevant implementations.</p><p>The example is similar to the previous one, but <code class="language-plaintext highlighter-rouge">aliased</code> has been removed since it continues to behave the same as <code class="language-plaintext highlighter-rouge">discrete</code>. A new set of functions <code class="language-plaintext highlighter-rouge">bounded</code> is added:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused_must_use)]</span> <span class="c1">// For the `TypeId::‚Ä¶` lines.</span>

<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">a</span> <span class="p">{</span>
    <span class="c1">// ‚ìê == ‚óØ</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">,</span> <span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">};</span>

    <span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">A</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">discrete</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">bounded</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">b</span> <span class="p">{</span>
    <span class="c1">// ‚ìë</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
        <span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">,</span>
        <span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">},</span>
    <span class="p">};</span>

    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Trait</span><span class="p">;</span>

    <span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">B</span><span class="p">;</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">B</span> <span class="p">{}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">discrete</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ‚ö†‚ö†</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">bounded</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">c</span> <span class="p">{</span>
    <span class="c1">// ‚ìí == ‚óØ</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">,</span> <span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">};</span>

    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Trait</span><span class="p">;</span>

    <span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Hash)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">C</span><span class="p">;</span>
    <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">C</span> <span class="p">{}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">discrete</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">bounded</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">d</span> <span class="p">{</span>
    <span class="c1">// ‚ìì</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
        <span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">,</span>
        <span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">},</span>
        <span class="nn">iter</span><span class="p">::</span><span class="n">once</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span>
        <span class="nn">a</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">A</span><span class="p">},</span>
        <span class="nn">b</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">B</span><span class="p">},</span>
        <span class="nn">c</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">C</span><span class="p">},</span>
        <span class="n">Trait</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">A</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">C</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">_state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">A</span> <span class="p">{}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">B</span> <span class="p">{}</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">C</span> <span class="p">{}</span>

    <span class="k">fn</span> <span class="nf">call_functions</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">a</span><span class="p">::</span><span class="nf">discrete</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span> <span class="c1">// ‚ìê == ‚óØ</span>
        <span class="nn">a</span><span class="p">::</span><span class="nf">generic</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">A</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>
        <span class="nn">a</span><span class="p">::</span><span class="nf">bounded</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">A</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>

        <span class="nn">b</span><span class="p">::</span><span class="nf">discrete</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">B</span><span class="p">)));</span> <span class="c1">// ‚ìë</span>
        <span class="nn">b</span><span class="p">::</span><span class="nf">generic</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">B</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>
        <span class="nn">b</span><span class="p">::</span><span class="nf">bounded</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">B</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>

        <span class="nn">c</span><span class="p">::</span><span class="nf">discrete</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">C</span><span class="p">)));</span> <span class="c1">// ‚ìí == ‚óØ</span>
        <span class="nn">c</span><span class="p">::</span><span class="nf">generic</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">C</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>
        <span class="nn">c</span><span class="p">::</span><span class="nf">bounded</span><span class="p">(</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="n">C</span><span class="p">)));</span> <span class="c1">// ‚äô == ‚ìì</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">// ‚ö†</code> and non-digit circles have the same meanings as above.</p><p>The following table describes how the types are observed at runtime in the lines marked with ‚ù∂ and ‚ù∑. Types are denoted as if seen from the global <em>implementation environment</em> with differences written inline, which should resemble how they are formatted in compiler messages and tooling.</p><div class="table-wrapper"><table><thead><tr><th>within function<br />(called by <code class="language-plaintext highlighter-rouge">call_functions</code>)<th>‚ù∂ (collection)<th>‚ù∑ (item)<tbody><tr><td><code class="language-plaintext highlighter-rouge">a::discrete</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;A&gt;</code><td><code class="language-plaintext highlighter-rouge">A</code><tr><td><code class="language-plaintext highlighter-rouge">a::generic</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;A as Hash in d + Trait in d&gt;</code><td><code class="language-plaintext highlighter-rouge">A</code><tr><td><code class="language-plaintext highlighter-rouge">a::bounded</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;A as Hash in d + Trait in d&gt;</code><td><code class="language-plaintext highlighter-rouge">A</code> ‚àò <code class="language-plaintext highlighter-rouge">Hash in d</code><tr><td><code class="language-plaintext highlighter-rouge">b::discrete</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;B as Hash in </code><strong><em><code class="language-plaintext highlighter-rouge">b</code></em></strong><code class="language-plaintext highlighter-rouge"> + Trait in</code><strong><em><code class="language-plaintext highlighter-rouge"> b</code></em></strong><code class="language-plaintext highlighter-rouge">&gt;</code><td><code class="language-plaintext highlighter-rouge">B</code><tr><td><code class="language-plaintext highlighter-rouge">b::generic</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;B as Hash in d + Trait in d&gt;</code><td><code class="language-plaintext highlighter-rouge">B</code><tr><td><code class="language-plaintext highlighter-rouge">b::bounded</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;B as Hash in d + Trait in d&gt;</code><td><code class="language-plaintext highlighter-rouge">B</code> ‚àò <code class="language-plaintext highlighter-rouge">Hash in d</code><tr><td><code class="language-plaintext highlighter-rouge">c::discrete</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;C&gt;</code><td><code class="language-plaintext highlighter-rouge">C</code><tr><td><code class="language-plaintext highlighter-rouge">c::generic</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;C as Hash in d + Trait in d&gt;</code><td><code class="language-plaintext highlighter-rouge">C</code><tr><td><code class="language-plaintext highlighter-rouge">c::bounded</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;C as Hash in d + Trait in d&gt;</code><td><code class="language-plaintext highlighter-rouge">C</code> ‚àò <code class="language-plaintext highlighter-rouge">Hash in d</code></table></div><p>The combination ‚àò is not directly expressible in <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;&gt;</code> calls (as even a direct top-level annotation would be ignored without bounds). Rather, it represents an observation like this:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">any</span><span class="p">::</span><span class="n">TypeId</span><span class="p">,</span> <span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">};</span>

    <span class="k">use</span> <span class="nn">a</span><span class="p">::</span><span class="n">A</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">d</span><span class="p">::{</span><span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">A</span><span class="p">};</span>

    <span class="k">fn</span> <span class="n">observe</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// '`A` ‚àò `Hash in d`'</span>
    <span class="p">}</span>

    <span class="nn">observe</span><span class="p">::</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h5 id="with-multiple-erased-type-parameters">with multiple erased type parameters<a href="#with-multiple-erased-type-parameters" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>By replacing the lines</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
<span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
</pre></table></code></div></div><p>with</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,)</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∂</span>
<span class="nn">TypeId</span><span class="p">::</span><span class="nn">of</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// ‚ù∑</span>
</pre></table></code></div></div><p>(and analogous inside the discrete functions), the <code class="language-plaintext highlighter-rouge">TypeId</code> table above changes as follows:</p><div class="table-wrapper"><table><thead><tr><th>within function<br />(called by <code class="language-plaintext highlighter-rouge">call_functions</code>)<th>‚ù∂ (collection)<th>‚ù∑ (item)<tbody><tr><td><code class="language-plaintext highlighter-rouge">a::discrete</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(A,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(A,)</code><tr><td><code class="language-plaintext highlighter-rouge">a::generic</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(A as Hash in d + Trait in d,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(A,)</code><tr><td><code class="language-plaintext highlighter-rouge">a::bounded</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(A as Hash in d + Trait in d,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(A</code> ‚àò <code class="language-plaintext highlighter-rouge">Hash in d,)</code><tr><td><code class="language-plaintext highlighter-rouge">b::discrete</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(B as Hash in </code><strong><em><code class="language-plaintext highlighter-rouge">b</code></em></strong><code class="language-plaintext highlighter-rouge"> + Trait in</code><strong><em><code class="language-plaintext highlighter-rouge"> b</code></em></strong><code class="language-plaintext highlighter-rouge">,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(B,)</code><tr><td><code class="language-plaintext highlighter-rouge">b::generic</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(B as Hash in d + Trait in d,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(B,)</code><tr><td><code class="language-plaintext highlighter-rouge">b::bounded</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(B as Hash in d + Trait in d,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(B</code> ‚àò <code class="language-plaintext highlighter-rouge">Hash in d,)</code><tr><td><code class="language-plaintext highlighter-rouge">c::discrete</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(C,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(C,)</code><tr><td><code class="language-plaintext highlighter-rouge">c::generic</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(C as Hash in d + Trait in d,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(C,)</code><tr><td><code class="language-plaintext highlighter-rouge">c::bounded</code><td><code class="language-plaintext highlighter-rouge">HashSet&lt;(C as Hash in d + Trait in d,)&gt;</code><td><code class="language-plaintext highlighter-rouge">(C</code> ‚àò <code class="language-plaintext highlighter-rouge">Hash in d,)</code></table></div><p>As you can see, the type identity of the tuples appears distinct when contributing to an implementation-aware generic‚Äôs type identity but (along with the <code class="language-plaintext highlighter-rouge">TypeId</code>) remains appropriately fuzzy when used alone.</p><p>This scales up to any number of type parameters used in implementation-invariant generics, which means an efficient <code class="language-plaintext highlighter-rouge">ErasedHashMap&lt;S: BuildHasher&gt;</code> can be constructed by keying storage on the <code class="language-plaintext highlighter-rouge">TypeId::of::&lt;(K, V)&gt;()</code> where <code class="language-plaintext highlighter-rouge">K: Hash + Eq</code> and <code class="language-plaintext highlighter-rouge">V</code> are the generic type parameters of its functions.</p><h3 id="logical-stability">Logical stability<a href="#logical-stability" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Non-breaking changes to external crates cannot change the meaning of the program.<li>Breaking changes should result in compile-time errors rather than a behaviour change.</ul><p>This is another consequence of subsetting rather than named-model imports, as narrowing a scoped implementation can only make the <code class="language-plaintext highlighter-rouge">use</code>-declaration fail to compile, rather than changing which implementations are shadowed.</p><p>Similarly, types of generics with different captured <em>implementation environments</em> are strictly distinct from each other, so that assigning them inconsistently does not compile. This is weighed somewhat against ease of refactoring, so in cases where a type parameter is inferred and the host is used in isolation, which are assumed to not care about implementation details like that, the code will continue to align with the definition instead of breaking.</p><h2 id="encourage-readable-code">Encourage readable code<a href="#encourage-readable-code" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This RFC aims to further decrease the mental workload required for code review, by standardising glue code APIs to some degree and by clarifying their use in other modules.</p><p>It also aims to create an import grammar that can be understood more intuitively than external newtypes when first encountered, which should improve the accessibility of Rust code somewhat.</p><h3 id="clear-imports">Clear imports<a href="#clear-imports" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>As scoped implementations bind implicitly like global ones, two aspects must be immediately clear at a glace:</p><ul><li><em>Which trait</em> is implemented?<li><em>Which type</em> is targeted?</ul><p>Restating this information in the <code class="language-plaintext highlighter-rouge">use</code>-declaration means that it is available without leaving the current file, in plaintext without any tooling assists. This is another improvement compared to newtypes or external definitions, where the relationship may not be immediately clear depending on their names.</p><p>Spelling scoped implementation imports out with keywords rather than just symbols makes their purpose easy to guess for someone unfamiliar with the scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> feature, possibly even for most English-speaking developers unfamiliar with Rust.</p><p>This is also true for blanket imports with <code class="language-plaintext highlighter-rouge">where</code>, which remain easy to parse visually due to the surrounding braces:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="n">Debug</span><span class="p">,</span> <span class="n">Display</span><span class="p">,</span> <span class="n">Pointer</span><span class="p">};</span>

<span class="c1">// `Debug` and `Display` all `Pointer`-likes as addresses.</span>
<span class="c1">// The `Display` import is different only to show the long form</span>
<span class="c1">// with `where`. It could be written like the `Debug` import.</span>
<span class="k">use</span> <span class="nn">cross_formatting</span><span class="p">::</span><span class="nn">by_pointer</span><span class="p">::{</span>
    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Pointer</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">T</span><span class="p">,</span>
    <span class="p">{</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Pointer</span><span class="p">},</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">());</span> <span class="c1">// For example: 0x7ff75584c360</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">());</span> <span class="c1">// For example: 0x7ff75584c360</span>
</pre></table></code></div></div><h3 id="familiar-grammar">Familiar grammar<a href="#familiar-grammar" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The grammar for scoped implementations differs from that for global implementations by only a prefixed <code class="language-plaintext highlighter-rouge">use</code> and an optional visibility. As such, it should be easy to parse for developers not yet familiar with scoped implementations specifically.</p><p>The clear prefix (starting with at least two keywords instead of one) should still be enough to distinguish scoped implementations at a glance from global ones.</p><p>The header (the part before the <code class="language-plaintext highlighter-rouge">{}</code> block) of global implementations is reused unchanged for scoped implementation imports, including all bounds specifications, so there is very little grammar to remember additionally in order to <code class="language-plaintext highlighter-rouge">use</code> scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s.</p><p>In each case, the meaning of identical grammar elements lines up exactly - only their context and perspective vary due to immediately surrounding tokens.</p><p>(See <a href="#grammar-changes">grammar-changes</a> for details.)</p><h3 id="stop-tokens-for-humans">Stop tokens for humans<a href="#stop-tokens-for-humans" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>When looking for the scoped implementation affecting a certain type, strict shadowing ensures that it is always the closest matching one that is effective.</p><p>As such, readers can stop scanning once they encounter a match (or module boundary, whether surrounding or nested), instead of checking the entire file‚Äôs length for another implementation that may be present in the outermost scope.</p><p>Aside from <em>implementation environments</em> captured <em>inside</em> generics, scoped implementations cannot influence the behaviour of another file without being mentioned explicitly.</p><h2 id="unblock-ecosystem-evolution">Unblock ecosystem evolution<a href="#unblock-ecosystem-evolution" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>As any number of scoped glue implementations can be applied directly to application code without additional compatibility shims, it becomes far easier to upgrade individual dependencies to their next major version. Compatibility with multiple versions of crates like Serde and <code class="language-plaintext highlighter-rouge">bevy_reflect</code> can be provided in parallel through officially supported glue crates.</p><p>Additionally, scoped implementations are actually <em>more</em> robust than newtypes regarding certain breaking changes:</p><p>A newtype that implements multiple traits could eventually gain a global blanket implementation of one of its traits for types that implement another of its traits, causing a conflict during the upgrade.</p><p>In the presence of an overlapping scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>, the new blanket implementation is just unambiguously shadowed where it would conflict, which means no change is necessary to preserve the code‚Äôs behaviour. A <a href="#global-trait-implementation-available">global-trait-implementation-available</a> warning is still shown where applicable to alert maintainers of new options they have.</p><p>(See also <a href="#glue-crate-suggestions">glue-crate-suggestions</a> for possible future tooling related to this pattern.)</p><h3 id="side-effect-parallelise-build-plans-somewhat-more">Side-effect: Parallelise build plans (somewhat) more<a href="#side-effect-parallelise-build-plans-somewhat-more" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Serde often takes a long time to build even without its macros. If another complex crate depends on it just to support its traits, this can significantly stretch the overall build time.</p><p>If glue code for ‚Äòoverlay‚Äô features like Serde traits is provided in a separate crate, that incidentally helps to reduce that effect somewhat:</p><p>Since the glue forms a second dependency chain that normally only rejoins in application code, the often heavier core functionality of libraries can build in parallel to Serde and/or earlier glue. Since the glue chain is likely to be less code, it matters less for overall build time whether it has to wait for one or two large crates first.</p><h2 id="provide-opportunities-for-rich-tooling">Provide opportunities for rich tooling<a href="#provide-opportunities-for-rich-tooling" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="discovery-of-implementations">Discovery of implementations<a href="#discovery-of-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>As scoped implementations clearly declare the link between the trait and type(s) they connect, tools like rust-analyzer are able to index them and suggest imports where needed, just like for global traits.</p><p>(At least when importing from another crate, the suggested import should be for a specific type or generic, even if the export in question is a blanket implementation. Other generics of the export can usually be preserved, though.)</p><h3 id="discovery-of-the-feature-itself">Discovery of the feature itself<a href="#discovery-of-the-feature-itself" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>In some cases (where a trait implementations cannot be found at all), tools can suggest creating a scoped implementation, unless adding it in that place would capture it as part of the <em>implementation environment</em> of a type parameter specified in an item definition visible outside the current crate.</p><p>That said, it would be great if rust-analyzer could detect and suggest/enable feature-gated global implementations to some extent, with higher priority than creating a new scoped implementation.</p><h3 id="rich-and-familiar-warnings-and-error-messages">Rich and familiar warnings and error messages<a href="#rich-and-familiar-warnings-and-error-messages" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Since scoped implementations work much like global ones, many of the existing errors and warnings can be reused with at most small changes. This means that, as developers become more familiar with either category of trait-related issues, they learn how to fix them for global and scoped implementations at the same time.</p><p>The implementation of the errors and warnings in the compiler can also benefit from the existing work done for global implementations, or in some cases outright apply the same warning to both scoped and global implementations.</p><p>Since available-but-not-imported scoped implementations are easily discoverable by the compiler, they can be used to improve existing errors like <em>error[E0277]: the trait bound <code class="language-plaintext highlighter-rouge">[‚Ä¶]</code> is not satisfied</em> and <em>error[E0599]: no method named <code class="language-plaintext highlighter-rouge">[‚Ä¶]</code> found for struct <code class="language-plaintext highlighter-rouge">[‚Ä¶]</code> in the current scope</em> with quick-fix suggestions also for using an existing scoped implementation in at least some cases.</p><h3 id="maintenance-warnings-for-ecosystem-evolution">Maintenance warnings for ecosystem evolution<a href="#maintenance-warnings-for-ecosystem-evolution" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s lead to better maintenance lints:</p><p>If a covering global implementation later becomes available through a dependency, a warning can be shown on the local trait implementation for review. (See <a href="#global-trait-implementation-available">global-trait-implementation-available</a>.)</p><p>In the long run, this can lead to less near-duplicated functionality in the dependency graph, which can lead to smaller executable sizes.</p><h3 id="automatic-documentation">Automatic documentation<a href="#automatic-documentation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Scoped implementations can be documented and appear as separate item category in rustdoc-generated pages.</p><p>Rustdoc should be able to detect and annotate captured scoped implementations in public signatures automatically. This, in addition to warnings, could be another tool to help avoid accidental exposure of scoped implementations.</p><p>Implementation origin and documentation could be surfaced by rust-analyzer in relevant places.</p><h2 id="why-specific-implementation-invariant-generics">Why specific <a href="#implementation-invariant-generics">implementation-invariant-generics</a>?<a href="#why-specific-implementation-invariant-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This is a <em>not entirely clean</em> ergonomics/stability trade-off, as well as a clean resolution path for <a href="#behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters">behaviour-changewarning-typeid-of-implementation-aware-generic-discretised-using-generic-type-parameters</a>.</p><blockquote><p>It is also the roughest part of this proposal, in my eyes. If you have a better way of dealing with the aware/invariant distinction, please do suggest it!</p></blockquote><p>The main issue is that generics in the Rust ecosystem do not declare which trait implementations on their type parameters need to be consistent during their instances‚Äô lifetime, if any, and that traits like <code class="language-plaintext highlighter-rouge">PartialOrd</code> that do provide logical consistency guarantees over time are not marked as such in a compiler-readable way.</p><p>Ignoring this and not having distinction of <a href="#implementation-aware-generics">implementation-aware-generics</a>‚Äô discretised variants would badly break logical consistency of generic collections like <code class="language-plaintext highlighter-rouge">BTreeSet&lt;T&gt;</code>, which relies on <code class="language-plaintext highlighter-rouge">Ord</code>-consistency to function.</p><p>On the other hand, certain types (e.g. references and (smart) pointers) that often wrap values in transit between modules <em>really</em> don‚Äôt care about implementation consistency on these types. If these were distinct depending on available implementations on their values, it would create <em>considerable</em> friction while defining public APIs in the same scope as <code class="language-plaintext highlighter-rouge">struct</code> or <code class="language-plaintext highlighter-rouge">enum</code> definitions that require scoped implementations for <code class="language-plaintext highlighter-rouge">derive</code>s.</p><p>Drawing a line manually here is an attempt to un-break this <em>by default</em> for the most common cases while maintaining full compatibility with existing code and keeping awareness of scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> entirely optional for writing correct and user-friendly APIs.</p><p>As a concrete example, this ensures that <code class="language-plaintext highlighter-rouge">Box&lt;dyn Future&lt;Output = Result&lt;(), Error&gt;&gt;&gt;</code> is automatically interchangeable even if spelled out in the presence of scoped <a href="#error-handling-and-conversions">error-handling-and-conversions</a> affecting <code class="language-plaintext highlighter-rouge">Error</code>, but that <code class="language-plaintext highlighter-rouge">BinaryHeap&lt;Box&lt;u8&gt;&gt;</code> and <code class="language-plaintext highlighter-rouge">BinaryHeap&lt;Box&lt;u8 as PartialOrd in reverse + Ord in reverse&gt;&gt;</code> don‚Äôt mix.</p><p>Functions pointers and closure trait( object)s should probably be fairly easy to pass around, with their internally-used bindings being an implementation detail. Fortunately, the Rust ecosystem already uses more specific traits for most configuration for better logical safety, so it‚Äôs likely not too messy to make these implementation-invariant.</p><p>Traits and trait objects cannot be implementation invariant by default (including for their associated types!) because it‚Äôs already possible to define <code class="language-plaintext highlighter-rouge">OrderedExtend</code> and <code class="language-plaintext highlighter-rouge">OrderedIterator</code> traits with logical consistency requirement on <code class="language-plaintext highlighter-rouge">Ord</code> between them.</p><h2 id="efficient-compilation">Efficient compilation<a href="#efficient-compilation" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>In theory, it should be possible to unify many instances of generic functions that may be polymorphic under this proposal cheaply before code generation. (Very few previously discrete implementations become polymorphic under scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>.)</p><p>This is mainly an effect of <a href="#layout-compatibility">layout-compatibility</a> and <a href="#binding-choice-by-implementations-bounds">binding-choice-by-implementations-bounds</a>, so that, where the differences are only bounds-irrelevant, generated implementations are easily identical in almost all cases. The exception here are <a href="#implementation-aware-generics">implementation-aware-generics</a>‚Äô <code class="language-plaintext highlighter-rouge">TypeId</code>s (see also <a href="#typeid-of-generic-type-parameters-opaque-types">typeid-of-generic-type-parameters-opaque-types</a>). Checking for this exception should be cheap if done alongside checks for e.g. function non-constness if possible, which propagates identically from callee to caller.</p><p>Given equal usage, compiling code that uses scoped implementations could as such be slightly more efficient compared to use of newtypes and the resulting text size may be slightly smaller in some cases where newtype implementations are inlined differently.</p><p>The compiler should treat implementations of the same empty trait on the same type as identical early on, so that no code generation is unnecessarily duplicated. However, unrelated empty-trait implementations must still result in distinct <code class="language-plaintext highlighter-rouge">TypeId</code>s when captured in a generic type parameter and observed there by a <code class="language-plaintext highlighter-rouge">where</code>-clause or through nesting in an implementation-aware generic.</p><h2 id="alternatives">Alternatives<a href="#alternatives" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="named-implementations">Named implementations<a href="#named-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Use of named implementations is not as obvious as stating the origin-trait-type triple in close proximity, so code that uses named implementations tends to be harder to read.</p><p>Like named implementations, the scope-identified implementations proposed here can be written concisely in generic parameter lists (as <code class="language-plaintext highlighter-rouge">Type as Trait in module</code>), limiting the code-writing convenience advantage of named implementations. Where needed, the module name can be chosen to describe specific function, e.g. exporting reverse-ordering <code class="language-plaintext highlighter-rouge">Ord</code> and <code class="language-plaintext highlighter-rouge">PartialOrd</code> implementations from a module called <code class="language-plaintext highlighter-rouge">reverse</code>.</p><p>If named implementations can‚Äôt be brought into scope (see Genus in <a href="#lightweight-flexible-object-oriented-generics">lightweight-flexible-object-oriented-generics</a>), that limits their practical application to where they can be captured in <a href="#implementation-aware-generics">implementation-aware-generics</a>. Bringing named implementations into scope would be more verbose than for module-trait-type-identified as subsetting would still be required to preserve useful room for library crate evolution.</p><h3 id="weakening-coherence-rules">Weakening coherence rules<a href="#weakening-coherence-rules" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is likely still some leeway here before the Rust ecosystem becomes brittle, but at least the orphan rule specifically is essential for ensuring that global trait implementations do not lead to hard ecosystem splits due to strictly incompatible framework crates.</p><p>If <em>other</em> coherence rules are relaxed, scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> also benefits immediately since it is subject to all of them.</p><h3 id="crate-private-implementations-as-distinct-feature">Crate-private implementations as distinct feature<a href="#crate-private-implementations-as-distinct-feature" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is a previous <a href="https://github.com/rust-lang/rfcs/pull/2529">RFC: Hidden trait implementations</a> from 2018-2021 where the result was general acceptance, but postponement for logistical reasons.</p><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> together with its warnings <a href="#scoped-implementation-is-less-visible-than-itemfield-it-is-captured-in">scoped-implementation-is-less-visible-than-itemfield-it-is-captured-in</a> and <a href="#imported-implementation-is-less-visible-than-itemfield-it-is-captured-in">imported-implementation-is-less-visible-than-itemfield-it-is-captured-in</a> can mostly cover this use-case, though with slightly more boilerplate (<code class="language-plaintext highlighter-rouge">use</code>-declarations) and not as-strict a limitation.</p><h3 id="required-explicit-binding-of-scoped-implementations-inside-generics">Required-explicit binding of scoped implementations inside generics<a href="#required-explicit-binding-of-scoped-implementations-inside-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>This could avoid the distinction between <a href="#implementation-aware-generics">implementation-aware-generics</a> and <a href="#implementation-invariant-generics">implementation-invariant-generics</a> to some extent, at the cost of likely overall worse ergonomics when working with scoped implementations.</p><p>It‚Äôs also likely to make <code class="language-plaintext highlighter-rouge">derive</code>-compatibility of scoped implementations inconsistent, because some macros may require explicit binding on field types while others would not.</p><h1 id="prior-art">Prior art</h1><h2 id="lightweight-flexible-object-oriented-generics">Lightweight, Flexible Object-Oriented Generics<a href="#lightweight-flexible-object-oriented-generics" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Yizhou Zhang, Matthew Loring, Guido Salvaneschi, Barbara Liskov and Andrew C. Myers, May 2015</p><p><a href="https://www.cs.cornell.edu/andru/papers/genus/">https://www.cs.cornell.edu/andru/papers/genus/</a></p><p>There are some parallels between Genus‚Äôs models and the scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s proposed in this RFC, but for the most part they are quite distinct due to Rust‚Äôs existing features:</p><div class="table-wrapper"><table><thead><tr><th>Genus<th>scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code><th>reasoning<tbody><tr><td>Proper-named models<td>Anonymous scoped implementations<td>Use of existing coherence constraints for validation. Forced subsetting in <code class="language-plaintext highlighter-rouge">use</code>-declarations improves stability. The <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> syntax stands out in <code class="language-plaintext highlighter-rouge">use</code>-declarations and is intuitively readable.<tr><td>Explicit bindings of non-default models<td>Mainly implicit bindings, but explicit bindings of scoped <em>and global</em> implementations are possible in some places.<td>Focus on simplicity and ergonomics of the most common use-case. More natural use with future specialisation.<tr><td>Comparing containers inherently constrain type parameters in their type definition.<td>Available scoped implementations for discretised type parameters become part of the type identity.<td>&lt;p&gt;This is a tradeoff towards integration with Rust‚Äôs ecosystem, as generics are generally not inherently bounded on collection types in Rust.&lt;/p&gt;&lt;p&gt;There is likely some friction here with APIs that make use of runtime type identity. See <a href="#split-type-identity-may-be-unexpected">split-type-identity-may-be-unexpected</a>.&lt;/p&gt;</table></div><p>Some features are largely equivalent:</p><div class="table-wrapper"><table><thead><tr><th>Genus<th>Rust (<em>without</em> scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>)<th>notes / scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code><tbody><tr><td>Implicitly created default models<td>Explicit global trait implementations<td>Duck-typed implementation of unknown external traits is unnecessary since third party crates‚Äô implementations are as conveniently usable in scope as if global.<tr><td>Runtime model information / Wildcard models<td>Trait objects<td>Scoped implementations can be captured in trait objects, and the <code class="language-plaintext highlighter-rouge">TypeId</code> of generic type parameters can be examined. This does not allow for invisible runtime specialisation in all cases.<tr><td>Bindings [only for inherent constraints on generic type parameters?] are part of type identity<td>not applicable<td>&lt;p&gt;Available implementations on type parameters of discretised implementation-aware generics are part of the type identity. Top-level bindings are not.&lt;/p&gt;&lt;p&gt;Genus‚Äôs approach provides better remote-access ergonomics than ùí¢‚Äôs and great robustness when moving instances through complex code, so it should be available. Fortunately, the existing style of generic implementations in Rust can simply be monomorphised accordingly, and existing reflexive blanket conversions and comparisons can bind regardless of unrelated parts of the top-level <em>implementation environment</em> of their type parameters.&lt;/p&gt;&lt;p&gt;However, typical Rust code also very heavily uses generics like references and closures to represent values passed through crate boundaries. To keep friction acceptably low by default, specific utility types are exempt from capturing <em>implementation environments</em> in their type parameters.&lt;/p&gt;</table></div><h2 id="a-language-for-generic-programming-in-the-large">A Language for Generic Programming in the Large<a href="#a-language-for-generic-programming-in-the-large" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Jeremy G. Siek, Andrew Lumsdaine, 2007</p><p><a href="https://arxiv.org/abs/0708.2255">https://arxiv.org/abs/0708.2255</a></p><p>ùí¢ and scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> are conceptually very similar, though this RFC additionally solves logical consistency issues that arise from having multiple alternative ways to fulfill a constraint and develops some ideas further than the paper. Other differences are largely due to ùí¢ being more C++-like while scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> attempts smooth integration with all relevant Rust language features.</p><p>A few notable similarities, in the paper‚Äôs words:</p><ul><li>equivalent retroactive modeling (where existing Rust‚Äôs is limited by orphan rules),<li>(retained) separate compilation (though <em>some</em> information can flow between items in this RFC, but only where such information flows already exist in Rust currently),<li>lexically scoped models,<li>seemingly the same binding rules on generic type parameters within constrained models/generic implementations,</ul><p>and key differences:</p><div class="table-wrapper"><table><thead><tr><th>ùí¢<th>Rust / scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code><th>notes<tbody><tr><td>Only discrete model imports<td>Includes generic imports and re-exports<td>This is pointed out as ‚Äò[left] for future work‚Äô in the paper. Here, it follows directly from the syntax combination of Rust‚Äôs <code class="language-plaintext highlighter-rouge">use</code> and <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> items.<tr><td>-<td>(Rust) Global implementations<td>The automatic availability of global implementations between separately imported traits and types offers more convenience especially when working with common traits, like those backing operators in Rust.<tr><td>Model overloading, mixed into nested scopes<td>Strict shadowing<td>Strict shadowing is easier to reason about for developers (especially when writing macros!), as the search stops at the nearest matching implementation or module boundary.<br />See Rust‚Äôs trait method resolution behaviour and <a href="#interaction-with-specialisation">interaction-with-specialisation</a> for how this is still practically compatible with a form of overload resolution.<br />See <a href="#scoped-fallback-implementations">scoped-fallback-implementations</a> for a possible future way to better enable adaptive behaviour in macro output.<tr><td>-<td>(Rust) Trait objects<td>ùí¢ does not appear to support runtime polymorphism beyond function pointers. Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> is seamlessly compatible with <code class="language-plaintext highlighter-rouge">dyn Trait</code> coercions (iff <code class="language-plaintext highlighter-rouge">Trait</code> is object-safe).<tr><td>(unclear?)<td>Available implementations on discretised type parameters become part of the type identity of implementation-aware generics.<td>This allows code elsewhere to access scoped implementations that are already available at the definition site, and leads to overall more semantically consistent behaviour.</table></div><h1 id="unresolved-questions">Unresolved questions</h1><h2 id="global-implementations">‚Äúglobal‚Äù implementations<a href="#global-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>I‚Äôm not too sure about the ‚Äúglobal‚Äù wording. <em>Technically</em> that implementation isn‚Äôt available for method calls unless the trait is in scope‚Ä¶ though it is available when resolving generics. Maybe ‚Äúunscoped‚Äù is better?</p><h2 id="precise-resolution-location-of-implementation-environments-in-function-calls">Precise resolution location of <em>implementation environments</em> in function calls<a href="#precise-resolution-location-of-implementation-environments-in-function-calls" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>In macros, which function-call token should provide the resolution context from where to look for scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s (in all possible cases)?</p><p>This doesn‚Äôt matter for <code class="language-plaintext highlighter-rouge">Span::call_site()</code> vs. <code class="language-plaintext highlighter-rouge">Span::mixed_site()</code> since scoped implementations would resolve transparently through both, but it does matter for <code class="language-plaintext highlighter-rouge">Span::def_site()</code> which should exclude them.</p><p>It very much does matter if one of the opt-in mitigations for <a href="#first-party-implementation-assumptions-in-macros">first-party-implementation-assumptions-in-macros</a> is implemented.</p><h2 id="which-structs-should-be-implementation-invariant">Which <code class="language-plaintext highlighter-rouge">struct</code>s should be implementation-invariant?<a href="#which-structs-should-be-implementation-invariant" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This is a tough question because, runtime behaviour difference of <a href="#of-type-erased-collections">of-type-erased-collections</a> aside, the following makes shifting a type from <a href="#implementation-aware-generics">implementation-aware-generics</a> to <a href="#implementation-invariant-generics">implementation-invariant-generics</a> a compilation-breaking change:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Type</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="k">trait</span> <span class="n">Trait</span> <span class="p">{}</span>

<span class="k">mod</span> <span class="n">a</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Type</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Trait</span><span class="p">};</span>
    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">b</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Type</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Trait</span><span class="p">};</span>
    <span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="nn">a</span><span class="p">::</span><span class="n">Alias</span> <span class="p">{}</span>
<span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="nn">b</span><span class="p">::</span><span class="n">Alias</span> <span class="p">{}</span>
</pre></table></code></div></div><p>(It is <em>theoretically</em> possible to do such a later adjustment as part of an edition, even considering <code class="language-plaintext highlighter-rouge">TypeId</code> behaviour I think, but it‚Äôs certainly not pretty.)</p><p>Splitting this along the line of ‚Äústructs that use <code class="language-plaintext highlighter-rouge">&lt;&gt;</code> around type parameters‚Äù would feel cleaner, but the basic smart pointers, <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>, <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> appear in crate API signatures enough that not including them would create considerable friction.</p><p>Other candidates for consideration:</p><ul><li>Other <code class="language-plaintext highlighter-rouge">DispatchFromDyn</code> types in the standard library like <code class="language-plaintext highlighter-rouge">Cell</code>, <code class="language-plaintext highlighter-rouge">SyncUnsafeCell</code>, <code class="language-plaintext highlighter-rouge">UnsafeCell</code></ul><h2 id="should-it-be-an-error-to-specify-an-implementation-environment-in-places-where-its-guaranteed-to-be-unused">Should it be an error to specify an <em>implementation environment</em> in places where it‚Äôs guaranteed to be unused?<a href="#should-it-be-an-error-to-specify-an-implementation-environment-in-places-where-its-guaranteed-to-be-unused" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>With the given <a href="#grammar-changes">grammar-changes</a>, it‚Äôs possible to write <code class="language-plaintext highlighter-rouge">fn((Type as Trait in module))</code>, but, at least without a surrounding host, here the <em>implementation environment</em> written inline is completely ineffective because function pointer types are discretised <a href="#implementation-invariant-generics">implementation-invariant-generics</a>.</p><p>On the other hand, making it an error rather than a <a href="#unused-scoped-implementation">unused-scoped-implementation</a> warning could easily cause problems for macros.</p><h1 id="future-possibilities">Future possibilities</h1><h2 id="exporting-a-scoped-implementation-as-global-extern-impl-trait">Exporting a scoped implementation as global, <code class="language-plaintext highlighter-rouge">extern impl Trait</code><a href="#exporting-a-scoped-implementation-as-global-extern-impl-trait" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong><em>This should never be used for IO/serialisation traits.</em></strong></p><p>Application crates may want to provide a specific implementation globally, disregarding orphan rules since there are no downstream crates that could be impacted by future incompatibilities (and crate-local issues are largely mitigated by <em>Cargo.lock</em>).</p><p>This could later be allowed using a construct like</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// Use an external implementation as global:</span>
<span class="nd">#[core::unstable_use_as_global]</span>
<span class="k">use</span> <span class="nn">impl_crate</span><span class="p">::{</span><span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">};</span>

<span class="c1">// Provide a local implementation globally:</span>
<span class="nd">#[core::unstable_use_as_global]</span>
<span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</pre></table></code></div></div><p>To use a global implementation not available through one of its dependencies, a library crate would have to declare it:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">;</span>
</pre></table></code></div></div><p>This would result in a compile error or link-time error if the declaration is not fully covered by a global trait implementation.</p><p>If the trait implementation is later made available plainly (that is: without <code class="language-plaintext highlighter-rouge">use</code>, subject to orphan rules) by a dependency, a warning should appear on the <code class="language-plaintext highlighter-rouge">extern impl</code> declaration, along with the suggestion to remove the <code class="language-plaintext highlighter-rouge">extern impl</code> item.</p><p>(However, I assume binding to implementations not-from dependencies or the same crate in this way has a lot of implications for code generation.)</p><p>There is previous discussion regarding a similar suggestion in a slightly different context: <a href="https://internals.rust-lang.org/t/pre-rfc-forward-impls/4628">[Pre-RFC] Forward impls</a><br /> Perhaps the downsides here could be mitigated by allowing <code class="language-plaintext highlighter-rouge">#[unstable_use_as_global]</code> very strictly only in application crates compiled with the <code class="language-plaintext highlighter-rouge">cargo --locked</code> flag.</p><h2 id="scoped-impl-trait-for-type-of-auto-traits-drop-andor-copy-with-orphan-rules">Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> of auto traits, <code class="language-plaintext highlighter-rouge">Drop</code> and/or <code class="language-plaintext highlighter-rouge">Copy</code> with orphan rules<a href="#scoped-impl-trait-for-type-of-auto-traits-drop-andor-copy-with-orphan-rules" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The crate in which a type is defined could in theory safely provide scoped implementations for it also for these traits.</p><ul><li><p>This is likely more complicated to implement than the scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>s proposed in this RFC, as these traits interact with more distinct systems.</p><li><p>What would be the binding site of <code class="language-plaintext highlighter-rouge">Drop</code> in <code class="language-plaintext highlighter-rouge">let</code>-statements?</p><li><p>This could interact with linear types, were those to be added later on.</p><p>For example, database transactions could be opt-out linear by being <code class="language-plaintext highlighter-rouge">!Drop</code> globally but also having their crate provide a scoped <code class="language-plaintext highlighter-rouge">Drop</code> implementation that can be imported optionally to remove this restriction in a particular consumer scope.</p></ul><h2 id="scoped-proxy-implementations">Scoped proxy implementations<a href="#scoped-proxy-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>In theory it <em>might</em> be possible to later add syntax to create an exported implementation that‚Äôs <em>not in scope for itself</em>.</p><p>I‚Äôm <strong>very</strong> hesitant about this since doing so would allow transparent overrides of traits (i.e. proxying), which could be abused for JavaScript-style layered overrides through copy-pasting source code together to some extent.</p><h2 id="analogous-scoped-impl-type">Analogous scoped <code class="language-plaintext highlighter-rouge">impl Type</code><a href="#analogous-scoped-impl-type" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This could be considered as more-robust alternative to non-object-safe extension traits defined in third party crates.</p><p>A good example of this use case could be the <a href="https://crates.io/crates/tap">tap</a> crate, which provides generic extension methods applicable to <em>all</em> types, but where its use is <em>theoretically</em> vulnerable to instability regarding the addition of type-associated methods of the same name(s).</p><p>If instead of (or in addition to!) ‚Ä¶:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// pipe.rs</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Pipe</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">pipe</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">R</span>
    <span class="k">where</span>
        <span class="k">Self</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nf">func</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Pipe</span> <span class="k">for</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span> <span class="p">{}</span>
</pre></table></code></div></div><p>‚Ä¶the extension could be defined as ‚Ä¶:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span> <span class="p">{</span>
  <span class="nd">#[inline(always)]</span>
  <span class="k">fn</span> <span class="n">pipe</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">R</span>
  <span class="k">where</span>
      <span class="k">Self</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">,</span>
      <span class="n">R</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">,</span>
  <span class="p">{</span>
      <span class="nf">func</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>‚Ä¶then:</p><ul><li><p>The consumer crate could choose which types to import the extension for, weighing</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="nn">pipe</span><span class="p">::{</span><span class="k">impl</span> <span class="n">Type1</span><span class="p">,</span> <span class="k">impl</span> <span class="n">Type2</span><span class="p">};</span>
</pre></table></code></div></div><p>against</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="nn">pipe</span><span class="p">::{</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">};</span>
</pre></table></code></div></div><li><p>These <em>scoped extensions would shadow inherent type-associated items of the same name</em>, guaranteeing stability towards those being added.</p><p>(This should come with some warning labels in the documentation for this feature, since <em>adding items to an existing public scoped extension</em> could be considered an easily-breaking change here.)</p></ul><p>This has fewer benefits compared to scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>, but would still allow the use of such third-party extension APIs in library crates with very high stability requirements.</p><p>An open question here is whether (and how) to allow partially overlapping <code class="language-plaintext highlighter-rouge">use impl Type</code> in the same scope, in order to not shadow inherent associated items with ones that cannot be implemented for the given type.</p><ul><li><p>That could in theory be more convenient to use, but</p><li><p>calls could be <em>subtly</em> inconsistent at the consumer side, i.e. accidentally calling an inherent method if a scoped extension method was expected and</p><li><p>widening a public implementation to overlap more of another exported in the same module could break dependent crates if a wide blanket import applied to narrower extensions.</p></ul><p>As such, <em>if</em> this feature was proposed and accepted at some point in the future, it would likely be a good idea to only allow non-overlapping implementations to be exported.</p><h2 id="interaction-with-specialisation">Interaction with specialisation<a href="#interaction-with-specialisation" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> can be used for consumer-side specialisation of traits for binding sites that are in item scope, by partially shadowing an outer scope‚Äôs implementation.</p><p>Note that this would <strong>not</strong> work on generic type parameters, as the selected implementation is controlled strictly by their bounds (See <a href="#resolution-on-generic-type-parameters">resolution-on-generic-type-parameters</a>.), but it would work in macros for the most part.</p><p>This does not interact with <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialisation proper</a>, but rather is a distinct, less powerful mechanism. As such, it would not supersede specialisation.</p><li><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> does not significantly interact with specialisation of global implementations.</p><p>Any global specialisation would only be resolved once it‚Äôs clear no scoped implementation applies.</p><li><p>Specialisation could disambiguate scoped implementations which are provided (implemented or imported) in the same scope. For example,</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">dummy_debug</span><span class="p">::{</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">T</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">debug_by_display</span><span class="p">::{</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">T</span><span class="p">};</span>
<span class="k">use</span> <span class="k">impl</span> <span class="n">Debug</span> <span class="k">for</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>would then compile, in scope resolving <code class="language-plaintext highlighter-rouge">&lt;str as Debug&gt;</code> to the local implementation and otherwise binding <code class="language-plaintext highlighter-rouge">Debug</code> depending on whether <code class="language-plaintext highlighter-rouge">Display</code> is available at the binding site for each given type <code class="language-plaintext highlighter-rouge">T</code>.</p><p>Local implementations do not necessarily have to be more specific compared to imported ones - in keeping with ‚Äúthis is the same as for global implementations‚Äù, the way in which the scoped implementation is introduced to the scope should not matter to specialisation.</p><p><strong>When importing scoped implementations from a module, specialisation should apply hierarchically.</strong> First, the specificity of implementations is determined only by <code class="language-plaintext highlighter-rouge">use impl</code> implementations and <code class="language-plaintext highlighter-rouge">use</code>-declarations in the importing scope. If the trait bound binds to a <code class="language-plaintext highlighter-rouge">use</code>-declaration, then the actual implementation is chosen by specificity among those visible in the module they are imported from. If the chosen implementation there is an import, the process repeats for the next module. This ensures stability and coherence when published implementations are specialised in other modules.</p><ul><li><p>I‚Äôm not sure how well this can be cached in the compiler for binding-sites in distinct scopes, unfortunately. Fortunately, specialisation of scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> does not seem like a blocker for specialisation of global trait implementations.</p><li><p>Should specialisation of scoped implementations require equal visibility? I think so, but this question also seems considerably out of scope for scoped <code class="language-plaintext highlighter-rouge">impl Trait as Type</code> as a feature itself.</p></ul></ul><h2 id="scoped-impl-trait-for-type-as-associated-item">Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> as associated item<a href="#scoped-impl-trait-for-type-as-associated-item" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code> could be allowed and used as associated non-object-safe item as follows:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">OuterTrait</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">OuterTrait</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">T</span><span class="p">::{</span><span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span><span class="p">};</span>
    <span class="c1">// ...configured code...</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">impl</span> <span class="n">OuterTrait</span> <span class="k">for</span> <span class="n">OtherType</span> <span class="p">{</span>
    <span class="c1">// Or via `use`-declaration of scoped implementation(s) defined elsewhere!</span>
    <span class="c1">// Or specify that the global implementation is used (somehow)!</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nn">function</span><span class="p">::</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="o">&gt;</span><span class="p">();</span>
</pre></table></code></div></div><p>This would exactly supersede the following more verbose pattern enabled by this RFC:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">OuterTrait</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Impl</span><span class="p">:</span> <span class="n">ImplTraitFor</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">ImplTraitFor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Copy of trait's associated items, but using `T` instead of the `Self` type and</span>
    <span class="c1">// e.g. a parameter named `this` in place of `self`-parameters.</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">OuterTrait</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type</span> <span class="p">{</span>
        <span class="c1">// Implement using `T::Impl`, associated item by associated item.</span>
    <span class="p">}</span>

    <span class="c1">// ...configured code...</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ImplTraitForType</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">ImplTraitFor</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">ImplTraitForType</span> <span class="p">{</span>
    <span class="c1">// Implement item-by-item, as existing scoped `impl Trait for Type` cannot be used here.</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">OuterTrait</span> <span class="k">for</span> <span class="n">OtherType</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Impl</span><span class="p">:</span> <span class="n">ImplTraitFor</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ImplTraitForType</span><span class="p">;</span>
<span class="p">}</span>

<span class="nn">function</span><span class="p">::</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="o">&gt;</span><span class="p">();</span>
</pre></table></code></div></div><ul><li><em>In theory</em> this could be made object-safe if the associated implementation belongs to an object-safe trait, but this would introduce much-more-implicit call indirection into Rust.</ul><h2 id="scoped-fallback-implementations">Scoped fallback implementations<a href="#scoped-fallback-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>A scoped fallback implementation could be allowed, for example by negatively bounding it <em>on the same trait</em> in the definition or import:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Type1</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Type2</span><span class="p">;</span>

<span class="p">{</span>
    <span class="k">use</span> <span class="nn">debug_fallback</span><span class="p">::{</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="o">!</span><span class="n">Debug</span><span class="p">};</span>

    <span class="nd">dbg!</span><span class="p">(</span><span class="n">Type1</span><span class="p">);</span> <span class="c1">// Compiles, uses global implementation.</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="n">Type2</span><span class="p">);</span> <span class="c1">// Compiles, uses fallback implementation.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This would be a considerably less messy alternative to <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">autoref-</a> or <a href="https://lukaskalbertodt.github.io/2019/12/05/generalized-autoref-based-specialization.html">autoderef-specialisation</a> for macro authors.</p><p>Note that ideally, these fallback implementations would still be required to not potentially overlap with any other (plain or fallback) scoped implementation brought into that same scope.</p><h2 id="negative-scoped-implementations">Negative scoped implementations<a href="#negative-scoped-implementations" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>It‚Äôs technically possible to allow negative scoped implementations that only shadow the respective implementation from an outer scope. For example:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// signed-indexing/src/arrays/prelude.rs</span>
<span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Index</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Index</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="p">{}</span>
<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="nd">#[inline]</span>
    <span class="nd">#[track_caller]</span>
    <span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">index</span> <span class="p">{</span>
            <span class="mi">0</span><span class="o">..</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="p">[</span><span class="n">index</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">],</span>
            <span class="o">..=-</span><span class="mi">1</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.checked_add_signed</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">#[inline(never)]</span>
                <span class="nd">#[track_caller]</span>
                <span class="k">fn</span> <span class="nf">out_of_bounds</span><span class="p">(</span><span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
                    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Tried to index slice of length {len} with index {index}, which is too negative to index backwards here."</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="nf">out_of_bounds</span><span class="p">(</span><span class="k">self</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">index</span><span class="p">);</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">signed_indexing</span><span class="p">::</span><span class="nn">arrays</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">let</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="c1">// Unambiguous:</span>
<span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">let</span> <span class="n">last</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</pre></table></code></div></div><p>This is likely a rather niche use-case.</p><p>It could also be useful in the context of <a href="#scoped-fallback-implementations">scoped-fallback-implementations</a>.</p><h2 id="implicit-import-of-supertrait-implementations-of-scoped-implementations-defined-on-discrete-types">Implicit import of supertrait implementations of scoped implementations defined on discrete types<a href="#implicit-import-of-supertrait-implementations-of-scoped-implementations-defined-on-discrete-types" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>As subtype implementations defined on discrete types always require specific supertrait implementations, the import of these supertrait implementations could be made implicit.</p><p>This would also affect <em>implementation environments</em> modified in generic arguments, changing</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="n">min_heap</span><span class="p">:</span> <span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="nb">u32</span> <span class="k">as</span> <span class="nb">PartialOrd</span> <span class="n">in</span> <span class="n">reverse</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="n">in</span> <span class="n">reverse</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="nf">.into</span><span class="p">();</span>
</pre></table></code></div></div><p>to</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="n">min_heap</span><span class="p">:</span> <span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">:</span> <span class="nb">Ord</span> <span class="n">in</span> <span class="n">reverse</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="nf">.into</span><span class="p">();</span>
</pre></table></code></div></div><p>and</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nd">dbg!</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">u32</span> <span class="k">as</span> <span class="nb">Ord</span> <span class="n">in</span> <span class="n">reverse</span> <span class="k">where</span> <span class="nb">u32</span> <span class="k">as</span> <span class="nb">PartialOrd</span> <span class="n">in</span> <span class="n">reverse</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// [‚Ä¶] = Greater</span>
</pre></table></code></div></div><p>to</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nd">dbg!</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">u32</span> <span class="k">as</span> <span class="nb">Ord</span> <span class="n">in</span> <span class="n">reverse</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// [‚Ä¶] = Greater</span>
</pre></table></code></div></div><p>The downside is that <code class="language-plaintext highlighter-rouge">use</code>-declarations would become less obvious. Implied supertrait implementation imports could be enabled only for <em>implementation environments</em> specified inline on generic type parameters as e.g. <code class="language-plaintext highlighter-rouge">Type as Ord in module</code> to avoid this.</p><p>If this is added later than scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>, then private scoped implementations <strong>must not</strong> be implicitly exported through this mechanism. (It‚Äôs likely a good idea to not allow that anyway, as it would be surprising.) Making previously crate-private implementations available that way could lead to unsoundness.</p><h3 id="alternatively">Alternatively<a href="#alternatively" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>It could be enough to allow inferring the module explicitly by writing <code class="language-plaintext highlighter-rouge">_</code> instead of its <em>SimplePath</em>, so that the snippets above become</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="n">min_heap</span><span class="p">:</span> <span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="nb">u32</span> <span class="k">as</span> <span class="nb">PartialOrd</span> <span class="n">in</span> <span class="n">_</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="n">in</span> <span class="n">reverse</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="nf">.into</span><span class="p">();</span>
</pre></table></code></div></div><p>and</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nd">dbg!</span><span class="p">(</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u32</span> <span class="k">as</span> <span class="nb">PartialOrd</span> <span class="n">in</span> <span class="n">_</span><span class="p">)</span> <span class="k">as</span> <span class="nb">Ord</span> <span class="n">in</span> <span class="n">reverse</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// [‚Ä¶] = Greater</span>
</pre></table></code></div></div><p>Here, too, the inference should only be of required supertrait implementations based on explicitly chosen implementations of their subtraits.</p><h2 id="conversions-where-a-generic-only-cares-about-specific-bounds-consistency">Conversions where a generic only cares about specific bounds‚Äô consistency<a href="#conversions-where-a-generic-only-cares-about-specific-bounds-consistency" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>With specialisation and more expressive bounds, an identity conversion like the following could be implemented:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// In the standard library.</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">mem</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">BuildHasher</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Hash</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Eq</span><span class="p">,</span> <span class="c1">// Observe implementations without requiring them.</span>
    <span class="n">U</span><span class="p">:</span> <span class="o">?</span><span class="n">Hash</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Eq</span><span class="p">,</span>
    <span class="n">T</span> <span class="o">==</span> <span class="n">U</span><span class="p">,</span> <span class="c1">// Comparison in terms of innate type identity and observed implementations.</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// SAFETY: This type requires only the `Hash` and `Eq` implementations to</span>
            <span class="c1">//         be consistent for correct function. All other implementations on</span>
            <span class="c1">//         generic type parameters may be exchanged freely.</span>
            <span class="c1">//         For the nested types this is an identity-transform, as guaranteed</span>
            <span class="c1">//         by `T == U` and the shared `S` which means the container is also</span>
            <span class="c1">//         guaranteed to be layout compatible.</span>
            <span class="nn">mem</span><span class="p">::</span><span class="nf">transmute</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This could also enable adjusted borrowing:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// In the standard library.</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">mem</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">BuildHasher</span><span class="o">&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">as_with_item_impl</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Hash</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Eq</span><span class="p">,</span> <span class="c1">// Observe implementations without requiring them.</span>
        <span class="n">U</span><span class="p">:</span> <span class="o">?</span><span class="n">Hash</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Eq</span><span class="p">,</span>
        <span class="n">T</span> <span class="o">==</span> <span class="n">U</span><span class="p">,</span> <span class="c1">// Comparison in terms of innate type identity and observed implementations.</span>
    <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// SAFETY: This type requires only the `Hash` and `Eq` implementations to</span>
            <span class="c1">//         be consistent for correct function. All other implementations on</span>
            <span class="c1">//         generic type parameters may be exchanged freely.</span>
            <span class="c1">//         For the nested types this is an identity-transform, as guaranteed</span>
            <span class="c1">//         by `T == U` and the shared `S` which means the container is also</span>
            <span class="c1">//         guaranteed to be layout compatible.</span>
            <span class="o">&amp;*</span><span class="p">(</span><span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>(But at that point, it may be better to use something like an unsafe marker trait or unsafe trait with default implementations.)</p><h2 id="sealed-trait-bounds">Sealed trait bounds<a href="#sealed-trait-bounds" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This is probably pretty strange, and may not be useful at all, but it likely doesn‚Äôt hurt to mention this.</p><p>Consider <em>ImplEnvironment</em> clauses in bounds like here:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">another_crate</span><span class="p">::{</span><span class="n">Trait</span><span class="p">,</span> <span class="n">Type1</span><span class="p">,</span> <span class="n">Type2</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">function</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">as</span> <span class="n">Trait</span> <span class="n">in</span> <span class="k">self</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type1</span> <span class="p">{}</span>
<span class="k">pub</span> <span class="k">use</span> <span class="k">impl</span> <span class="n">Trait</span> <span class="k">for</span> <span class="n">Type2</span> <span class="p">{}</span>
</pre></table></code></div></div><p>With this construct, <code class="language-plaintext highlighter-rouge">function</code> could privately rely on implementation details of <code class="language-plaintext highlighter-rouge">Trait</code> on <code class="language-plaintext highlighter-rouge">Type1</code> and <code class="language-plaintext highlighter-rouge">Type2</code> without defining a new sealed wrapper trait. It also becomes possible to easily define multiple sealed sets of implementations this way, by defining modules that export them.</p><p>Overall this would act as a more-flexible but also more-explicit counterpart to sealed traits.</p><p>Iff the caller is allowed to use this function without restating the binding, then removing the scope would be a breaking change (as it is already with bindings captured on type parameters in public signatures, so that would be consistent for this syntactical shape).</p><blockquote><p>That convenience (automatically using the correct implementations even if not in scope) also really should exist only iff there already is robust, near-effortless tooling for importing existing scoped implementations where missing. Otherwise this feature here <em>would</em> get (ab)used for convenience, which would almost certainly lead to painful overly sealed APIs.</p></blockquote><p>Binding an implementation in a call as <code class="language-plaintext highlighter-rouge">function::&lt;T as Trait in a&gt;()</code> while it is constrained as <code class="language-plaintext highlighter-rouge">fn function&lt;T as Trait in b&gt;() { ‚Ä¶ }</code> MUST fail for distinct modules <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> even if the implementations are identical, as otherwise this would leak the implementation identity into the set of breaking changes.</p><h2 id="glue-crate-suggestions">Glue crate suggestions<a href="#glue-crate-suggestions" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>If crates move some of their overlay features into glue crates, as explained in <a href="#unblock-ecosystem-evolution">unblock-ecosystem-evolution</a>, it would be nice if they could suggest them if both they and e.g. Serde were <code class="language-plaintext highlighter-rouge">cargo add</code>ed as direct dependencies of a crate currently being worked on.</p><p>An example of what this could look like:</p><div class="language-toml highlighter-rouge"><div class="code-header"> <span label-text="TOML"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"my-crate"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.2"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="c"># none</span>

<span class="nn">[suggest-with.serde."1"]</span>
<span class="py">my-crate_serde_glue</span> <span class="p">=</span> <span class="s">"0.1.0"</span>

<span class="nn">[suggest-with.bevy_reflect."0.11"]</span>
<span class="py">my-crate_bevy_reflect_glue</span> <span class="p">=</span> <span class="s">"0.1.2"</span>

<span class="nn">[suggest-with.bevy_reflect."0.12"]</span>
<span class="py">my-crate_bevy_reflect_glue</span> <span class="p">=</span> <span class="s">"0.2.1"</span>
</pre></table></code></div></div><p>(This sketch doesn‚Äôt take additional registries into account.)</p><p>Ideally, crates.io should only accept existing crates here (but with non-existing version numbers) and Cargo should by default validate compatibility where possible during <code class="language-plaintext highlighter-rouge">cargo publish</code>.</p><h2 id="reusable-limited-access-apis">Reusable limited-access APIs<a href="#reusable-limited-access-apis" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Given a newtype of an unsized type, like</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">MyStr</span><span class="p">(</span><span class="nb">str</span><span class="p">);</span>
</pre></table></code></div></div><p>for example, there is currently no safe-Rust way to convert between <code class="language-plaintext highlighter-rouge">&amp;str</code> and <code class="language-plaintext highlighter-rouge">&amp;MyStr</code> or <code class="language-plaintext highlighter-rouge">Box&lt;MyStr&gt;</code> and <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>, even though <em>in the current module which can see the field</em> this is guaranteed to be a sound operation.</p><p>One good reason for this is that there is no way to represent this relationship with a marker trait, since any global implementation of such a trait would give outside code to this conversion too.</p><p>With scoped <code class="language-plaintext highlighter-rouge">impl Trait for Type</code>, the code above could safely imply a marker implementation like the following in the same scope:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Visibility matches newtype or single field, whichever is more narrow.</span>

<span class="k">use</span> <span class="k">unsafe</span> <span class="k">impl</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">MyStr</span> <span class="p">{}</span>
<span class="k">use</span> <span class="k">unsafe</span> <span class="k">impl</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">MyStr</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">str</span> <span class="p">{}</span>
<span class="c1">// Could symmetry be implied instead?</span>
</pre></table></code></div></div><p>(<code class="language-plaintext highlighter-rouge">Transparent</code> can and should be globally reflexive.)</p><p>This would allow safe APIs with unlimited visibility like</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">U</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// SAFETY: This operation is guaranteed-safe by `Transparent`.</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">transmute</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>and</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">Transparent</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">Transparent</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span> <span class="p">{}</span>
</pre></table></code></div></div><p>which due to their bound would only be usable where the respective <code class="language-plaintext highlighter-rouge">T: Transparent&lt;U&gt;</code>-implementation is in scope, that is: where by-value unwrapping-and-then-wrapping would be a safe operation (for <code class="language-plaintext highlighter-rouge">Sized</code> types in that position).</p><p>Overall, this would make unsized newtypes useful without <code class="language-plaintext highlighter-rouge">unsafe</code>, by providing a compiler-validated alternative to common reinterpret-casts in their implementation. The same likely also applies to certain optimisations for <code class="language-plaintext highlighter-rouge">Sized</code> that can‚Äôt be done automatically for unwrap-then-wrap conversions as soon as a custom <code class="language-plaintext highlighter-rouge">Allocator</code> with possible side-effects is involved.</p><p>If a module wants to publish this marker globally, it can do so with a separate global implementation of the trait, which won‚Äôt cause breakage. (As noted in <a href="#efficient-compilation">efficient-compilation</a>, the compiler should treat implementations of empty traits as identical early on, so that no code generation is unnecessarily duplicated.)</p><blockquote><p><em>Could</em> sharing pointers like <code class="language-plaintext highlighter-rouge">Arc</code> inherit this marker from their contents like <code class="language-plaintext highlighter-rouge">Box</code> could? I‚Äôm unsure. They probably <em>shouldn‚Äôt</em> since doing this to exposed shared pointers could easily lead to hard-to-debug problems depending on drop order.</p><p>A global</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</pre></table></code></div></div><p>should be unproblematic, but a global</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Transparent</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</pre></table></code></div></div><p>(or vice versa) <strong>must not</strong> exist to allow the likely more useful implementations on <code class="language-plaintext highlighter-rouge">&amp;</code>-like types.</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/language-design/'>Language Design</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rust/" class="post-tag no-text-decoration" >Rust</a> <a href="/tags/traits/" class="post-tag no-text-decoration" >traits</a> <a href="/tags/composition/" class="post-tag no-text-decoration" >composition</a> <a href="/tags/rfc/" class="post-tag no-text-decoration" >RFC</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper">This post is <a href="https://creativecommonsusa.org/wp-content/uploads/2018/01/Copyright-and-Open-Licensing-Primer.pdf">not licensed</a> for any purpose, unless otherwise noted.<br> It is provided AS IS without any guarantee of correctness beyond those required for legal reasons.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Rust RFC 3634: Scoped <code>impl Trait for Type</code> - Abstraction Haven&url=https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Rust RFC 3634: Scoped <code>impl Trait for Type</code> - Abstraction Haven&u=https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Rust RFC 3634: Scoped <code>impl Trait for Type</code> - Abstraction Haven&url=https://blog.schichler.dev/posts/Rust-RFC-3634_-Scoped-impl-Trait-for-Type/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Asteracea/">Asteracea (as of right now) üåº</a><li><a href="/posts/Moving/">Moving</a><li><a href="/posts/Some-thoughts-on-Bubble/">Some thoughts on Bubble</a><li><a href="/posts/Cheese-olive-dish/">Cheese-olive dish</a><li><a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/">Intrusive Smart Pointers + Heap Only Types = üíû</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/"><div class="card-body"> <em class="timeago small" date="2020-10-31 16:10:00 +0100" >Oct 31, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Semantic FFI Bindings in Rust - Reactivating the Borrow Checker</h3><div class="text-muted small"><p> In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks ...</p></div></div></a></div><div class="card"> <a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/"><div class="card-body"> <em class="timeago small" date="2021-11-14 18:44:00 +0100" >Nov 14, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Intrusive Smart Pointers + Heap Only Types = üíû</h3><div class="text-muted small"><p> In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomati...</p></div></div></a></div><div class="card"> <a href="/posts/Pinning-in-plain-English/"><div class="card-body"> <em class="timeago small" date="2021-11-24 17:10:00 +0100" >Nov 24, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pinning in plain English</h3><div class="text-muted small"><p> A mirrored bell pepper is still clearly the same fruit, but the mirror image, if physically placed outside the mirror, would largely only be compatible with a fundamentally different biology, ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Asteracea/" class="btn btn-outline-primary" prompt="Older"><p>Asteracea (as of right now) üåº</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> ¬© 2024 <a href="https://schichler.dev/">Tamme Schichler</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are not licensed for redistribution by the author. (Feel free to save a copy for personal use, though. You likely don't even need permission for that.)">Most rights reserved.</span> <br> <a href="https://impressum.schichler.dev/">Impressum/Imprint, Datenschutz</a></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="/assets/un-cdn/jsdelivr/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/un-cdn/jsdelivr/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/un-cdn/jsdelivr/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
