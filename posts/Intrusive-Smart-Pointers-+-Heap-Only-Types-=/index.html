<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"> <script defer="" data-domain="blog.schichler.dev" src="https://a.schichler.dev/js/script.js"></script><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Intrusive Smart Pointers + Heap Only Types = üíû" /><meta property="og:locale" content="en" /><meta name="description" content="In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomatic? (Yes, if‚Ä¶) Heap-only mutability Intrusive counting How to do this 99% safely? (I made a crate.) The Clone hole ‚ö† Plugging the Clone hole Where to go from here" /><meta property="og:description" content="In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomatic? (Yes, if‚Ä¶) Heap-only mutability Intrusive counting How to do this 99% safely? (I made a crate.) The Clone hole ‚ö† Plugging the Clone hole Where to go from here" /><link rel="canonical" href="https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/" /><meta property="og:url" content="https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/" /><meta property="og:site_name" content="Abstraction Haven" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-14T18:44:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Intrusive Smart Pointers + Heap Only Types = üíû" /><meta name="twitter:site" content="@tammeschichler" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"In this post: Heap only types: Where do they appear? Handling heap only types: Box, Rc and Arc Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶) Can this be more idiomatic? (Yes, if‚Ä¶) Heap-only mutability Intrusive counting How to do this 99% safely? (I made a crate.) The Clone hole ‚ö† Plugging the Clone hole Where to go from here","url":"https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/","@type":"BlogPosting","headline":"Intrusive Smart Pointers + Heap Only Types = üíû","dateModified":"2022-01-11T21:54:32+01:00","datePublished":"2021-11-14T18:44:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/"},"@context":"https://schema.org"}</script><title>Intrusive Smart Pointers + Heap Only Types = üíû | Abstraction Haven</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Abstraction Haven"><meta name="application-name" content="Abstraction Haven"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/un-cdn/jsdelivr/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="/assets/un-cdn/jsdelivr/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Abstraction Haven</a></div><div class="site-subtitle font-italic">Mostly Rust, sometimes mainly carbohydrates.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://ko-fi.com/tamme/" aria-label="ko-fi" target="_blank" rel="noopener" title="https://ko-fi.com/tamme/" > <i class="fas fa-coffee"></i> </a> <a href="https://tamschi.itch.io/" aria-label="itch.io" target="_blank" rel="noopener" title="https://tamschi.itch.io/" > <i class="fab fa-itch-io"></i> </a> <a href="https://github.com/Tamschi" aria-label="github" target="_blank" rel="noopener" title="https://github.com/Tamschi" > <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tamme','schichler.dev'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="xmpp:tamme@schichler.dev" aria-label="xmpp" > <i class="fas fa-comment-dots"></i> </a> <a href="https://nerdculture.de/@Tamschi" aria-label="mastodon" target="_blank" rel="noopener" title="https://nerdculture.de/@Tamschi" > <i class="fab fa-mastodon"></i> </a> <a href="https://twitter.com/tammeschichler" aria-label="twitter" target="_blank" rel="noopener" title="https://twitter.com/tammeschichler" > <i class="fab fa-twitter"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Intrusive Smart Pointers + Heap Only Types = üíû</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="/assets/img/posts/2021-11-14-Intrusive Smart Pointers + Heap Only Types = üíû/TauamyRb8.jpg" class="preview-img bg" alt="A Feynman diagram showing how an intrusive `Pin<Arc<Node data-proofer-ignore>>` cloned via `&Node`. The initial `Pin<Arc<Node>>` remains unchanged. An `&Node` is derived from it. As this `&Node` is converted into a full `Pin<Arc<Node>>`, an unlabeled green wavy connector shoots off and mutates the dashed `Node` instance with a slight delay." width="1600" height="840" ><h1 data-toc-skip>Intrusive Smart Pointers + Heap Only Types = üíû</h1><div class="post-meta text-muted"><div style="float: left; clear: left;"> By <em> <a href="https://schichler.dev/">Tamme Schichler</a> </em></div><div style="float: right; clear: right;"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a></div><div class="d-flex" style="float: left; clear: left;"><div> <span> Posted <em class="timeago" date="2021-11-14 18:44:00 +0100" data-toggle="tooltip" data-placement="bottom" title="Sun, Nov 14, 2021, 6:44 PM +0100" >Nov 14, 2021</em> </span> <span> Updated <em class="timeago" date="2022-01-11 21:54:32 +0100 " data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 11, 2022, 9:54 PM +0100" >Jan 11, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3077 words"> <em>17 min</em> read</span></div></div><div class="post-tags" style="float: right; clear: right;"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/patterns/" class="post-tag no-text-decoration" >patterns</a> <a href="/tags/api/" class="post-tag no-text-decoration" >api</a> <a href="/tags/walkthrough/" class="post-tag no-text-decoration" >walkthrough</a> <a href="/tags/crate-included/" class="post-tag no-text-decoration" >crate included</a></div><div style="clear: both;"></div></div><div class="post-content"><blockquote><p>In this post:</p><ul><li>Heap only types: Where do they appear?<li>Handling heap only types: <code class="language-plaintext highlighter-rouge">Box</code>, <code class="language-plaintext highlighter-rouge">Rc</code> and <code class="language-plaintext highlighter-rouge">Arc</code><li>Cloning a handle from a heap-only borrow? (Yes, but‚Ä¶)<li>Can this be more idiomatic? (Yes, if‚Ä¶)<li>Heap-only mutability<li>Intrusive counting<li>How to do this 99% safely? (I made a crate.)<li>The <code class="language-plaintext highlighter-rouge">Clone</code> hole ‚ö†<ul><li>Plugging the <code class="language-plaintext highlighter-rouge">Clone</code> hole</ul><li>Where to go from here</ul></blockquote><hr /><blockquote><p>Prior work:</p><ul><li>The initial approach is inspired by <a href="https://docs.rs/triomphe/0.1/triomphe/struct.ArcBorrow.html"><code class="language-plaintext highlighter-rouge">triomphe::ArcBorrow</code></a>.</ul></blockquote><hr /><blockquote><p>Cover image made using <a href="https://feynman.aivazis.com/">https://feynman.aivazis.com/</a>.<br /> Not physically accurate. Time is horizontal. Lifetime dependencies omitted.</p></blockquote><hr /><p>Please note that this post is a proof of concept. I‚Äôm confident it can be implemented in a way that has no or negative overhead compared to, for example, the standard library‚Äôs smart pointers, but I have not gotten around to do this yet.</p><h2 id="heap-only-types">Heap Only Types<a href="#heap-only-types" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust can model (at least) two kinds of heap-only-ish types: <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=Unsized%20Type#dynamically-sized-types-and-the-sized-trait">Unsized types</a>, which cannot be placed on the stack by the compiler because their size is unknown, and <strong>semantically heap-only types</strong>, which are contextually heap-only whenever an API doesn‚Äôt allow them to be observable elsewhere. As usual, these limitations don‚Äôt exist for <code class="language-plaintext highlighter-rouge">unsafe</code> Rust, which is beyond the scope of this post.</p><p>The type examined here is only semantically heap-only towards a consumer in a different crate, but the pattern I present also works for unsized (dynamically-sized) types.</p><h3 id="where-do-they-appear">Where do they appear?<a href="#where-do-they-appear" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is an opportunity to make a type heap-only whenever it would otherwise be useless. A good example is the following reference-counted inverse tree:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="c1">// ances-tree/lib.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Borrow</span><span class="p">,</span> <span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="n">Pipe</span><span class="p">;</span> <span class="c1">// ¬π</span>

<span class="nd">#[cfg(doctest)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">readme</span> <span class="p">{</span>
	<span class="nn">doc_comment</span><span class="p">::</span><span class="nd">doctest!</span><span class="p">(</span><span class="s">"../README.md"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cd">/// A reference-counting inverse tree node.</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
	<span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cd">/// Creates a new [`Node`] instance with the given `parent` and `value`.</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
		<span class="k">Self</span> <span class="p">{</span> <span class="n">parent</span><span class="p">,</span> <span class="n">value</span> <span class="p">}</span>
	<span class="p">}</span>

	<span class="cd">/// Retrieves a reference to a [`Node`] with a value matching `key` iff available.</span>
	<span class="cd">///</span>
	<span class="cd">/// See also: &lt;https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.get&gt;</span>
	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">Self</span><span class="o">&gt;</span>
	<span class="k">where</span>
		<span class="n">T</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
		<span class="n">Q</span><span class="p">:</span> <span class="nb">Eq</span><span class="p">,</span>
	<span class="p">{</span>
		<span class="k">let</span> <span class="k">mut</span> <span class="n">this</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>
		<span class="k">while</span> <span class="n">this</span><span class="py">.value</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">!=</span> <span class="n">key</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="py">.parent</span><span class="nf">.as_ref</span><span class="p">()</span><span class="o">?</span>
		<span class="p">}</span>
		<span class="nf">Some</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Abridged. See omitted code at ¬≤.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>¬π Not shown in this abridged snippet, I‚Äôm using myrrlyn‚Äôs excellent <a href="https://crates.io/crates/tap">tap</a> crate to organise long expressions in execution order.<br /> ¬≤ <a href="https://github.com/Tamschi/ances-tree/blob/blog-link/basic-inverse-tree/src/lib.rs#L46-L124">Tamschi/ances-tree üîñblog-link/basic-inverse-tree (lib.rs#L46-L124)</a></p><p>üíÅ‚Äç‚ôÇÔ∏è <em>I‚Äôve published this example crate on GitHub and will occasionally link tags and diffs for you to follow along. The project that inspired this pattern, <a href="https://github.com/Tamschi/rhizome#readme">rhizome</a>, is too verbose and messy to cite here, but follows generally the same structure.</em><br /> <em>You can see the changes for each section in this post in <a href="https://github.com/Tamschi/ances-tree/commits/blog-steps">the blog-steps branch</a>. GitHub isn‚Äôt too clear about this, but the section title ones are merge commits that together contain all changes.</em></p><p>Note that the above doesn‚Äôt make <code class="language-plaintext highlighter-rouge">Node</code> heap-only yet!</p><h2 id="handling-heap-only-types">Handling heap only types<a href="#handling-heap-only-types" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>To restrict a type to the heap, we <a href="https://doc.rust-lang.org/stable/core/pin/index.html">pin</a> it behind a smart pointer (in this case <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html"><code class="language-plaintext highlighter-rouge">Arc</code></a>) as follows:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Borrow</span><span class="p">,</span> <span class="nn">marker</span><span class="p">::</span><span class="n">PhantomPinned</span><span class="p">,</span> <span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">,</span> <span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="n">Pipe</span><span class="p">;</span>

<span class="cd">/// A reference-counting inverse tree node.</span>
<span class="nd">#[derive(Debug)]</span> <span class="c1">// No `Clone`!</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
	<span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
	<span class="c1">// The private field also prevents construction elsewhere.</span>
	<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cd">/// Creates a new [`Node`] instance with the given `parent` and `value`.</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
		<span class="k">Self</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span>
			<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">pin</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// `.get(‚Ä¶)` unchanged.</span>
	<span class="c1">// `.get_mut(‚Ä¶)` and `.make_mut(‚Ä¶)` removed for now.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The consumer now never sees a <code class="language-plaintext highlighter-rouge">Node</code> or <code class="language-plaintext highlighter-rouge">&amp;mut Node</code> directly, which means the instances can‚Äôt be moved away from the heap.</p><p>The <code class="language-plaintext highlighter-rouge">.get(‚Ä¶)</code> method remains unchanged as <code class="language-plaintext highlighter-rouge">&amp;Node</code> is still accessible through <a href="https://doc.rust-lang.org/stable/core/pin/struct.Pin.html#impl-Deref"><code class="language-plaintext highlighter-rouge">impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt;</code></a>.</p><p><code class="language-plaintext highlighter-rouge">.get_mut(‚Ä¶)</code> and <code class="language-plaintext highlighter-rouge">.make_mut(‚Ä¶)</code> have been removed for now since the Rust standard library doesn‚Äôt provide equivalents of <em>its</em> <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#method.get_mut"><code class="language-plaintext highlighter-rouge">Arc::get_mut</code></a> and <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#method.make_mut"><code class="language-plaintext highlighter-rouge">Arc::make_mut</code></a> functions for <code class="language-plaintext highlighter-rouge">Pin&lt;Arc&lt;‚Ä¶&gt;&gt;</code>.<br /> Note that even exclusively held <code class="language-plaintext highlighter-rouge">Node</code>‚Äôs are effectively read-only now. There are work-arounds for all of this, of course, but they involve a lot of <code class="language-plaintext highlighter-rouge">unsafe</code>. This feature will safely come back later on, though.</p><h2 id="cloning-a-handle-from-a-heap-only-borrow">Cloning a handle from a heap-only borrow?<a href="#cloning-a-handle-from-a-heap-only-borrow" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>When borrowing the contents of an <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code>, we usually want to handle a <code class="language-plaintext highlighter-rouge">&amp;T</code> rather than an <code class="language-plaintext highlighter-rouge">&amp;Arc&lt;T&gt;</code> to avoid a double-indirection when accessing the value.</p><p>Since any API consumer will only see pinned <code class="language-plaintext highlighter-rouge">Node</code>s, we <em>know</em> that any <code class="language-plaintext highlighter-rouge">&amp;Node</code> we see actually points to an instance managed by <code class="language-plaintext highlighter-rouge">Arc</code>. Can we increment the reference count to create an additional <code class="language-plaintext highlighter-rouge">Arc</code>?</p><p>The answer is, unfortunately here but fortunately in general, no.</p><p>Even if <code class="language-plaintext highlighter-rouge">Arc</code> had a known layout with a known pointer offset, we would not be allowed to magic-up a borrow using pointer maths:<br /> As the <code class="language-plaintext highlighter-rouge">Arc</code> reference count is stored outside <code class="language-plaintext highlighter-rouge">Node</code>, we must not* access it through <code class="language-plaintext highlighter-rouge">&amp;Node</code> even using pointer maths, as this would be an out-of-bounds read.</p><p>üíÅ‚Äç‚ôÇÔ∏è *Technically <em>code like that works right now, but I‚Äôm told it‚Äôs still considered UB. Never allowing out-of-bounds access through references could enable or at least simplify powerful optimisations in the future.</em></p><p>As <code class="language-plaintext highlighter-rouge">triomphe</code> has a matching known-<code class="language-plaintext highlighter-rouge">Arc</code>-borrow API, we can quickly see what this <em>would</em> look like if we borrowed into a pointer and abstracted instead.</p><p>First, we switch out the <code class="language-plaintext highlighter-rouge">Arc</code> import:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Borrow</span><span class="p">,</span> <span class="nn">marker</span><span class="p">::</span><span class="n">PhantomPinned</span><span class="p">,</span> <span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="n">Pipe</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">triomphe</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">ArcBorrow</span><span class="p">};</span>
</pre></table></code></div></div><p>and adjust the constructor a bit since <code class="language-plaintext highlighter-rouge">triomphe</code> isn‚Äôt <code class="language-plaintext highlighter-rouge">Pin</code>-aware:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cd">/// Creates a new [`Node`] instance with the given `parent` and `value`.</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
		<span class="k">Self</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span>
			<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">new</span><span class="p">)</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="p">})</span>
	<span class="p">}</span>

	<span class="c1">// `.get(‚Ä¶)` unchanged.</span>
	<span class="c1">// `.get_mut(‚Ä¶)` and `.make_mut(‚Ä¶)` still missing.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We also have to shim the following functions:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
	<span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">this</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span> <span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">borrow_arc</span><span class="p">)</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc_borrow</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">arc_borrow</span><span class="p">)</span> <span class="p">})</span>
<span class="p">}</span>

<span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">clone_arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Pin</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
	<span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">this</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span> <span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">ArcBorrow</span><span class="p">::</span><span class="n">clone_arc</span><span class="p">)</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="p">})</span>
<span class="p">}</span>
</pre></table></code></div></div><p>So far so good.</p><p>Their signatures are a mouthful, so we‚Äôll change the code again to abstract the borrow type a bit, and use that abstraction everywhere it‚Äôs applicable.</p><p>First the borrow:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">NodeBorrow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="n">arc_borrow</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">NodeBorrow</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

	<span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
		<span class="o">&amp;*</span><span class="k">self</span><span class="py">.arc_borrow</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And then the handle:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="n">arc</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cd">/// Creates a new [`Node`] instance with the given `parent` and `value`.</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
		<span class="n">Node</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span>
			<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">new</span><span class="p">)</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="p">})</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc</span><span class="p">|</span> <span class="k">Self</span> <span class="p">{</span> <span class="n">arc</span> <span class="p">})</span>
	<span class="p">}</span>

	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeBorrow</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="py">.arc</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span> <span class="p">}</span>
			<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">borrow_arc</span><span class="p">)</span>
			<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc_borrow</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">arc_borrow</span><span class="p">)</span> <span class="p">})</span>
			<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc_borrow</span><span class="p">|</span> <span class="n">NodeBorrow</span> <span class="p">{</span> <span class="n">arc_borrow</span> <span class="p">})</span>
	<span class="p">}</span>

	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">clone_handle</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">NodeBorrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
		<span class="k">unsafe</span> <span class="p">{</span>
			<span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="py">.arc_borrow</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ArcBorrow</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">ArcBorrow</span><span class="p">::</span><span class="n">clone_arc</span><span class="p">)</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="p">})</span>
		<span class="nf">.pipe</span><span class="p">(|</span><span class="n">arc</span><span class="p">|</span> <span class="k">Self</span> <span class="p">{</span> <span class="n">arc</span> <span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

	<span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
		<span class="o">&amp;*</span><span class="k">self</span><span class="py">.arc</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Node</code> itself loses its constructor and now stores a <code class="language-plaintext highlighter-rouge">NodeHandle</code> as parent reference:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>
<span class="cd">/// A reference-counting inverse tree node.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
	<span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
	<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="c1">// Constructor removed, otherwise unchanged.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That‚Äôs fairly nice now. The only sticking points are that we have a <code class="language-plaintext highlighter-rouge">NodeBorrow&lt;'a, T&gt;</code> instead of an <code class="language-plaintext highlighter-rouge">&amp;'a Node</code> and no exclusive/mutable references to <code class="language-plaintext highlighter-rouge">Node</code>.</p><p>Exposing two bespoke helper types to fix clumsy signatures also isn‚Äôt ideal, but more of an incidental issue.</p><h2 id="can-this-be-more-idiomatic">Can this be more idiomatic?<a href="#can-this-be-more-idiomatic" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Let‚Äôs say we had a hypothetical <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> that was legal to borrow from <code class="language-plaintext highlighter-rouge">&amp;T</code>. Let‚Äôs also say it was pinning-aware so that we can skip some boilerplate while preventing any de-boxing.</p><p>First, our <code class="language-plaintext highlighter-rouge">NodeHandle</code> is now a type alias, since we won‚Äôt need additional functions:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>Second,</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="n">NodeBorrow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>, but since that type alias is longer than its original type, we‚Äôll just write <code class="language-plaintext highlighter-rouge">&amp;Node&lt;T&gt;</code> instead.</p><p>Third, <code class="language-plaintext highlighter-rouge">Node</code> remains unchanged for now, but all functions are concentrated on that type like this:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cd">/// Creates a new [`Node`] instance with the given `parent` and `value`.</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="n">Node</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span>
			<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">pin</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="cd">/// Retrieves a reference to a [`Node`] with a value matching `key` iff available.</span>
	<span class="cd">///</span>
	<span class="cd">/// See also: &lt;https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.get&gt;</span>
	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">Self</span><span class="o">&gt;</span>
	<span class="k">where</span>
		<span class="n">T</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
		<span class="n">Q</span><span class="p">:</span> <span class="nb">Eq</span><span class="p">,</span>
	<span class="p">{</span>
		<span class="k">let</span> <span class="k">mut</span> <span class="n">this</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>
		<span class="k">while</span> <span class="n">this</span><span class="py">.value</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">!=</span> <span class="n">key</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="py">.parent</span><span class="nf">.as_ref</span><span class="p">()</span><span class="o">?</span>
		<span class="p">}</span>
		<span class="nf">Some</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">clone_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="nd">todo!</span><span class="p">()</span> <span class="c1">// ü§î</span>
	<span class="p">}</span>

	<span class="c1">// Mutability will be back, eventually.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">Arc</code> can‚Äôt know that our <code class="language-plaintext highlighter-rouge">Node</code> is only ever visible behind <code class="language-plaintext highlighter-rouge">Arc</code>, so we have to provide a safe <code class="language-plaintext highlighter-rouge">.clone_handle()</code> method ourselves.</p><h2 id="heap-only-mutability">Heap-only mutability<a href="#heap-only-mutability" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The signature of an exclusive borrow in Rust is <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut _&gt;</code>. While the <code class="language-plaintext highlighter-rouge">Arc</code> can‚Äôt be <code class="language-plaintext highlighter-rouge">DerefMut</code> (which would allow us to use <a href="https://doc.rust-lang.org/stable/std/pin/struct.Pin.html#method.as_mut"><code class="language-plaintext highlighter-rouge">Pin::as_mut</code></a>), it can generically provide us with pinning alternatives to its <code class="language-plaintext highlighter-rouge">get_mut</code> and <code class="language-plaintext highlighter-rouge">make_mut</code> methods.</p><p>We can use these to go from <code class="language-plaintext highlighter-rouge">&amp;mut NodeHandle&lt;T&gt;</code> to <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut Node&lt;T&gt;&gt;</code>.</p><p>üíÅ‚Äç‚ôÇÔ∏è <em><code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut Node&lt;T&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">Deref&lt;Target = Node&lt;T&gt;&gt;</code> (because <code class="language-plaintext highlighter-rouge">&amp;mut Node&lt;T&gt;</code> is the same), so we could access a shared reference and clone the <code class="language-plaintext highlighter-rouge">NodeHandle&lt;T&gt;</code>, which would give us a parallel shared reference to our now-free-again exclusive reference (<code class="language-plaintext highlighter-rouge">&amp;Node&lt;T&gt;</code> and parallel <code class="language-plaintext highlighter-rouge">&amp;mut Node&lt;T&gt;</code>). This would be <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">extremely bad</a>.</em></p><p><em>We‚Äôll assume that the <code class="language-plaintext highlighter-rouge">Arc</code> already protects against this invalid construct, at the cost of slight (additional) overhead per exclusive borrow.</em></p><p>This isn‚Äôt quite enough to let a consumer change the contents of the instance, since we still aren‚Äôt providing mutable access to the public fields. Manual pin-projection is somewhat error-prone to implement, so we‚Äôre going to let the <a href="https://crates.io/crates/pin-project">pin-project</a> crate take care of that:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cd">/// A reference-counting inverse tree node.</span>
<span class="nd">#[pin_project::pin_project]</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
	<span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
	<span class="nd">#[pin]</span> <span class="c1">// Required to keep `Node&lt;T&gt;: !Unpin`!</span>
	<span class="n">_pin</span><span class="p">:</span> <span class="n">PhantomPinned</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">parent_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
		<span class="k">self</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.project</span><span class="p">()</span><span class="py">.parent</span>
	<span class="p">}</span>

	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">value_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
		<span class="k">self</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.project</span><span class="p">()</span><span class="py">.value</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We must mark <code class="language-plaintext highlighter-rouge">_pin</code> as structural(ly pinned) here; otherwise <code class="language-plaintext highlighter-rouge">pin_project</code> would <code class="language-plaintext highlighter-rouge">impl&lt;T&gt; Unpin for Node&lt;T&gt; {}</code> with no constraints.</p><p>The <code class="language-plaintext highlighter-rouge">self: &amp;'a mut Pin&lt;&amp;mut Self&gt;</code> parameter on these methods looks a bit strange, but lets a consumer call them directly on the guard we get from <code class="language-plaintext highlighter-rouge">Arc::get_mut</code>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">let</span> <span class="k">mut</span> <span class="n">exclusive</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">handle</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
		<span class="k">let</span> <span class="n">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">exclusive</span><span class="nf">.value_mut</span><span class="p">();</span>
		<span class="k">let</span> <span class="n">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">exclusive</span><span class="nf">.parent_mut</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">let</span> <span class="n">second_handle</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">handle</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">());</span>
	<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">second_handle</span><span class="py">.value</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>üíÅ‚Äç‚ôÇÔ∏è <em>It‚Äôs likely a good idea to inline <code class="language-plaintext highlighter-rouge">parent_mut</code> and <code class="language-plaintext highlighter-rouge">value_mut</code>. However, performance-optimisation is arbitrarily out of scope for this post.</em></p><h2 id="intrusive-counting">Intrusive counting<a href="#intrusive-counting" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The reason <code class="language-plaintext highlighter-rouge">alloc::sync::Arc</code> and <code class="language-plaintext highlighter-rouge">triomphe::Arc</code> can‚Äôt quite soundly go from ‚Äú<code class="language-plaintext highlighter-rouge">&amp;T</code>-behind-<code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code>‚Äù to a cloned <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> is <em>only</em> the required out-of-bounds access to the <code class="language-plaintext highlighter-rouge">Arc</code>‚Äôs reference counter in those case.</p><p>If we can move the reference-counter <em>inside</em> the contained instance, we are then able to get a reference to it and, by effectively reimplementing <code class="language-plaintext highlighter-rouge">alloc::sync::Arc&lt;T&gt;</code> <strong>without exposing <code class="language-plaintext highlighter-rouge">&amp;mut T</code></strong>, can arrive at the API above.</p><p>At this point, only the following types are exposed:</p><ul><li>A generic <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> that acts much like the standard library‚Äôs.<li>A generic guard that ensures mutable borrow exclusivity dynamically.<li>Our <code class="language-plaintext highlighter-rouge">Node&lt;T&gt;</code>, which contains the entirety of our API.</ul><h2 id="how-to-do-this-almost-safely">How to do this (almost) safely?<a href="#how-to-do-this-almost-safely" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The necessary smart pointer I needed for the above turned out to be really easy to abstract, so I‚Äôve turned it into a crate that you can find here: <a href="https://crates.io/crates/tiptoe">üì¶tiptoe</a></p><p>(Be sure to activate the <code class="language-plaintext highlighter-rouge">"sync"</code> feature to use <code class="language-plaintext highlighter-rouge">Arc</code>.)</p><p>You still have to adjust your <code class="language-plaintext highlighter-rouge">struct</code> to make it compatible, but this can be done in few lines of code and without using <code class="language-plaintext highlighter-rouge">unsafe</code> more than once:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Borrow</span><span class="p">,</span> <span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tap</span><span class="p">::</span><span class="n">Pipe</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tiptoe</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">IntrusivelyCountable</span><span class="p">,</span> <span class="n">TipToe</span><span class="p">};</span>

<span class="cd">/// A reference-counting inverse tree node.</span>
<span class="nd">#[pin_project::pin_project]</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
	<span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
	<span class="nd">#[pin]</span> <span class="c1">// Required to keep `Node&lt;T&gt;: !Unpin`!</span>
	<span class="n">tip_toe</span><span class="p">:</span> <span class="n">TipToe</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cd">/// Creates a new [`Node`] instance with the given `parent` and `value`.</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="n">Node</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span>
			<span class="n">tip_toe</span><span class="p">:</span> <span class="nn">TipToe</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
		<span class="p">}</span>
		<span class="nf">.pipe</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="n">pin</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">IntrusivelyCountable</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">type</span> <span class="n">RefCounter</span> <span class="o">=</span> <span class="n">TipToe</span><span class="p">;</span>

	<span class="nd">#[inline(always)]</span>
	<span class="k">fn</span> <span class="nf">ref_counter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">RefCounter</span> <span class="p">{</span>
		<span class="o">&amp;</span><span class="k">self</span><span class="py">.tip_toe</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">TipToe</code>, the reference-counting slot, is written to be as unobtrusive as possible:</p><ul><li>It‚Äôs transparent to all standard comparisons and hashing.<li>It implements <code class="language-plaintext highlighter-rouge">Default</code> and <code class="language-plaintext highlighter-rouge">Clone</code> (but the clone always has the default value).<li>It‚Äôs <code class="language-plaintext highlighter-rouge">!Unpin</code>, so it can be used to pin the surrounding struct.</ul><p><code class="language-plaintext highlighter-rouge">tiptoe::Arc&lt;T&gt;</code> will never provide a <code class="language-plaintext highlighter-rouge">&amp;mut</code> reference to its contents directly (and provides <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut _&gt;</code> only as <code class="language-plaintext highlighter-rouge">Pin&lt;Arc&lt;_&gt;&gt;</code>), but if <code class="language-plaintext highlighter-rouge">T: Unpin</code>, then <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Pin&lt;Arc&lt;T&gt;&gt;</code>, and <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, are equivalent and can be converted safely. Keep this in mind when exposing instances of your types through a conversion that requires <code class="language-plaintext highlighter-rouge">unsafe</code>.</p><p><code class="language-plaintext highlighter-rouge">TipToed</code>, the trait by which <code class="language-plaintext highlighter-rouge">Arc</code> finds the intrusive counter, is unsafe as Rust‚Äôs type system can‚Äôt guarantee a ‚Äúboring‚Äù implementation with only one embedded counter returned at all times. (The actual safety requirements are actually slightly more lenient than that, though. The true requirement is that it mustn‚Äôt confuse the count in a way that would cause instances to be dropped early, and that the call must have absolutely no (observable) effect.)</p><p>Since <code class="language-plaintext highlighter-rouge">Node</code> is a heap-only <em>and <code class="language-plaintext highlighter-rouge">Arc</code>-only</em> type via pinning, we can additionally provide the following method:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">#[must_use]</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">clone_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeHandle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="nn">Pin</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">borrow_pin_from_inner_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, we assume <code class="language-plaintext highlighter-rouge">&amp;self</code> is behind a <code class="language-plaintext highlighter-rouge">Pin&lt;Arc&lt;_&gt;&gt;</code>. <code class="language-plaintext highlighter-rouge">Arc&lt;_&gt;</code> is ABI-compatible with a plain shared reference, so it can be borrowed from one (via a short detour through <code class="language-plaintext highlighter-rouge">&amp;&amp;self</code>).</p><h2 id="the-clone-hole-">The <code class="language-plaintext highlighter-rouge">Clone</code> hole ‚ö†<a href="#the-clone-hole-" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">tiptoe::Arc</code> also provides a <code class="language-plaintext highlighter-rouge">make_mut</code> function, which has the same copy-on-write functionality as in the standard library. However, there is a problem with making this available for our <code class="language-plaintext highlighter-rouge">Node&lt;T&gt;</code>: <code class="language-plaintext highlighter-rouge">alloc::sync::Arc::&lt;T&gt;::make_mut</code> requires <code class="language-plaintext highlighter-rouge">T: Clone</code>.</p><p>We cannot implement <code class="language-plaintext highlighter-rouge">Clone</code> on <code class="language-plaintext highlighter-rouge">Node&lt;_&gt;</code> because that would allow a consumer to move from <code class="language-plaintext highlighter-rouge">&amp;Node&lt;T&gt;</code> to <code class="language-plaintext highlighter-rouge">Node&lt;T&gt;</code>, an instance decidedly off-heap.</p><h3 id="plugging-the-clone-hole">Plugging the <code class="language-plaintext highlighter-rouge">Clone</code> hole<a href="#plugging-the-clone-hole" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>For this reason, <code class="language-plaintext highlighter-rouge">tiptoe::Arc::&lt;T&gt;::make_mut</code> instead requires <code class="language-plaintext highlighter-rouge">tiptoe::ManagedClone</code>. This trait has the same shape as <code class="language-plaintext highlighter-rouge">Clone</code> but its methods are <code class="language-plaintext highlighter-rouge">unsafe</code> and it comes with a caller restriction:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cd">/// # Safety</span>
<span class="cd">///</span>
<span class="cd">/// This method may only be used to create equally encapsulated instances.</span>
<span class="cd">///</span>
<span class="cd">/// For example, if you can see the instance is inside a [`Box`](`alloc::boxed::Box`),</span>
<span class="cd">/// then you may clone it into another [`Box`](`alloc::boxed::Box`) this way.</span>
<span class="cd">///</span>
<span class="cd">/// If you have only a reference or pointer to the implementing type's instance,</span>
<span class="cd">/// but don't know or can't replicate its precise encapsulation, then you must not call this method.</span>
<span class="cd">///</span>
<span class="cd">/// You may not use it in any way that could have side-effects before encapsulating the clone.</span>
<span class="cd">/// This also means you may not drop the clone. Forgetting it is fine.</span>
<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">managed_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
</pre></table></code></div></div><p>In short: This method mustn‚Äôt be used by an API consumer to interact with unwrapped instances.</p><p>(Any type that is <code class="language-plaintext highlighter-rouge">Clone</code> is automatically <code class="language-plaintext highlighter-rouge">ManagedClone</code>.)</p><p>You can find this final step in the implementation here: <a href="https://github.com/Tamschi/ances-tree/blob/blog-link/managed-clone/src/lib.rs#L83-L94">Tamschi/ances-tree üîñblog-link/managed-clone (lib.rs#L83-L94)</a><br /> The <em>develop</em> branch also contains a rehash of the assumptions made at each location where <code class="language-plaintext highlighter-rouge">unsafe</code> is used.</p><h2 id="where-to-go-from-here">Where to go from here<a href="#where-to-go-from-here" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>I‚Äôve implemented tiptoe only as far as I personally need it, so there are a few open points where it could be more useful:</p><ul><li><p>Nobody has audited <code class="language-plaintext highlighter-rouge">tiptoe</code> so far. It contains a lot of <code class="language-plaintext highlighter-rouge">unsafe</code> snippets, so getting a few more eyes on it would be helpful in this regard.</p><li><p>I currently only need <code class="language-plaintext highlighter-rouge">Arc</code>, not <code class="language-plaintext highlighter-rouge">Rc</code>. I‚Äôve implemented <code class="language-plaintext highlighter-rouge">TipToe</code> in such a way that it can alternatively act as <code class="language-plaintext highlighter-rouge">Rc</code> reference counter with no synchronisation overhead, so it should be fairly easy to copy-paste the latter from the former if needed.</p><li><p>The crate is unoptimised in terms of speed. I don‚Äôt have experience with benchmarking Rust and don‚Äôt need the crate to be particularly fast right now.</p><li><p><code class="language-plaintext highlighter-rouge">TipToe</code> is a strong reference counter only. From what I can tell, <code class="language-plaintext highlighter-rouge">tiptoe::Arc</code> and an eventual <code class="language-plaintext highlighter-rouge">tiptoe::Rc</code> could become compatible with an additional intrusive strong/weak counter without breaking API changes.</p><li><p>I may add an <code class="language-plaintext highlighter-rouge">ExclusiveArc&lt;_&gt;</code> or <code class="language-plaintext highlighter-rouge">Unique&lt;_&gt;</code> type in the future, which would behave like a standard <code class="language-plaintext highlighter-rouge">Box&lt;_&gt;</code> but set the internal counter to the exclusivity value until converted into an <code class="language-plaintext highlighter-rouge">Arc</code>. It‚Äôs also likely possible to improve the way dynamic exclusivity works, but I suspect I currently lack the necessary skills for that.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/patterns/" class="post-tag no-text-decoration" >patterns</a> <a href="/tags/api/" class="post-tag no-text-decoration" >api</a> <a href="/tags/walkthrough/" class="post-tag no-text-decoration" >walkthrough</a> <a href="/tags/crate-included/" class="post-tag no-text-decoration" >crate included</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper">This post is <a href="https://creativecommonsusa.org/wp-content/uploads/2018/01/Copyright-and-Open-Licensing-Primer.pdf">not licensed</a> for any purpose, unless otherwise noted.<br> It is provided AS IS without any guarantee of correctness beyond those required for legal reasons.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Intrusive Smart Pointers + Heap Only Types = üíû - Abstraction Haven&url=https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Intrusive Smart Pointers + Heap Only Types = üíû - Abstraction Haven&u=https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Intrusive Smart Pointers + Heap Only Types = üíû - Abstraction Haven&url=https://blog.schichler.dev/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Asteracea/">Asteracea (as of right now) üåº</a><li><a href="/posts/Moving/">Moving</a><li><a href="/posts/Some-thoughts-on-Bubble/">Some thoughts on Bubble</a><li><a href="/posts/Cheese-olive-dish/">Cheese-olive dish</a><li><a href="/posts/Intrusive-Smart-Pointers-+-Heap-Only-Types-=/">Intrusive Smart Pointers + Heap Only Types = üíû</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="/assets/un-cdn/jsdelivr/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Semantic-FFI-Bindings-in-Rust-Reactivating-the-Borrow-Checker/"><div class="card-body"> <em class="timeago small" date="2020-10-31 16:10:00 +0100" >Oct 31, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Semantic FFI Bindings in Rust - Reactivating the Borrow Checker</h3><div class="text-muted small"><p> In this post: Rust references, opaque handles and ownership Likely pitfalls or: c_void isn‚Äôt (yet) C‚Äôs void One big caveat Lifetime-generic opaque references and callbacks ...</p></div></div></a></div><div class="card"> <a href="/posts/Pinning-in-plain-English/"><div class="card-body"> <em class="timeago small" date="2021-11-24 17:10:00 +0100" >Nov 24, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pinning in plain English</h3><div class="text-muted small"><p> A mirrored bell pepper is still clearly the same fruit, but the mirror image, if physically placed outside the mirror, would largely only be compatible with a fundamentally different biology, ...</p></div></div></a></div><div class="card"> <a href="/posts/Asteracea/"><div class="card-body"> <em class="timeago small" date="2022-05-14 15:25:00 +0200" >May 14, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Asteracea (as of right now) üåº</h3><div class="text-muted small"><p> This is a relatively high-level summary post of design decisions I made so far while implementing Asteracea and its related packages like the lignin group of crates. I‚Äôm making this post partially ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Some-thoughts-on-Bubble/" class="btn btn-outline-primary" prompt="Older"><p>Some thoughts on Bubble</p></a> <a href="/posts/Pinning-in-plain-English/" class="btn btn-outline-primary" prompt="Newer"><p>Pinning in plain English</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> ¬© 2024 <a href="https://schichler.dev/">Tamme Schichler</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are not licensed for redistribution by the author. (Feel free to save a copy for personal use, though. You likely don't even need permission for that.)">Most rights reserved.</span> <br> <a href="https://impressum.schichler.dev/">Impressum/Imprint, Datenschutz</a></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/patterns/">patterns</a> <a class="post-tag" href="/tags/walkthrough/">walkthrough</a> <a class="post-tag" href="/tags/cheese/">cheese</a> <a class="post-tag" href="/tags/chili/">chili</a> <a class="post-tag" href="/tags/components/">components</a> <a class="post-tag" href="/tags/composition/">composition</a> <a class="post-tag" href="/tags/crate-included/">crate included</a> <a class="post-tag" href="/tags/critique/">critique</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="/assets/un-cdn/jsdelivr/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/un-cdn/jsdelivr/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/un-cdn/jsdelivr/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
